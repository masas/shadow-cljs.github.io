msgid ""
msgstr ""
"Content-Type: text/plain; charset=UTF-8\n"

msgid "This is a convenient way to test out fixes (even to `shadow-cljs` itself!) without having to clone that project and understand its setup, build, etc."
msgstr "これは、プロジェクトをクローンしてそのセットアップやビルドなどを理解しなくても、(たとえ `shadow-cljs` 自体であっても！)修正をテストアウトするのに便利な方法です。"

msgid "Introduction"
msgstr ""

msgid "`shadow-cljs` provides everything you need to compile your ClojureScript projects with a focus on simplicity and ease of use. The provided build targets abstract away most of the manual configuration so that you only have to configure the essentials for your build. Each target provides optimal defaults for each environment and get an optimized experience during development and in release builds."
msgstr "`shadow-cljs` は、シンプルさと使いやすさに焦点を当てて ClojureScript プロジェクトをコンパイルするために必要なものをすべて提供します。提供されているビルドターゲットは、手動設定のほとんどを抽象化しているので、ビルドに必要な要素だけを設定する必要があります。各ターゲットはそれぞれの環境に最適なデフォルトを提供し、開発中やリリースビルドで最適化されたエクスペリエンスを得ることができます。"

msgid "High-Level Overview"
msgstr ""

msgid "`shadow-cljs` is composed of 2 parts:"
msgstr "`shadow-cljs` は2つの部分から構成されています。"

msgid "The https://clojars.org/thheller/shadow-cljs[shadow-cljs] Clojure library which handles all the actual work."
msgstr "https://clojars.org/thheller/shadow-cljs[shadow-cljs] 実際の作業をすべて処理するClojureライブラリ。"

msgid "The https://www.npmjs.com/package/shadow-cljs[shadow-cljs] `npm` package which provides a convenient interface for running most of the build functionality directly from command line."
msgstr "https://www.npmjs.com/package/shadow-cljs[shadow-cljs] `npm` パッケージは、ほとんどのビルド機能をコマンドラインから直接実行するための便利なインターフェイスを提供します。"

msgid "If desired you can easily integrate the `shadow-cljs` Clojure library into any other Clojure/JVM build tool (eg. https://leiningen.org/[leiningen] or the https://clojure.org/guides/deps_and_cli[Clojure CLI] tools)."
msgstr "必要であれば `shadow-cljs` Clojureライブラリを他のClojure/JVMビルドツール(例: https://leiningen.org/[leiningen]やhttps://clojure.org/guides/deps_and_cli[Clojure CLI]ツール)に簡単に統合することができます。"

msgid "It is recommended to use the `npm` package as that provides a more optimized development experience tailored towards CLJS development."
msgstr "CLJS開発に合わせて最適化された開発体験を提供するため `npm` パッケージを使用することをお勧めします。"

msgid "Basic Workflow"
msgstr ""

msgid "When working with `shadow-cljs` you will be defining one or more builds in the `shadow-cljs.edn` configuration file. Each build will have a `:target` property which represents a configuration preset optimized for the target environment (eg. the Browser, a `node.js` application or a Chrome Extension)."
msgstr "`shadow-cljs` を使うときは `shadow-cljs.edn` 設定ファイルに1つ以上のビルドを定義することになります。各ビルドは `:target` プロパティを持ち、ターゲット環境(ブラウザ `node.js` アプリケーション、Chrome 拡張機能など)に最適化された設定プリセットを表します。"

msgid "Each build can either produce development or release output depending on the command used to trigger the compilation. The standard build commands are: `compile`, `watch` and `release`."
msgstr "各ビルドは、コンパイルのトリガーに使用されるコマンドに応じて、開発またはリリースの出力を生成することができます。標準的なビルドコマンドは以下の通りです。`compile`,`watch`,`release` です。"

msgid "Development Mode"
msgstr ""

msgid "You can either `compile` a development build once or run a `watch` process which will monitor your source files and re-compile them automatically (and live-reload the code if desired)."
msgstr "開発ビルドを一度 `compile` するか `watch` プロセスを実行してソースファイルを監視し、自動的に再コンパイルすることができます (必要に応じてコードをライブリロードすることもできます)。"

msgid "All development builds are optimized for the developer experience with fast feedback cycles and other features like a REPL to directly interact with your running code."
msgstr "すべての開発ビルドは、高速なフィードバックサイクルと、実行中のコードと直接対話するための REPL のような他の機能を備え、開発者の経験に合わせて最適化されています。"

msgid "A development build should never be shipped publicly since they can become quite large and may only work on the machine they were compiled on depending on the `:target`."
msgstr "開発ビルドは非常に大きくなり `:target` によってはコンパイルされたマシン上でしか動作しない可能性があるため、決して公開してはいけません。"

msgid "Release Mode"
msgstr ""

msgid "Creating a `release` build will strip out all the development related code and finally run the code through the Closure Compiler. This is an optimizing Compiler for JavaScript which will significantly reduce the overall size of the code."
msgstr "`release` ビルドを作成すると、開発に関連するすべてのコードが削除され、最終的にClosure Compilerでコードが変換されます。これはJavaScript用の最適化コンパイラで、コード全体のサイズを大幅に削減します。"

msgid "Important Concepts"
msgstr ""

msgid "There are several important concepts that you should familiarize yourself with when using `shadow-cljs`. They are integral to understanding how everything fits together and how the tool works with your code."
msgstr "`shadow-cljs` を使うときには、いくつかの重要な概念を理解しておく必要があります。これらの概念は、すべてのものがどのように組み合わされ、ツールがあなたのコードでどのように動作するかを理解するために不可欠なものです。"

msgid "The Classpath"
msgstr ""

msgid "`shadow-cljs` uses the Java Virtual Machine (JVM) and its \"classpath\" when working with files. This is a virtual filesystem composed of many classpath entries. Each entry is either"
msgstr "`shadow-cljs` は、ファイルを扱う際に Java Virtual Machine (JVM) とその ”classpath\" を使用します。これは、多くのクラスパスエントリで構成された仮想ファイルシステムです。各エントリは"

msgid "A local filesystem directory, managed by `:source-paths` entry in the configuration."
msgstr "設定の `:source-paths` エントリで管理されるローカルファイルシステムディレクトリ。"

msgid "Or a `.jar` file, representing Clojure(Script) or JVM libraries. These are compressed archives containing many files (basically just a `.zip` file). These are added by your `:dependencies`."
msgstr "または、Clojure(Script)やJVMライブラリを表す `.jar` ファイル。これらは多くのファイルを含む圧縮されたアーカイブです(基本的にはただの `.zip` ファイル)。これらは `:dependencies` によって追加されます。"

msgid "In the Clojure(Script) everything is namespaced and each name is expected to resolve to a file. If you have a `(ns demo.app)` namespace the compiler expects to find a `demo/app.cljs` (or `.cljc`) on the classpath. The classpath will be searched in order until it is found. Suppose you configured the `:source-paths [\"src/main\" \"src/test\"]` the compiler will first look for a `src/main/demo/app.cljs` and then `src/test/demo/app.cljs`. When the file is not found on any source path the JVM will begin looking into the `.jar` files on the classpath. When it finds a `demo/app.cljs` at the root of any of the libraries that file it will be used."
msgstr "Clojure(Script)では、すべてのものが名前空間になっており、それぞれの名前はファイルに解決されることが期待されています。名前空間が `(ns demo.app)` の場合、コンパイラはクラスパス上に `demo/app.cljs` (または `.cljc`) を見つけることを期待しています。クラスパスは見つかるまで順番に検索されます。例えば `:source-paths [\"src/main/\" \"src/test/test\"]` を設定したとすると、コンパイラは最初に `src/main/demo/app.cljs` を探し、次に `src/test/demo/app.cljs` を探すことになります。ソースパス上にファイルが見つからない場合、JVMはクラスパス上の `.jar` ファイルを探し始めます。ライブラリのルートに `demo/app.cljs` を見つけると、そのファイルが使用されます。"

msgid "When a filename exists multiple times on the classpath then only the first one is used. Everything on the JVM and Clojure(Script) is namespaced to avoid such conflicts. Very similar to `npm` where each package must have a unique name."
msgstr "ファイル名がクラスパス上に複数回存在する場合、最初のものだけが使用されます。JVMとClojure(Script)上のすべてのものは、そのような衝突を避けるために名前空間が設定されています。各パッケージが一意の名前を持たなければならない `npm` と非常に似ています。"

msgid "It is therefore recommended to be very disciplined about the names you choose and properly namespacing everything. It may seem repetitive to always use `(ns your-company.components.foo)` over `(ns components.foo)` but it will save you from lot of headaches later on."
msgstr "そのため、名前の選択や名前の間隔はきちんと決めておくことをお勧めします。常に `(ns your-company.components.foo)` の上に `(ns components.foo)` を使うことは、繰り返しのように思えるかもしれませんが、後になって多くの頭痛の種を避けることができます。"

msgid "This is unlike `npm` where the package name itself is never used inside the package itself and only relative paths are used."
msgstr "これは `npm` とは異なり、パッケージ名自体がパッケージ内部で使われることはなく、相対パスのみが使われます。"

msgid "Server Mode"
msgstr ""

msgid "`shadow-cljs` can be started in \"server\" mode which is required for long-running tasks such as `watch`. A `watch` will implicitly start the server instance if it is not already running. The server will provide the Websocket endpoint that builds will connect to as well as all the other endpoints for nREPL, Socket REPL and the development HTTP servers."
msgstr "`shadow-cljs` は `watch` のような長時間のタスクを実行する場合に必要な、&#34;server&#34; モードで起動することができます。 `watch` はまだ起動していなければ暗黙のうちにサーバインスタンスを起動します。サーバはビルドが接続するWebsocketエンドポイントを提供し、他のすべてのエンドポイントと同様に nREPL, Socket REPL, 開発用HTTPサーバを提供します。"

msgid "When using the `shadow-cljs` CLI interface all commands will re-use a running server instance JVM instead of starting a new JVM. This is substantially faster since start-up time can be quite slow."
msgstr "`shadow-cljs` CLIインターフェースを使用する場合、すべてのコマンドは新しいJVMを起動する代わりに、実行中のサーバインスタンスJVMを再利用します。これにより、JVM起動時間が非常に遅くなる可能性を排除するので、実質的に速くなります。"

msgid "Once the server is running however you only have to restart it whenever your `:dependencies` change and everything else can be done via the REPL."
msgstr "いったんサーバが起動してしまえば `:dependencies` が変更されたときだけ再起動すればよく、それ以外のことはすべて REPL を使って行うことができます。"

msgid "REPL"
msgstr ""

msgid "The REPL is at the heart of all Clojure(Script) development and every CLI command can also be used directly from the REPL as well. It is absolutely worth getting comfortable with the REPL even if the command line may seem more familiar."
msgstr "REPLはすべてのClojure(Script)開発の中心であり、すべてのCLIコマンドはREPLから直接使用することもできます。たとえコマンドラインがより身近に感じられるかもしれませんが、REPLに慣れることは絶対に価値があります。"

msgid "About this Book"
msgstr ""

msgid "Work in Progress"
msgstr ""

msgid "This is a work in progress. If you find an error, please submit a PR to fix it, or an issue with details of the problem."
msgstr "これは作業中のものです。エラーを発見した場合は、修正のためのPR(訳注：pull request?)、または問題の詳細を記載した問題を投稿してください。"

msgid "Contributing"
msgstr ""

msgid "This source for this book is hosted on https://github.com/shadow-cljs/shadow-cljs.github.io[Github]."
msgstr "この本のソースは https://github.com/shadow-cljs/shadow-cljs.github.io[Github] でホストされています。"

msgid "Conventions Used"
msgstr ""

msgid "There are many examples in this book. Most things used in these should be obvious from their context, but to prevent misunderstanding it is important to know the author's intentions."
msgstr "本書には多くの例が掲載されています。これらの中で使われているものの多くは、文脈から明らかなはずですが、誤解を防ぐためには、著者の意図を知ることが大切です。"

msgid "When command-line examples are given we may include BASH comments (starting with `#`), and will usually include the standard user UNIX prompt of `$` to indicate separation of the command from its output."
msgstr "コマンドラインの例を示す際には、BASH のコメント (`#` で始まる) を含めることがあり、通常は、コマンドとその出力を分離することを示すために、標準的なユーザ UNIX プロンプト `$` を含めます。"

msgid ""
"# A comment. This command lists files:\n"
"$ ls -l\n"
"shadow-cljs.edn\n"
"project.clj\n"
"..."
msgstr ""

msgid "Many of the examples are of the configuration file for the compiler. This file contains an EDN map. Where we have already discussed required options we will often elide them for clarity. In this case we'll usually include an ellipsis to indicate \"content that is required but isn't in our current focus\":"
msgstr "例の多くは、コンパイラの設定ファイルです。このファイルには EDN マップが含まれています。すでに必須オプションについて説明している場合は、わかりやすくするために省略します。この場合、\"必要だが現在の焦点には入っていない内容 \"を示すために、通常は省略記号(\"...\")を入れます。"

msgid "Example 1. Specify dependencies"
msgstr "Example 1. 依存関係の指定"

msgid "{:dependencies [[lib \"1.0\"]]}"
msgstr ""

msgid "Example 2. Add source paths"
msgstr "Example 2. ソースパスの追加"

msgid ""
"{...\n"
" :source-paths [\"src\"]\n"
" ...}"
msgstr ""

msgid "This allows us to concisely include enough context to understand the nesting of the configuration of interest:"
msgstr "これにより、関心のある構成の入れ子を理解するのに十分なコンテキストを簡潔に含めることができます:"

msgid "Example 3. Nested option"
msgstr "Example 3. 入れ子になったオプション"

msgid ""
"{...\n"
" :builds {:build-id {...\n"
"                     :output-dir \"resources/public/js\"}}}"
msgstr ""

msgid "Code examples may be similarly shortened."
msgstr "コード例も同様に短縮しています。"

msgid "Installation"
msgstr ""

msgid "Standalone via <code>npm</code>"
msgstr "`npm` 経由のスタンドアローン"

msgid "You will need:"
msgstr "下記を必要とします:"

msgid "https://nodejs.org[`node.js`] (v6.0.0+, most recent version preferred)"
msgstr "https://nodejs.org[`node.js`] (v6.0.0.0+, 最新バージョンを推奨)"

msgid "https://www.npmjs.com[`npm`] or https://www.yarnpkg.com[`yarn`]"
msgstr "https://www.npmjs.com[`npm`] または https://www.yarnpkg.com[`yarn`]"

msgid "Any Java SDK (Version 8 or higher). http://openjdk.java.net/install/[OpenJDK] or http://www.oracle.com/technetwork/java/javase/downloads/index.html[Oracle]"
msgstr "Java SDK (バージョン8以上) http://openjdk.java.net/install/[OpenJDK]または http://www.oracle.com/technetwork/java/javase/downloads/index.html[Oracle]のいずれか。"

msgid "In your project directory you'll need a `package.json`. If you do not have one yet you can create one by running `npm init -y`. If you don't have a project directory yet consider creating it by running"
msgstr ""
"プロジェクトディレクトリに `package.json` が必要です。もしまだない場合は、npm init -yを実行することで作成できます。\n"
"またプロジェクトディレクトリがない場合は"

msgid "$ npx create-cljs-project my-project"
msgstr ""

msgid "This will create all the necessary basic files and you can skip the following commands."
msgstr "これで必要な基本ファイルがすべて作成されるので、以下のコマンドをスキップすることができます。"

msgid "If you have a `package.json` already and just want to add `shadow-cljs` run"
msgstr "既に `package.json` があり `shadow-cljs` を追加したい場合は、以下のように実行してください。"

msgid "NPM"
msgstr ""

msgid "$ npm install --save-dev shadow-cljs"
msgstr ""

msgid "Yarn"
msgstr ""

msgid "$ yarn add --dev shadow-cljs"
msgstr ""

msgid "For convenience you can run `npm install -g shadow-cljs` or `yarn global add shadow-cljs`. This will let you run the `shadow-cljs` command directly later. There should always be a shadow-cljs version installed in your project, the global install is optional."
msgstr "便利なように `npm install -g shadow-cljs` や `yarn global add shadow-cljs` を実行することができます。これにより、後で `shadow-cljs` コマンドを直接実行できるようになります。プロジェクトには常にshadow-cljsのバージョンがインストールされているはずです。"

msgid "Library"
msgstr ""

msgid "Although it is recommended to run the standalone version via `npm` you can also embed `shadow-cljs` into any other Clojure JVM tool (eg. `lein`, `boot`, ...)."
msgstr "スタンドアロン版を `npm` 経由で実行することを推奨しますが `shadow-cljs` を他の Clojure JVM ツール (例えば `lein`, `boot`, .... など) に埋め込むこともできます。"

msgid "The artifact can be found at:"
msgstr "アーティファクトは以下の場所にあります。"

msgid "Usage"
msgstr ""

msgid "`shadow-cljs` can be used in many different ways but the general workflow stays the same."
msgstr "`shadow-cljs` は様々な方法で使うことができますが、一般的なワークフローは同じです。"

msgid "During development you have the option to `compile` a build once or run a `watch` worker which watches your source files for changes and re-compiles them automatically. When <<devtools, enabled>> the `watch` will also hot-reload your code and provide a REPL. During development the focus is on developer experience with fast feedback cycles. Development code should never be shipped to the public."
msgstr "開発中にはビルドを一度コンパイルするか `watch` ワーカーを実行してソースファイルの変更を監視し、自動的に再コンパイルするかを選択することができます。 <<devtools, enabled>> の場合 `watch` ワーカーはコードをホットリロードして REPL を提供します。開発中は、開発者の経験と高速なフィードバックサイクルに焦点を当てています。開発コードは決して公開されるべきではありません。"

msgid "When it is time to get serious you create a <<release, `release`>> build which creates an optimized build suitable for production. For this the https://developers.google.com/closure/compiler/[Closure Compiler] is used which applies some seriously `:advanced` optimizations to your code to create the most optimal output available. This may require some <<externs, tuning>> to work properly when using lots of interop with native JavaScript but works flawlessly for ClojureScript (and the code from the https://developers.google.com/closure/library/[Closure Library])."
msgstr "いよいよ本気を出す時が来た時には、<<release,`release`>>ビルドを作成し、本番に適した最適化されたビルドを作成します。このために https://developers.google.com/closure/compiler/[Closure Compiler] を使用します。これは、あなたのコードに `:advanced` 最適化を適用して、最適な出力を作成します。これは、ネイティブのJavaScriptで多くのinteropを使用しているときに適切に動作するために、いくつかの<<externs, tuning>>を必要とするかもしれませんが、ClojureScript(とhttps://developers.google.com/closure/library/[Closure Library]からのコード)では完璧に動作します。"

msgid "Command Line"
msgstr ""

msgid "If <<Installation, installed>> globally, you can use the `shadow-cljs` command directly."
msgstr "グローバルに<<Installation,インストール>>する場合は `shadow-cljs` コマンドを直接使うことができます。"

msgid "$ shadow-cljs help"
msgstr ""

msgid "If you prefer to only use the local `npm` install you can invoke it via `npx` or `yarn`."
msgstr "ローカルの `npm` インストールのみを使いたい場合は `npx` や `yarn` を使って起動することができます。"

msgid ""
"# npm\n"
"$ npx shadow-cljs help\n"
"\n"
"# yarn\n"
"$ yarn shadow-cljs help\n"
"\n"
"# manually\n"
"$ ./node_modules/.bin/shadow-cljs help"
msgstr ""

msgid "The guide will assume there is a global install to keep examples short but this is not required."
msgstr "このガイドでは、例を短くするためにグローバルインストールを想定していますが、これは必須ではありません。"

msgid "Commonly used shadow-cljs commands during development"
msgstr "開発中によく使われる shadow-cljs コマンド"

msgid ""
"# compile a build once and exit\n"
"$ shadow-cljs compile app\n"
"\n"
"# compile and watch\n"
"$ shadow-cljs watch app\n"
"\n"
"# connect to REPL for the build (available while watch is running)\n"
"$ shadow-cljs cljs-repl app\n"
"\n"
"# connect to standalone node repl\n"
"$ shadow-cljs node-repl"
msgstr ""
"# 一度ビルドをコンパイルして終了する\n"
"$ shadow-cljs compile app\n"
"\n"
"# コンパイルして見張る\n"
"$ shadow-cljs watch app\n"
"\n"
"# ビルド用の REPL に接続します (ウォッチの実行中に利用可能)\n"
"$ shadow-cljs cljs-repl app\n"
"\n"
"# スタンドアロン node repl に接続\n"
"$ shadow-cljs node-repl"

msgid "Running a release build optimized for production use."
msgstr "本番用に最適化されたリリースビルドの実行"

msgid "$ shadow-cljs release app"
msgstr ""

msgid "Sometimes you may run into some release issues due to `:advanced` compilation. These commands can help track down the causes."
msgstr "時々 `:advanced` のコンパイルに起因するリリース上の問題が発生することがあります。これらのコマンドは原因を突き止めるのに役立ちます。"

msgid "Release debugging commands."
msgstr ""

msgid ""
"$ shadow-cljs check app\n"
"$ shadow-cljs release app --debug"
msgstr ""

msgid "A `shadow-cljs` command can be fairly slow to start. To improve this `shadow-cljs` can run in \"server mode\" which means that a dedicated process is started which all other commands can use to execute a lot faster since they won't have to start a new JVM/Clojure instance."
msgstr "`shadow-cljs` コマンドの起動はかなり遅くなります。これを改善するために `shadow-cljs` は \"server mode\" で実行することができます。専用のプロセスで開始され、毎回新しい JVM/Clojure インスタンスを起動する必要がないので、他のすべてのコマンドがより速く実行できます。"

msgid "Commands that do long-running things implicitly start a server instance (eg. `watch`) but it is often advisable to have a dedicated server process running."
msgstr "長時間実行するようなコマンドは、暗黙のうちにサーバインスタンスを起動しますが(例: `watch`)、多くの場合専用のサーバプロセスを実行しておくことを推奨します。"

msgid "You can run the process in the foreground in a dedicated terminal. Use `CTRL+C` to terminate the server."
msgstr "専用のターミナルでフォアグラウンドでプロセスを実行することができます。サーバを終了させるには `CTRL+C` を使います。"

msgid ""
"$ shadow-cljs server\n"
"\n"
"# or (if you'd like REPL to control the server process)\n"
"$ shadow-cljs clj-repl"
msgstr ""
"$ shadow-cljs server\n"
"\n"
"# または (サーバプロセスを制御するためにREPLを使用したい場合は)\n"
"$ shadow-cljs clj-repl"

msgid "You can also run the server in the background controlled via the common `start|stop|restart` functions."
msgstr "また、共通の `start|stop|restart` 関数で制御されたバックグラウンドでサーバを実行することもできます。"

msgid ""
"$ shadow-cljs start\n"
"$ shadow-cljs stop\n"
"$ shadow-cljs restart"
msgstr ""

msgid "Once any server is running every other command will use that and run much faster."
msgstr "どのサーバーでも一旦実行されると、他のすべてのコマンドはそれを使用して、はるかに高速に実行されます。"

msgid "Build Tool Integration"
msgstr ""

msgid "`shadow-cljs` can integrate with other Clojure tools since the primary distribution is just a `.jar` file available via https://clojars.org/thheller/shadow-cljs[Clojars]. By default your `:dependencies` are managed via `shadow-cljs.edn` but you can use other builds tools to manage your dependencies as well."
msgstr "主なディストリビューションは https://clojars.org/thheller/shadow-cljs[Clojars] から入手できる `.jar` ファイルだけなので `shadow-cljs` は他の Clojure ツールと統合することができます。デフォルトでは `:dependencies` は `shadow-cljs.edn` で管理されていますが、他のビルドツールを使って依存関係を管理することもできます。"

msgid "It is strongly recommended to use the standalone `shadow-cljs` version. The command does a lot of things to optimize the user experience (e.g. faster startup) which are not done by other tools. You'll also save yourself a lot of headaches dealing with dependency conflicts and other related errors."
msgstr "スタンドアロンの `shadow-cljs` バージョンを使用することを強くお勧めします。このコマンドは、他のツールではできないユーザーエクスペリエンスを最適化するために多くのことを行います (例えば、起動の高速化など)。また、依存関係の競合やその他の関連するエラーを処理する手間も省けます。"

msgid "Leiningen"
msgstr ""

msgid "If you'd like to use https://leiningen.org/[Leiningen] to manage your dependencies, you can do so by adding a `:lein` entry to your `shadow-cljs.edn` config. With this setting, the `shadow-cljs` command will use `lein` to launch the JVM, ignoring any `:source-paths` and `:dependencies` in `shadow-cljs.edn`; relying instead on `lein` to set them from `project.clj`."
msgstr "https://leiningen.org/[Leiningen]を使って依存関係を管理したい場合は `shadow-cljs.edn` の設定に `:lein` エントリを追加してください。この設定では `shadow-cljs` コマンドは `lein` を使って JVM を起動し `shadow-cljs.edn` の `:source-paths` や `:dependencies` は無視します。"

msgid ""
"{:lein true\n"
" ; :source-paths and :dependencies are now ignored in this file\n"
" ; configure them via project.clj\n"
" :builds { ... }"
msgstr ""
"{:lein true\n"
" ; :source-paths と :dependencies はこのファイルでは無視され\n"
" ; project.clj を通して設定されます\n"
" :builds { ... }"

msgid "Using a dedicated <code>lein</code> profile"
msgstr "専用の `lein` プロファイルを使う"

msgid ""
"{:lein {:profile \"+cljs\"}\n"
" :builds {...}}"
msgstr ""

msgid "Sample project.clj"
msgstr ""

msgid ""
"(defproject my-awesome-project\n"
"  ...\n"
"  :profiles\n"
"  {:cljs\n"
"   {:source-paths [\"src/cljs\"]\n"
"    :dependencies [[thheller/shadow-cljs \"...\"]\n"
"                   [reagent \"0.8.1\"]]}})"
msgstr ""

msgid "When using `project.clj` to manage your `:dependencies` you must manually include the https://clojars.org/thheller/shadow-cljs[thheller/shadow-cljs] artifact in your `:dependencies` (directly or in a profile)."
msgstr "`project.clj` を使って `:dependencies` を管理する場合、手動で https://clojars.org/thheller/shadow-cljs[thheller/shadow-cljs] アーティファクトを `:dependencies` (直接またはプロファイル) に含めなければなりません。"

msgid "When you are running into weird Java Stackstraces when starting `shadow-cljs` or trying compile builds you may have a dependency conflict. It is very important that `shadow-cljs` is used with proper matching `org.clojure/clojurescript` and `closure-compiler` versions. You can check via `lein deps :tree` and the required versions are listed on https://clojars.org/thheller/shadow-cljs[clojars] (on the right side)."
msgstr "`shadow-cljs` を起動したり、ビルドをコンパイルしようとしたときに、奇妙な Java Stackstraces が発生する場合、依存関係の競合があるかもしれません。`shadow-cljs` が `org.clojure/clojurescript` と `closure-compiler` のバージョンにマッチした状態で使われていることが非常に重要です。必要なバージョンは `lein deps :tree` で確認でき、https://clojars.org/thheller/shadow-cljs[clojars] (右側) にリストアップされています。"

msgid "Running Tasks Directly From Leiningen"
msgstr "Leiningenから直接タスクを実行する"

msgid "You may also directly execute `shadow-cljs` commands via `lein` if you prefer to not use the `shadow-cljs` command itself."
msgstr "また `shadow-cljs` コマンド自体を使いたくない場合は `lein` を使って `shadow-cljs` コマンドを直接実行することもできます。"

msgid "It is recommended to still use the `shadow-cljs` command to run commands since that will take full advantage of a running server mode instance. This will run commands substantially faster than launching additional JVMs when using `lein` directly."
msgstr "コマンドを実行するには `shadow-cljs` コマンドを使用することをお勧めします。これは `lein` を直接使用する場合に追加の JVM を起動するよりも、コマンドの実行速度を大幅に向上させることができます。"

msgid "Just compile :dev mode once, no REPL or live-reload:"
msgstr "REPLやライブリロードをせずに、一度だけ :devモードでコンパイルする。"

msgid "$ lein run -m shadow.cljs.devtools.cli compile build-id"
msgstr ""

msgid "Create a :release mode optimized build:"
msgstr ":release モードに最適化されたビルドを作成する。"

msgid "$ lein run -m shadow.cljs.devtools.cli release build-id"
msgstr ""

msgid "tools.deps / deps.edn"
msgstr ""

msgid "The new https://clojure.org/guides/deps_and_cli[deps.edn] can also be used to manage your `:dependencies` and `:source-paths` instead of using the built-in methods or `lein`. All `shadow-cljs` commands will then be launched via the new `clojure` utility instead."
msgstr "新しい https://clojure.org/guides/deps_and_cli[deps.edn] は、組み込みのメソッドや `lein` を使う代わりに `:dependencies` や `:source-paths` を管理するために使うこともできます。すべての `shadow-cljs` コマンドは、代わりに新しい `clojure` ユーティリティを使って起動されます。"

msgid "`tools.deps` is still changing quite frequently. Make sure you are using the latest version."
msgstr "`tools.deps` はまだかなりの頻度で変更されています。最新のバージョンを使用していることを確認してください。"

msgid "To use this set the `:deps true` property in your config. It is also possible to configure which `deps.edn` aliases should be used."
msgstr "これを使用するには、設定で `:deps true` プロパティを設定します。どの `deps.edn` エイリアスを使用するかを設定することもできます。"

msgid "You must add the `thheller/shadow-cljs` artifact to your `deps.edn` manually."
msgstr "手動で `deps.edn` に `thheller/shadow-cljs` アーティファクトを追加する必要があります。"

msgid "Simple <code>shadow-cljs.edn</code> example"
msgstr "Simple `shadow-cljs.edn` example"

msgid ""
"{:deps true\n"
" :builds ...}"
msgstr ""

msgid "Simple <code>deps.edn</code> example"
msgstr "Simple `deps.edn` example"

msgid ""
"{:paths [...]\n"
" :deps {thheller/shadow-cljs {:mvn/version <latest>}}}"
msgstr ""

msgid "Example <code>shadow-cljs.edn</code> with :cljs alias"
msgstr "Example `shadow-cljs.edn` with :cljs alias"

msgid ""
"{:deps {:aliases [:cljs]}\n"
" :builds ...}"
msgstr ""

msgid "Example <code>deps.edn</code>"
msgstr "Example `deps.edn`"

msgid ""
"{:paths [...]\n"
" :deps {...}\n"
" :aliases\n"
" {:cljs\n"
"  {:extra-deps {thheller/shadow-cljs {:mvn/version <latest>}}}}"
msgstr ""

msgid "Running with `clj` directly."
msgstr "直接 `clj` で実行するなら"

msgid ""
"{:paths [...]\n"
" :deps {...}\n"
" :aliases\n"
" {:shadow-cljs\n"
"  {:extra-deps {thheller/shadow-cljs {:mvn/version <latest>}}\n"
"   :main-opts [\"-m\" \"shadow.cljs.devtools.cli\"]}}}"
msgstr ""

msgid "clj -A:shadow-cljs watch app"
msgstr ""

msgid "You may also specify additional aliases via the command line using `-A`, eg. `shadow-cljs -A:foo:bar ...`."
msgstr "コマンドラインで `-A` を使って追加のエイリアスを指定することもできます。 例. `shadow-cljs -A:foo:bar ...`.など。"

msgid "Aliases are only applied when a new instance/server is started. They do not apply when connecting to a running server using the `shadow-cljs` command. Running via `clj` will always start a new JVM and does not support server-mode."
msgstr "エイリアスが適用されるのは新しいインスタンス/サーバが起動したときだけです。これらは `shadow-cljs` コマンドを使って実行中のサーバに接続しているときには適用されません。`clj` を使って実行すると、常に新しい JVM が起動され、サーバモードはサポートされません。"

msgid "Boot"
msgstr ""

msgid "The authors have little Boot experience, so this chapter is in need of contributions. We understand that Boot allows you to build your tool chain out of functions. Since `shadow-cljs` is a normal JVM library, you can call functions within it to invoke tasks."
msgstr "著者は Boot の経験がほとんどないため、この章では貢献を必要としています。Bootでは、関数からツールチェーンを構築できることを理解しています。`shadow-cljs` は通常の JVM ライブラリなので、その中の関数を呼び出してタスクを呼び出すことができます。"

msgid "Some boot tasks are available here: https://github.com/jgdavey/boot-shadow-cljs"
msgstr "いくつかのbootタスクはここにあります: https://github.com/jgdavey/boot-shadow-cljs"

msgid "Running Clojure Code"
msgstr ""

msgid "You can use the `shadow-cljs` CLI to call specific Clojure functions from the command line. This is useful when you want run some code before/after certain tasks. Suppose you wanted to `rsync` the output of your `release` build to a remote server."
msgstr "コマンドラインから特定のClojure関数を呼び出すために `shadow-cljs` CLIを使うことができます。これは、特定のタスクの前後にコードを実行したい場合に便利です。例えば `release` ビルドの出力をリモートサーバに `rsync` したいとします。"

msgid "Example Clojure Namespace in <code>src/my/build.clj</code>"
msgstr "Example Clojure Namespace in `src/my/build.clj`"

msgid ""
"(ns my.build\n"
"  (:require\n"
"    [shadow.cljs.devtools.api :as shadow]\n"
"    [clojure.java.shell :refer (sh)]))\n"
"\n"
"(defn release []\n"
"  (shadow/release :my-build)\n"
"  (sh \"rsync\" \"-arzt\" \"path/to/output-dir\" \"my@server.com:some/path\"))"
msgstr ""

msgid "Running the <code>release</code> function"
msgstr "Running the `release` function"

msgid ""
"$ shadow-cljs clj-run my.build/release\n"
"# or\n"
"$ shadow-cljs run my.build/release"
msgstr ""

msgid "You can pass arguments to the invoked functions via the command line."
msgstr "呼び出された関数には、コマンドラインを介して引数を渡すことができます。"

msgid "Using arguments via normal Clojure fn args"
msgstr "通常の Clojure fn args で引数を使用する"

msgid ""
"...\n"
"(defn release [server]\n"
"  (shadow/release :my-build)\n"
"  (sh \"rsync\" \"-arzt\" \"path/to/output-dir\" server))"
msgstr ""

msgid "Passing the server from the command line"
msgstr "コマンドラインからサーバーへの受け渡し"

msgid "$ shadow-cljs clj-run my.build/release my@server.com:some/path"
msgstr ""

msgid "The usual `(defn release [& args])` structure also works if you want to parse the args with something like https://github.com/clojure/tools.cli[tools.cli]."
msgstr "通常の `(defn release [& args])` 構造体は、 https://github.com/clojure/tools.cli[tools.cli] のように引数を解析したい場合にも動作します。"

msgid "You have access to the full power of Clojure here. You can build entire tools on top of this if you like. As a bonus everything you write this way is also directly available via the Clojure REPL."
msgstr "あなたはここでClojureのフルパワーにアクセスすることができます。お望みならば、この上にツール全体を構築することができます。ボーナスとして、この方法で書いたものはすべてClojure REPL経由で直接利用可能です。"

msgid "When the <<server-mode, server>> is running the namespace will not be reloaded automatically, it will only be loaded once. It is recommended to do the development using a REPL and reload the file as usual (eg. `(require 'my.build :reload)`). You may also run `shadow-cljs clj-eval \"(require 'my.build :reload)\"` to reload manually from the command line."
msgstr "<<server-mode, server>>を実行している場合、名前空間は自動的にリロードされず、一度だけロードされます。REPLを使って開発を行い、通常通りリロードすることをお勧めします(例: `(require 'my.build :reload)`)。また `shadow-cljs clj-eval \"(require 'my.build :reload)\"` を実行して、コマンドラインから手動でリロードすることもできます。"

msgid "Calling watch via clj-run"
msgstr ""

msgid "By default the functions called by `clj-run` only have access to a minimal `shadow-cljs` runtime which is enough to run `compile`, `release` and any other Clojure functionality. The JVM will terminate when your function completes."
msgstr "デフォルトでは `clj-run` によって呼び出された関数は `compile`, `release` や他のClojure機能を実行するのに十分な最小限の `shadow-cljs` ランタイムにしかアクセスできません。JVMは、関数が完了すると終了します。"

msgid "If you want to start a `watch` for a given build you need to declare that the function you are calling requires a full server. This will cause the process to stay alive until you explicitly call `(shadow.cljs.devtools.server/stop!)` or `CTRL+C` the process."
msgstr "あるビルドに対して `watch` を起動したい場合、呼び出した関数がフルサーバを必要とすることを宣言する必要があります。これにより、明示的に `(shadow.cljs.devtools.server/stop!)` を呼び出すか `CTRL+C` でプロセスを起動するまでプロセスは生きたままになります。"

msgid ""
"(ns demo.run\n"
"  (:require [shadow.cljs.devtools.api :as shadow]))\n"
"\n"
";; this fails because a full server instance is missing\n"
"(defn foo\n"
"  [& args]\n"
"  (shadow/watch :my-build))\n"
"\n"
";; this metadata will ensure that the server is started so watch works\n"
"(defn foo\n"
"  {:shadow/requires-server true}\n"
"  [& args]\n"
"  (shadow/watch :my-build))"
msgstr ""
"(ns demo.run\n"
"  (:require [shadow.cljs.devtools.api :as shadow]))\n"
"\n"
";; これは、完全なサーバインスタンスがないために失敗します。\n"
"(defn foo\n"
"  [& args]\n"
"  (shadow/watch :my-build))\n"
"\n"
";; このメタデータはサーバが起動されていることを確認します。\n"
"(defn foo\n"
"  {:shadow/requires-server true}\n"
"  [& args]\n"
"  (shadow/watch :my-build))"

msgid "The REPL is a very powerful tool to have when working with Clojure(Script) code. `shadow-cljs` provides several built-in variants that let you get started quickly as well as variants that are integrated into your standard builds."
msgstr "REPLはClojure(Script)コードを扱うときに持っていると非常に強力なツールです。`shadow-cljs` は、標準ビルドに統合されたバリアントだけでなく、すぐに始められるようにいくつかの組み込みバリアントを提供しています。"

msgid "When you quickly want to test out some code the built-in REPLs should be enough. If you need more complex setups that also do stuff on their own it is best to use an actual build."
msgstr "すぐにいくつかのコードをテストしたい場合は、組み込みの REPL で十分です。より複雑なセットアップを必要とする場合は、実際のビルドを使用するのがベストです。"

msgid "ClojureScript REPL"
msgstr ""

msgid "By default you can choose between a `node-repl` and a `browser-repl`. They both work similarly and the differentiating factor is that one runs in a managed `node.js` process while the others opens a Browser Window that will be used to eval the actual code."
msgstr "デフォルトでは `node-repl` と `browser-repl` のどちらかを選ぶことができます。どちらも似たような動作をしますが、一方は管理された `node.js` プロセスで動作し、他方は実際のコードを評価するために使用されるブラウザウィンドウを開くという点が違います。"

msgid "Node REPL"
msgstr ""

msgid "$ shadow-cljs node-repl"
msgstr ""

msgid "This starts a blank CLJS REPL with an already connected `node` process."
msgstr "これは、すでに接続されている `node` プロセスで空のCLJS REPLを起動します。"

msgid "If you exit the Node REPL the `node` process is also killed!"
msgstr "ノードREPLを終了した場合 `node` プロセスも終了します。"

msgid "`node-repl` lets you get started without any additional configuration. It has access to all your code via the usual means, ie. `(require '[your.core :as x])`. Since it is not connected to any build it does not do any automatic rebuilding of code when your files change and does not provide hot-reload."
msgstr "`node-repl` を使うと、追加の設定なしに始めることができます。これは通常の方法、すなわち `(require '[your.core :as x])` ですべてのコードにアクセスすることができます。ビルドに接続されていないので、ファイルが変更されてもコードの自動再構築は行われず、ホットリロードも行いません。"

msgid "Browser REPL"
msgstr ""

msgid "$ shadow-cljs browser-repl"
msgstr ""

msgid "This starts a blank CLJS REPL and will open an associated Browser window where the code will execute. Besides running in the Browser this has all the same functionality as the above `node-repl`."
msgstr "これは空のCLJS REPLを起動し、コードが実行される関連するブラウザウィンドウを開きます。ブラウザで実行するだけでなく、これは上記の `node-repl` と同じ機能をすべて持っています。"

msgid "If you close the Browser window the REPL will stop working."
msgstr "ブラウザのウィンドウを閉じると、REPLは動作を停止します。"

msgid "Build-specific REPL"
msgstr ""

msgid "`node-repl` and `browser-repl` work without any specific build configuration. That means they'll only do whatever you tell them to do but nothing on their own."
msgstr "`node-repl` と `browser-repl` は特定のビルド設定をしなくても動作します。つまり、あなたが指示したことは何でもできるだけで、それ自体は何もしません。"

msgid "If you want to build a specific thing you should configure a build using one of the provided build-targets. Most of them automatically inject the necessary code for a ClojureScript REPL. It should not require any additional configuration. For the build CLJS REPL to work you need 2 things"
msgstr "特定のものをビルドしたい場合は、提供されている build-targets の一つを使ってビルドを設定する必要があります。それらのほとんどは、ClojureScript REPLのために必要なコードを自動的に注入します。追加の設定は必要ありません。ビルドCLJS REPLが動作するためには、2つのものが必要です。"

msgid "a running `watch` for your build"
msgstr "ビルド用に実行中の `watch`"

msgid "connect the JS runtime of the `:target`. Meaning if you are using the `:browser` target you need to open a Browser that has the generated JS loaded. For node.js builds that means running the `node` process."
msgstr "`:target` の JS ランタイムに接続します。つまり `:browser` ターゲットを使用している場合は、生成された JS が読み込まれたブラウザを開く必要があります。node.jsのビルドでは `node` プロセスを実行することを意味します。"

msgid "Once you have both you can connect to the CLJS REPL via the command line or from the Clojure REPL."
msgstr "両方が揃ったら、コマンドラインまたはClojure REPLからCLJS REPLに接続することができます。"

msgid "CLI"
msgstr ""

msgid ""
"$ shadow-cljs watch build-id\n"
"...\n"
"\n"
"# different terminal\n"
"$ shadow-cljs cljs-repl build-id\n"
"shadow-cljs - connected to server\n"
"[3:1]~cljs.user=>"
msgstr ""
"$ shadow-cljs watch build-id\n"
"...\n"
"\n"
"# 別のターミナルウィンドウ$ shadow-cljs cljs-repl build-id\n"
"shadow-cljs - connected to server\n"
"[3:1]~cljs.user=>"

msgid ""
"$ shadow-cljs clj-repl\n"
"...\n"
"[2:0]~shadow.user=> (shadow/watch :browser)\n"
"[:browser] Configuring build.\n"
"[:browser] Compiling ...\n"
"[:browser] Build completed. (341 files, 1 compiled, 0 warnings, 3,19s)\n"
":watching\n"
"[2:0]~shadow.user=> (shadow/repl :browser)\n"
"[2:1]~cljs.user=>"
msgstr ""

msgid "Type `:repl/quit` to exit the REPL. This will only exit the REPL, the `watch` will remain running."
msgstr "REPLを終了するには `:repl/quit` とタイプします。これはREPLを終了するだけで `watch` は実行されたままです。"

msgid "You may run multiple `watch` \"workers\" in parallel and connect/disconnect to their REPLs at any given time."
msgstr "複数の `watch` \"worker\" を並行して実行し、それらの REPL に接続/切断することができます。"

msgid "No connected runtime error."
msgstr "接続不能ランタイムエラー"

msgid ""
"[3:1]~cljs.user=> (js/alert \"foo\")\n"
"There is no connected JS runtime."
msgstr ""

msgid "If you see this you need to open your App in the Browser or start the `node` process."
msgstr "これが表示された場合は、ブラウザでアプリを開くか `node` プロセスを開始する必要があります。"

msgid "Clojure REPL"
msgstr ""

msgid "A Clojure REPL is also provided in addition to the provided ClojureScript REPLs. This is can be used to control the `shadow-cljs` process and run all other build commands through it. You can start with a Clojure REPL and then upgrade it to a CLJS REPL at any point (and switch back)."
msgstr "提供されているClojureScript REPLに加えて、Clojure REPLも提供されています。これは `shadow-cljs` プロセスを制御し、それを通して他のすべてのビルドコマンドを実行するために使用することができます。Clojure REPLから始めて、いつでもCLJS REPLにアップグレードすることができます。"

msgid "Running from the CLI"
msgstr ""

msgid ""
"$ shadow-cljs clj-repl\n"
"...\n"
"shadow-cljs - REPL - see (help), :repl/quit to exit\n"
"[1:0]~shadow.user=>"
msgstr ""

msgid "The `shadow.cljs.devtools.api` namespace has functions that map more or less 1:1 to the CLI counterparts. It is aliased as `shadow` by default."
msgstr "名前空間 `shadow.cljs.devtools.api` は、多かれ少なかれCLIに対応する関数を持っています。デフォルトでは `shadow` という名前でエイリアスされています。"

msgid "Example commands"
msgstr ""

msgid ""
";; shadow-cljs watch foo\n"
"(shadow.cljs.devtools.api/watch :foo)\n"
";; this is identical, due to the provided ns alias\n"
"(shadow/watch :foo)\n"
";; shadow-cljs watch foo --verbose\n"
"(shadow/watch :foo {:verbose true})\n"
";; shadow-cljs compile foo\n"
"(shadow/compile :foo)\n"
";; shadow-cljs release foo\n"
"(shadow/release :foo)\n"
"\n"
";; shadow-cljs browser-repl\n"
"(shadow/browser-repl)\n"
";; shadow-cljs node-repl\n"
"(shadow/node-repl)\n"
";; shadow-cljs cljs-repl foo\n"
"(shadow/repl :foo)\n"
"\n"
";; Once you are in a CLJS REPL you can use\n"
":repl/quit\n"
";; or\n"
":cljs/quit\n"
";; to drop back down to CLJ."
msgstr ""

msgid "Embedded"
msgstr ""

msgid "It is also possible to use `shadow-cljs` entirely from within any other CLJ process. As long as the `thheller/shadow-cljs` artifact was loaded on the classpath you are good to go."
msgstr "また、他のCLJプロセス内から `shadow-cljs` を完全に使用することも可能です。クラスパスに `thheller/shadow-cljs` アーティファクトがロードされていれば問題ありません。"

msgid "Example using <code>lein repl</code>"
msgstr "Example using `lein repl`"

msgid ""
"$ lein repl\n"
"nREPL server started on port 57098 on host 127.0.0.1 - nrepl://127.0.0.1:57098\n"
"REPL-y 0.4.3, nREPL 0.6.0\n"
"Clojure 1.10.0\n"
"...\n"
"\n"
"user=> (require '[shadow.cljs.devtools.server :as server])\n"
"nil\n"
"user=> (server/start!)\n"
"...\n"
":shadow.cljs.devtools.server/started\n"
"user=> (require '[shadow.cljs.devtools.api :as shadow])\n"
"nil\n"
"user=> (shadow/compile :foo)\n"
"..."
msgstr ""

msgid "You can stop the embedded server by running `(shadow.cljs.devtools.server/stop!)`. This will also stop all running build processes."
msgstr "`(shadow.cljs.devtools.server/stop!)` これは実行中のビルドプロセスもすべて停止します。"

msgid "If you want to switch to a CLJS REPL this may require additional setup in the tool you used to start the server in. Since `lein` will default to using nREPL it will require configuring additional nREPL `:middleware`. When using `clj` you are good to go since it doesn't use nREPL."
msgstr "CLJS REPLに切り替えたい場合は、サーバを起動する際に使用したツールで追加の設定が必要になるかもしれません。 `lein` はデフォルトでnREPLを使うようになっているので、追加のnREPL `:middleware` を設定する必要があります。 `clj` を使う場合は、nREPLを使わないので問題ありません。"

msgid "Configuration"
msgstr ""

msgid "`shadow-cljs` is configured by a `shadow-cljs.edn` file in your project root directory. You can create a default one by running `shadow-cljs init`. It should contain a map with some global configuration and a `:builds` entry for all your builds."
msgstr "`shadow-cljs` はプロジェクトのルートディレクトリにある `shadow-cljs.edn` ファイルによって設定されます。デフォルトのファイルは `shadow-cljs init` を実行することで作成できます。このファイルには、グローバルな設定を含むマップと、すべてのビルド用の `:builds` エントリが含まれているはずです。"

msgid ""
"{:source-paths [...]\n"
" :dependencies [...]\n"
" :builds {...}}"
msgstr ""

msgid "An example config could look like this:"
msgstr "設定例は以下のようになります。"

msgid ""
"{:dependencies\n"
" [[reagent \"0.8.0-alpha2\"]]\n"
"\n"
" :source-paths\n"
" [\"src\"]\n"
"\n"
" :builds\n"
" {:app {:target :browser\n"
"        :output-dir \"public/js\"\n"
"        :asset-path \"/js\"\n"
"        :modules {:main {:entries [my.app]}}}}}"
msgstr ""

msgid "The file structure for this example should look like this:"
msgstr "この例のファイル構成は次のようになります。"

msgid ""
".\n"
"├── package.json\n"
"├── shadow-cljs.edn\n"
"└── src\n"
"    └── my\n"
"        └── app.cljs"
msgstr ""

msgid "Source Paths"
msgstr ""

msgid "`:source-paths` configures your JVM classpath. The compiler will use this config to find Clojure(Script) source files (eg. `.cljs`)."
msgstr "`:source-paths` は JVM のクラスパスを設定します。コンパイラはこの設定を使ってClojure(Script)のソースファイル(例: `.cljs` )を見つけます。"

msgid "It is fine to put everything into one source path but you can use multiple if you want to \"group\" source files in certain ways. It is useful if you want to keep your tests separate for example."
msgstr "全てを一つのソースパスに入れるのは良いのですが、ソースファイルを特定の方法で\"グループ\"化したい場合は、複数のソースパスを使うことができます。例えば、テストを別々にしておきたい場合などに便利です。"

msgid "Using multiple source paths"
msgstr "複数のソースパスの使用"

msgid ""
"{:source-paths [\"src/main\" \"src/test\"]\n"
" ...}"
msgstr ""

msgid "File Structure"
msgstr "ファイル構成"

msgid ""
".\n"
"├── package.json\n"
"├── shadow-cljs.edn\n"
"└── src\n"
"    └── main\n"
"        └── my\n"
"            └── app.cljs\n"
"    └── test\n"
"        └── my\n"
"            └── app_test.cljs"
msgstr ""

msgid "It is not recommended to separate source files by extension (eg. `src/clj`, `src/cljs`, `src/cljc`). For some reason this is widely used in CLJS project templates but it just makes things harder to use."
msgstr "ソースファイルを拡張子(例: `src/clj`, `src/cljs`, `src/cljc`)で分けることは推奨されていません。なぜかこれは CLJS プロジェクトのテンプレートで広く使われていますが、使いにくくなるだけです。"

msgid "Dependencies"
msgstr "依存関係"

msgid "Clojure(Script)"
msgstr ""

msgid "Your dependencies are managed via the `:dependencies` key at the root of the `shadow-cljs.edn` config file. They are declared in the same notation that other Clojure tools like `lein` or `boot` use."
msgstr "依存関係は `shadow-cljs.edn` 設定ファイルのルートにある `:dependencies` キーで管理されます。依存関係は `lein` や `boot` のような他の Clojure ツールと同じ記法で宣言されます。"

msgid "Each dependency is written as a vector using `[library-name \"version-string\"]` nested in one outer vector."
msgstr "各依存関係は、外側のベクトルに入れ子にした `[library-name \"version-string\"]` を用いてベクトルとして記述しています。"

msgid "Example :dependencies"
msgstr ":dependencies の例"

msgid ""
"{:source-paths [\"src\"]\n"
" :dependencies [[reagent \"0.9.1\"]]\n"
" :builds ...}"
msgstr ""

msgid "Notice that the source path is *only* specified once in the entire configuration. The system will use namespace dependency graphs to determine what code is needed in the final output of any given build."
msgstr "ソースパスが指定されるのは、設定全体の中で *一度* だけであることに注意してください。システムは名前空間依存性グラフを使用して、任意のビルドの最終出力に必要なコードを決定します。"

msgid "JavaScript"
msgstr ""

msgid "`shadow-cljs` integrates fully with the https://www.npmjs.com/[`npm`] ecosystem to manage JavaScript dependencies."
msgstr "`shadow-cljs` は、https://www.npmjs.com/[`npm`] エコシステムと完全に統合して JavaScript の依存関係を管理します。"

msgid "You can use `npm` or `yarn` to manage your dependencies, please refer to their respective documentation."
msgstr "依存関係の管理には `npm` や `yarn` を使うことができます。"

msgid "npm"
msgstr ""

msgid "https://docs.npmjs.com/"
msgstr ""

msgid "yarn"
msgstr ""

msgid "https://yarnpkg.com/en/docs"
msgstr ""

msgid "Both manage your dependencies via a `package.json` file in your project directory.  Almost every package available via `npm` will explain how to install it. Those instructions now apply to `shadow-cljs` as well."
msgstr "どちらもプロジェクトディレクトリの `package.json` ファイルを使って依存関係を管理します。 ほとんどのパッケージは `npm` で利用できるので、インストール方法を説明してくれます。これらの説明は `shadow-cljs` にも適用されます。"

msgid "Installing a JavaScript package"
msgstr ""

msgid ""
"# npm\n"
"$ npm install the-thing\n"
"\n"
"# yarn\n"
"$ yarn add the-thing"
msgstr ""

msgid "Nothing more is required. Dependencies will be added to the `package.json` file and this will be used to manage them."
msgstr "これ以上は必要ありません。依存関係は `package.json` ファイルに追加され、これが管理に使われます。"

msgid "If you don’t have a `package.json` yet run `npm init` from a command line."
msgstr "まだ `package.json` を持っていない場合は、コマンドラインから `npm init` を実行します。"

msgid "Missing JS Dependency?"
msgstr ""

msgid "You might run into errors related to missing JS dependencies. Most ClojureScript libraries do not yet declare the `npm` packages they use since they still expect to use <<cljsjs, CLJSJS>>. We want to use `npm` directly which means you must manually install the `npm` packages until libraries properly declare the `:npm-deps` themselves."
msgstr "JS の依存関係の欠落に関連したエラーに遭遇するかもしれません。ほとんどの ClojureScript ライブラリはまだ `npm` パッケージを宣言していません。私たちは `npm` を直接使いたいので、ライブラリが `:npm-deps` を適切に宣言するまでは `npm` パッケージを手動でインストールしなければなりません。"

msgid "The required JS dependency \"react\" is not available, it was required by ..."
msgstr "必要なJSの依存関係 \"react\" が利用できません、これは..."

msgid "This means that you should `npm install react`."
msgstr "ということは `npm install react` をするべきだということです。"

msgid "In the case of `react` you probably need these 3 packages: `npm install react react-dom create-react-class`."
msgstr "`react` の場合、次の3つのパッケージが必要になるでしょう。 `npm install react react-dom create-react-class` "

msgid "User Configuration"
msgstr ""

msgid "Most configuration will be done in the projects themselves via `shadow-cljs.edn` but some config may be user-dependent. Tools like https://docs.cider.mx[CIDER] may require the additional `cider-nrepl` dependency which would be useless for a different team member using Cursive when adding that dependency via `shadow-cljs.edn`."
msgstr "ほとんどの設定はプロジェクト自身で `shadow-cljs.edn` を使って行いますが、いくつかの設定はユーザに依存することがあります。 https://docs.cider.mx[CIDER] のようなツールは `shadow-cljs.edn` で依存関係を追加しても Cursive を使っている別のチームメンバーには意味がないので、追加の `cider-nrepl` 依存関係を必要とするかもしれません。"

msgid "A restricted set of config options can be added to `~/.shadow-cljs/config.edn` which will then apply to all projects built on this users machine."
msgstr "制限された設定オプションのセットを `~/.shadow-cljs/config.edn` に追加することができ、このユーザのマシンでビルドされたすべてのプロジェクトに適用されます。"

msgid "Adding dependencies is allowed via the usual `:dependencies` key. Note that dependencies added here will apply to ALL projects. Keep them to a minimum and only put tool related dependencies here. Everything that is relevant to a build should remain in `shadow-cljs.edn` as otherwise things may not compile for other users. These dependencies will automatically be added when using `deps.edn` or `lein` as well."
msgstr "依存関係を追加するには、通常の `:dependencies` キーを使用します。ここで追加された依存関係はすべてのプロジェクトに適用されることに注意してください。依存関係は最小限に抑え、ツール関連の依存関係だけをここに入れてください。ビルドに関連するものはすべて `shadow-cljs.edn` のままにしておくべきです。これらの依存関係は `deps.edn` や `lein` を使うときにも自動的に追加されます。"

msgid "Example ~/.shadow-cljs/config.edn"
msgstr ""

msgid ""
"{:dependencies\n"
" [[cider/cider-nrepl \"0.21.1\"]]}\n"
";; this version may be out of date, check whichever is available"
msgstr ""
"{:dependencies\n"
" [[cider/cider-nrepl \"0.21.1\"]]}\n"
";; このバージョンは古いかもしれません、利用可能なものをチェックしましょう。"

msgid "When using `deps.edn` to resolve dependencies you may sometimes want to activate additional aliases. This can be done via `:deps-aliases`."
msgstr "依存関係を解決するために `deps.edn` を使う場合、追加のエイリアスを有効にしたいことがあるかもしれません。これは `:deps-aliases` で行うことができます。"

msgid ""
";; shadow-cljs.edn in project\n"
"{:deps {:aliases [:cljs]}}\n"
"\n"
";; ~/.shadow-cljs/config.edn\n"
"{:deps-aliases [:cider]}"
msgstr ""

msgid "This will make the `shadow-cljs` command use the `[:cider :cljs]` aliases in projects using `deps.edn`. This might be useful if you have an additional `:cider` alias in your `~/.clojure/deps.edn`."
msgstr "これにより `deps.edn` を使っているプロジェクトで `shadow-cljs` コマンドが `[:cider :cljs]` エイリアスを使うようになります。これは `~/.clojure/deps.edn` に追加の `:cider` エイリアスがある場合に便利です。"

msgid "By default the `shadow-cljs` server-mode will launch an embedded nREPL server which you might not need. You can disable this by setting `:nrepl false` in user config."
msgstr "デフォルトでは `shadow-cljs` サーバモードは必要ないかもしれない組み込みの nREPL サーバを起動します。これを無効にするには、ユーザ設定で `:nrepl false` を設定します。"

msgid "The only other currently accepted value in the user config is the <<open-file-command, :open-file-command>>. No other options are currently have any effect."
msgstr "ユーザー設定で現在認められている他の値は、 <<open-file-command, :open-file-command>> だけです。他のオプションは現在のところ何の影響もありません。"

msgid "Server Options"
msgstr ""

msgid "This section is for other options that configure the `shadow-cljs` server instance. They are optional."
msgstr "このセクションでは `shadow-cljs` サーバインスタンスを設定する他のオプションについて説明します。これらはオプションです。"

msgid "nREPL"
msgstr ""

msgid "The `shadow-cljs` <<server-mode, server>> provides a https://nrepl.org[nREPL] server via TCP. If you look at the startup message you'll see the port of nREPL, and the port will also be stored in `target/shadow-cljs/nrepl.port`:"
msgstr "`shadow-cljs` <<server-mode, server>> は https://nrepl.org[nREPL] サーバを TCP 経由で提供します。起動メッセージを見るとnREPLのポート番号が表示されており、その数値は `target/shadow-cljs/nrepl.port` に格納されています。"

msgid ""
"$ shadow-cljs watch app\n"
"shadow-cljs - HTTP server available at http://localhost:8600\n"
"shadow-cljs - server version: <version> running at http://localhost:9630\n"
"shadow-cljs - nREPL server started on port 64967\n"
"shadow-cljs - watching build :app\n"
"[:app] Configuring build.\n"
"[:app] Compiling ..."
msgstr ""

msgid "You can configure the port and additional middleware with `shadow-cljs.edn`:"
msgstr "ポート番号や追加のミドルウェアは `shadow-cljs.edn` で設定することができます。"

msgid ""
"{...\n"
" :nrepl {:port 9000\n"
"         :middleware []} ; optional list of namespace-qualified symbols\n"
" ...}"
msgstr ""

msgid "The default global config file in `~/.nrepl/nrepl.edn` or the local `.nrepl.edn` will also be loaded on startup and can be used to configure `:middleware`."
msgstr "デフォルトのグローバル設定ファイルは `~/.nrepl/nrepl.edn` またはローカルの `.nrepl.edn` にあり、起動時に読み込まれ `:middleware` を設定するのに使われます。"

msgid "If the popular middleware https://github.com/clojure-emacs/cider-nrepl[cider-nrepl] is found on the classpath (e.g. it's included in `:dependencies`), it will be used automatically. No additional configuration required. This can be disabled by setting `:nrepl {:cider false}`."
msgstr "人気のあるミドルウェア https://github.com/clojure-emacs/cider-nrepl[cider-nrepl] がクラスパス上にあれば(例えば `:dependencies` に含まれているなど)、自動的に使用されます。追加の設定は必要ありません。これは `:nrepl {:cider false}` を設定することで無効にできます。"

msgid "You may configure the namespace you start in when connecting by setting `:init-ns` in the `:nrepl` options. It defaults to `shadow.user`."
msgstr "接続時に開始する名前空間は `:nrepl` オプションで `:init-ns` を設定することで設定できます。デフォルトは `shadow.user` です。"

msgid ""
"{...\n"
" :nrepl {:init-ns my.repl}\n"
" ...}"
msgstr ""

msgid "The nREPL server can be disabled by setting `:nrepl false`."
msgstr "nREPLサーバは `:nrepl false` を設定することで無効にすることができます。"

msgid "nREPL Usage"
msgstr ""

msgid "When connecting to the nREPL server the connection always starts out as a Clojure REPL. Switching to a CLJS REPL works similarly to the <<cljs-repl, non-nREPL version>>. First the `watch` for the given build needs to be started and then we need to select this build to switch the current nREPL session to that build. After selecting the build everything will be eval'd in ClojureScript instead of Clojure."
msgstr "nREPLサーバに接続するとき、接続は常にClojure REPLとして始まります。CLJS REPLへの切り替えは<<cljs-repl, non-nREPL version>>と同様に動作します。まず、与えられたビルドのための `watch` を開始する必要があり、次に、現在のnREPLセッションをそのビルドに切り替えるために、このビルドを選択する必要があります。ビルドを選択した後は、ClojureではなくClojureScriptで全てが評価されます。"

msgid ""
"(shadow/watch :the-build)\n"
"(shadow/repl :the-build)"
msgstr ""

msgid "Use `:cljs/quit` to return to Clojure."
msgstr ""

msgid "Embedded nREPL Server"
msgstr ""

msgid "When you use `shadow-cljs` embedded in other tools that provide their own nREPL server (eg. `lein`) you need to configure the `shadow-cljs` middleware. Otherwise you won't be able to switch between CLJ and CLJS REPLs."
msgstr "独自のnREPLサーバを提供する他のツール(例: `lein`)に埋め込まれた `shadow-cljs` を使う場合 `shadow-cljs` ミドルウェアを設定する必要があります。そうしないと、CLJとCLJSのREPLを切り替えることができません。"

msgid "Example Leiningen <code>project.clj</code>"
msgstr "Example Leiningen `project.clj`"

msgid ""
"(defproject my-amazing-project \"1.0.0\"\n"
"  ...\n"
"  :repl-options\n"
"  {:init-ns shadow.user ;; or any of your choosing\n"
"   :nrepl-middleware\n"
"   [shadow.cljs.devtools.server.nrepl/middleware]}\n"
"  ...)"
msgstr ""

msgid "You still need to start the <<embedded, embedded server>> manually before using the CLJS REPL."
msgstr "CLJS REPLを使用する前に、<<embedded, embedded server>>を手動で起動する必要があります。"

msgid "Socket REPL"
msgstr ""

msgid "A Clojure Socket REPL is started automatically in server-mode and uses a random port by default. Tools can find the port it was started under by checking `.shadow-cljs/socket-repl.port` which will contain the port number."
msgstr "Clojure Socket REPLはサーバモードで自動的に起動され、デフォルトではランダムなポートを使用します。ツールは、ポート番号を含む `.shadow-cljs/socket-repl.port` をチェックすることで、それが起動されたポートを見つけることができます。"

msgid "You can also set a fixed port by via `shadow-cljs.edn`."
msgstr "また `shadow-cljs.edn` を使って固定ポートを設定することもできます。"

msgid ""
"{...\n"
" :socket-repl\n"
" {:port 9000}\n"
" ...}"
msgstr ""

msgid "The Socket REPL can be disabled by setting `:socket-repl false`."
msgstr "ソケットREPLを無効にするには `:socket-repl false` を設定します。"

msgid "SSL"
msgstr ""

msgid "The `shadow-cljs` HTTP servers support SSL. It requires a Java Keystore that provides a matching private key and certificate."
msgstr "`shadow-cljs` HTTPサーバはSSLをサポートしています。一致する秘密鍵と証明書を提供するJavaキーストアが必要です。"

msgid "<code>shadow-cljs.edn</code> with SSL configured"
msgstr "SSL設定をした `shadow-cljs.edn`"

msgid ""
"{...\n"
" :ssl {:keystore \"ssl/keystore.jks\"\n"
"       :password \"shadow-cljs\"}\n"
" ...}"
msgstr ""

msgid "The above are the defaults so if you want to use those it is fine to just set `:ssl {}`."
msgstr "上記はデフォルトなので、これらを使いたい場合は `:ssl {}` を設定するだけで大丈夫です。"

msgid "You can create a Keystore using the java `keytool` command. Creating a trusted self-signed certificate is also possible but somewhat complicated."
msgstr "javaの `keytool` コマンドを使用してキーストアを作成することができます。信頼できる自己署名証明書を作成することも可能ですが、少々複雑です。"

msgid "https://gist.github.com/jchandra74/36d5f8d0e11960dd8f80260801109ab0[OpenSSL] instructions for Linux and Windows (via WSL)"
msgstr "https://gist.github.com/jchandra74/36d5f8d0e11960dd8f80260801109ab0[OpenSSL]のLinuxとWindowsの説明書 (WSL経由)"

msgid "https://certsimple.com/blog/localhost-ssl-fix[macOS] instructions"
msgstr "https://certsimple.com/blog/localhost-ssl-fix[macOS]の説明書"

msgid "The created `Certificates.p12` (macOS) or `localhost.pfx` (Linux, Windows) file can be turned into the required `keystore.jks` via the `keytool` utility."
msgstr "作成した `Certificates.p12` (macOS) または `localhost.pfx` (Linux, Windows) ファイルは `keytool` ユーティリティを使って必要な `keystore.jks` に変換することができます。"

msgid "$ keytool -importkeystore -destkeystore keystore.jks -srcstoretype PKCS12 -srckeystore localhost.pfx"
msgstr ""

msgid "You must generate the Certificate with a SAN (Subject Alternative Name) for \"localhost\" (or whichever host you want to use). SAN is required to get Chrome to trust the Certificate and not show warnings. The password used when exporting must match the password assigned to the Keystore."
msgstr "証明書は、\"localhost\"（または使用したいホスト）のSAN（Subject Alternative Name）で生成する必要があります。SAN は、Chrome が証明書を信頼して警告を表示しないようにするために必要です。エクスポート時に使用するパスワードは、キーストアに割り当てられたパスワードと一致している必要があります。"

msgid "Primary HTTP(S)"
msgstr ""

msgid "The `shadow-cljs` server starts one primary HTTP server. It is used to serve the UI and websockets used for Hot Reload and REPL clients. By default it listens on Port 9630. If that Port is in use it will increment by one and attempt again until an open Port is found."
msgstr "`shadow-cljs` サーバはプライマリ HTTP サーバを一つ起動します。これはホットリロードとREPLクライアントに使われるUIとウェブソケットを提供するために使われます。デフォルトではポート9630を listen します。もしそのポートが使用中であれば、1つずつインクリメントして、開いているポートが見つかるまで再試行します。"

msgid "Startup message indicating the Port used"
msgstr "使用ポートを示す起動メッセージ"

msgid "shadow-cljs - server running at http://0.0.0.0:9630"
msgstr ""

msgid "When `:ssl` is configured the server will be available via `https://` instead."
msgstr "`ssl` が設定されている場合は、代わりに `https://` を用いてサーバを利用できるようになります。"

msgid "The server automatically supports HTTP/2 when using `:ssl`."
msgstr "サーバは `:ssl` を使うと自動的に HTTP/2 をサポートします。"

msgid "If you prefer to set your own port instead you can do this via the `:http` config."
msgstr "代わりに自分のポートを設定したい場合は `:http` 設定で設定することができます。"

msgid "<code>shadow-cljs.edn</code> with <code>:http</code> config"
msgstr "`:http` を設定した `shadow-cljs.edn`"

msgid ""
"{...\n"
" :http {:port 12345\n"
"        :host \"my.machine.local\"}\n"
" ...}"
msgstr ""

msgid "`:ssl` switches the server to server `https://` only. If you want to keep the `http://` version you can configure a separate `:ssl-port` as well."
msgstr "`:ssl` はサーバを `https://` のみに切り替えます。もし `http://` バージョンを維持したい場合は `:ssl-port` を別途設定することもできます。"

msgid ""
"{...\n"
" :http {:port 12345\n"
"        :ssl-port 23456\n"
"        :host \"localhost\"}\n"
" ...}"
msgstr ""

msgid "Development HTTP(S)"
msgstr ""

msgid "`shadow-cljs` can provide additional basic HTTP servers via the `:dev-http` config entry. By default these will serve all static files from the configured paths, and fall back to `index.html` when a resource is not found (this is what you typically want when developing an application which uses browser push state)."
msgstr "`shadow-cljs` は `:dev-http` 設定項目で追加の基本的な HTTP サーバを提供することができます。デフォルトでは、これらは設定されたパスからすべての静的ファイルを提供し、リソースが見つからない場合は `index.html` にフォールバックします (これはブラウザのプッシュ状態を利用するアプリケーションを開発する際に典型的に必要とされるものです)。"

msgid "These servers are started automatically when `shadow-cljs` is running in server mode. They are not specific to any build and can be used to serve files for multiple builds as long as a unique `:output-dir` is used for each."
msgstr "これらのサーバは `shadow-cljs` がサーバモードで動作しているときに自動的に起動します。これらのサーバはどのビルドにも依存せず、それぞれに固有の `:output-dir` が使われている限り、複数のビルドに対応するファイルを提供するために使うことができます。"

msgid "IMPORTANT"
msgstr ""

msgid "These are just generic web servers that server static files. They are not required for any live-reload or REPL logic. Any webserver will do, these are just provided for convenience."
msgstr "これらは静的ファイルを提供する汎用的なウェブサーバです。ライブリロードや REPL ロジックには必要ありません。どのウェブサーバでも可能ですが、これらは利便性のために提供されているだけです。"

msgid "Basic example serving the <code>public</code> directory via <code><a href=\"http://localhost:8000\" class=\"bare\">http://localhost:8000</a></code>"
msgstr "基本的な例として `public` ディレクトリを経由して `http://localhost:8000` を提供する例。"

msgid ""
"{...\n"
" :dev-http {8000 \"public\"}\n"
" :builds {...}}"
msgstr ""

msgid "`:dev-http` expects a map of `port-number` to `config`. The `config` supports several shortcuts for the most common scenarios."
msgstr "`:dev-http` は `port-number` から `config` へのマップを期待しています。 `config` は最も一般的なシナリオのためのいくつかのショートカットをサポートしています。"

msgid "Serve directory from filesystem root"
msgstr ""

msgid ":dev-http {8000 \"public\"}"
msgstr ""

msgid "Serve from classpath root"
msgstr ""

msgid ":dev-http {8000 \"classpath:public\"}"
msgstr ""

msgid "This would attempt to find a request to `/index.html` via `public/index.html` on the classpath. Which may include files in `.jar` files."
msgstr "これはクラスパス上の `public/index.html` を経由して `/index.html` へのリクエストを見つけようとします。これは `.jar` ファイル内のファイルを含むかもしれません。"

msgid "Serve from multiple roots"
msgstr ""

msgid ":dev-http {8000 [\"a\" \"b\" \"classpath:c\"]}"
msgstr ""

msgid "This would first attempt to find `<project-root>/a/index.html` then `<project-root>/b/index.html` then `c/index.html` on the classpath. If nothing is found the default handler will be called."
msgstr "これは、まず `<project-root>/a/index.html`、次に `<project-root>/b/index.html`、次に `c/index.html` をクラスパス上で見つけようとします。何も見つからなければ、デフォルトのハンドラが呼ばれます。"

msgid "The longer config version expects a map and the supported options are:"
msgstr "長い設定バージョンではマップを想定しており、サポートされているオプションは以下の通りです。"

msgid "`:root`"
msgstr ""

msgid "(String) The path from which to serve requests. Paths starting with `classpath:` will serve from the classpath instead of the filesystem. All filesystem paths are relative to the project root."
msgstr "(String) リクエストに応答するパス。 `classpath:` で始まるパスは、ファイルシステムではなくクラスパスから提供します。ファイルシステムのパスはすべてプロジェクトのルートからの相対パスです。"

msgid "`:roots`"
msgstr ""

msgid "(Vector of Strings) If you need multiple root paths, use instead of `:root`."
msgstr "(Vector of Strings) 複数のルートパスが必要な場合は `:roots` を使う。"

msgid "`:ssl-port`"
msgstr ""

msgid "When `:ssl` is configured use this port for ssl connections and server normal HTTP on the regular port. If `:ssl-port` is not set but `:ssl` is configured the default port will only server SSL requests."
msgstr "`ssl` が設定されている場合、このポートを使ってssl接続を行い、通常のポートで通常のHTTPをサーバする。もし `:ssl-port` が設定されておらず `:ssl` が設定されている場合、デフォルトのポートは SSL リクエストのみを提供するようになります。"

msgid "`:host`"
msgstr ""

msgid "Optional. The hostname to listen on. Defaults to localhost."
msgstr "省略可能です。listenするホスト名。デフォルトは localhost です。"

msgid "`:handler`"
msgstr ""

msgid "Optional. A fully qualified symbol. A `(defn handler [req] resp)` that is used if a resource is not found for the given request. Defaults to `shadow.http.push-state/handle`."
msgstr "オプションです。完全修飾シンボル。与えられたリクエストに対してリソースが見つからなかった場合に使われる `(defn handler [req] resp)` です。デフォルトは `shadow.http.push-state/handle` です。"

msgid "The following two options only apply when using the default, built-in handler and typically do not need to be changed:"
msgstr "以下の2つのオプションは、デフォルトのビルトインハンドラを使用している場合にのみ適用され、通常は変更する必要はありません。"

msgid "`:push-state/headers`"
msgstr ""

msgid "(optional) A map of HTTP headers to respond with. Defaults to `text/html` standard headers."
msgstr "(オプション)  HTTP ヘッダのマップを返します。デフォルトは `text/html` 標準ヘッダ。"

msgid "`:push-state/index`"
msgstr ""

msgid "(optional) The file to serve. Defaults to `index.html`."
msgstr "(オプション) ファイルを提供、デフォルトは `index.html`  。"

msgid ""
"{...\n"
" :dev-http\n"
" {8080 {:root \"public\"\n"
"        :handler my.app/handler}}}"
msgstr ""

msgid "Reverse Proxy Support"
msgstr ""

msgid "By default the dev server will attempt to serve requests locally but sometimes you may want to use an external web server to serve requests (eg. API request). This can be configured via `:proxy-url`."
msgstr "デフォルトでは、開発サーバはローカルでリクエストを送ろうとしますが、時には外部のウェブサーバを使ってリクエストを送ろうとすることもあるでしょう (例: APIリクエスト)。これは `:proxy-url` で設定できます。"

msgid ""
"{...\n"
" :dev-http\n"
" {8000\n"
"  {:root \"public\"\n"
"   :proxy-url \"https://some.host\"}}}"
msgstr ""

msgid "A request going to `http://localhost:8000/api/foo` will serve the content returned by `https://some.host/api/foo` instead. All request that do not have a local file will be served by the proxied server."
msgstr "`http://localhost:8000/api/foo` へのリクエストは、代わりに `https://some.host/api/foo` が返すコンテンツを返します。ローカルファイルを持たないリクエストはすべてプロキシされたサーバによって処理されます。"

msgid "Additional optional Options to configure the connection handling are:"
msgstr "接続処理を設定するための追加オプションは次のとおりです。"

msgid "`:proxy-rewrite-host-header`"
msgstr ""

msgid "boolean, defaults to true. Determines whether the original Host header will be used or the one from the `:proxy-url`. `localhost` vs `some.host` using the example above."
msgstr "boolean, デフォルトは true です。オリジナルのHostヘッダを使うか `:proxy-url` のものを使うかを決定します。上の例で `localhost` と `some.host` を比較してみましょう。"

msgid "`:proxy-reuse-x-forwarded`"
msgstr ""

msgid "boolean, defaults to false. Configures if the proxy should add itself to `X-Forwarded-For` list or start a new one."
msgstr "boolean, デフォルトはfalseです。プロキシが `X-Forwarded-For` リストに自分自身を追加するか、新しいプロキシを開始するかを設定します。"

msgid "`:proxy-max-connection-retries`"
msgstr ""

msgid "int, defaults to 1."
msgstr "int, デフォルトは1"

msgid "`:proxy-max-request-time`"
msgstr ""

msgid "ms as int, defaults to 30000. 30sec request timeout."
msgstr "ミリ秒をintで指定します、デフォルトは 30000 です。30秒のリクエストタイムアウト。"

msgid "JVM Configuration"
msgstr ""

msgid "When `shadow-cljs.edn` is used in charge of starting the JVM you can configure additional command line arguments to be passed directly to the JVM. For example you may want to decrease or increase the amount of RAM used by shadow-cljs."
msgstr "`shadow-cljs.edn` がJVMの起動を担当している場合、JVMに直接渡す追加のコマンドライン引数を設定することができます。例えば、shadow-cljsが使用するメモリの量を減らしたり増やしたりすることができます。"

msgid "This is done by configuring `:jvm-opts` at the root of `shadow-cljs.edn` expecting a vector of strings."
msgstr "これは `shadow-cljs.edn` のルートで `:jvm-opts` を設定することで行われます。"

msgid "Example limited RAM use to 1GB"
msgstr "例：メモリ消費を1GBへ設定"

msgid ""
"{:source-paths [...]\n"
" :dependencies [...]\n"
" :jvm-opts [\"-Xmx1G\"]\n"
" :builds ...}"
msgstr ""

msgid "The arguments that can be passed to the JVM vary depending on the version but you can find an example list https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html[here]. Please note that assigning too little or too much RAM can degrade performance. The defaults are usually good enough."
msgstr "JVMに渡すことができる引数はバージョンによって異なりますが、 https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html[こちら] に例示的なリストがあります。RAMの割り当てが少なすぎたり多すぎたりすると、パフォーマンスが低下する可能性があることに注意してください。通常はデフォルトで十分です。"

msgid "When using `deps.edn` or `project.clj` the `:jvm-opts` need to be configured there."
msgstr "`deps.edn` や `project.clj` を使う場合は、それらのファイルで `:jvm-opts` を設定する必要があります。"

msgid "Build Configuration"
msgstr ""

msgid "`shadow-cljs.edn` will also need a `:builds` section. Builds should be a map of builds *keyed* by build ID:"
msgstr "`shadow-cljs.edn` は `:builds` セクションも必要です。ビルドはビルドIDをキーにしたビルドのマップでなければなりません。"

msgid "A configuration file with a build map."
msgstr ""

msgid ""
"{:dependencies [[some-library \"1.2.1\"] ...]\n"
" :source-paths [\"src\"]\n"
" :builds\n"
" {:app   {:target     :browser\n"
"          ... browser-specific options ...}\n"
"  :tests {:target :karma\n"
"          ... karma-specific options ...}}}"
msgstr ""

msgid "Each build describes artifacts that the compiler will build. The build target is an extensible feature of `shadow-cljs`, and the compiler comes with quite a few of them already."
msgstr "各ビルドはコンパイラがビルドする成果物を記述します。ビルドターゲットは `shadow-cljs` の拡張可能な機能であり、コンパイラにはすでにかなりの数のビルドターゲットが用意されています。"

msgid "Build Target"
msgstr ""

msgid "Each build in `shadow-cljs` must define a `:target` which defines where you intend your code to be executed. There are default built-ins for the <<target-browser,browser>> and <<target-node,`node.js`>>. They all share the basic concept of having `:dev` and `:release` modes. `:dev` mode provides all the usual development goodies like fast compilation, live code reloading and a REPL. `:release` mode will produce optimized output intended for production."
msgstr "`shadow-cljs` の各ビルドは `:target` を定義しなければなりません。デフォルトのビルドインは <<target-browser,browser>> と <<target-node, `node.js`>> です。これらはすべて `:dev` モードと `:release` モードを持つという基本的なコンセプトを共有しています。 `:dev` モードは、高速なコンパイル、ライブコードのリロード、REPLのような通常の開発上の利点をすべて提供します。リリースモードでは、プロダクション向けに最適化された出力を生成します。"

msgid "Targets are covered in separate chapters."
msgstr "ターゲットは別の章でカバーされています。"

msgid "Here are some of them:"
msgstr "その一部をご紹介します。"

msgid "<<target-browser, `:browser`>>"
msgstr ""

msgid "Output code suitable for running in a web browser."
msgstr "Webブラウザでの実行に適した出力コード。"

msgid "<<target-bootstrap, `:bootstrap`>>"
msgstr ""

msgid "Output code suitable for running in bootstrapped cljs environment."
msgstr "bootstrap cljs環境に適した出力コード。"

msgid "<<target-browser-test, `:browser-test`>>"
msgstr ""

msgid "Scan for tests to determine required files, and output tests suitable for running in the browser."
msgstr "必要なファイルを決定するためのテストをスキャンし、ブラウザでの実行に適したテストを出力します。"

msgid "<<target-karma, `:karma`>>"
msgstr ""

msgid "Scan for tests to determine required files, and output karma-runner compatible tests. See http://karma-runner.github.io/2.0/index.html[Karma]."
msgstr "テストをスキャンして必要なファイルを判断し、カルマランナーに対応したテストを出力します。 http://karma-runner.github.io/2.0/index.html[Karma]を参照。"

msgid "<<target-node-library, `:node-library`>>"
msgstr ""

msgid "Output code suitable for use as a node library."
msgstr "nodeライブラリとして使用するのに適した出力コード。"

msgid "<<target-node-script, `:node-script`>>"
msgstr ""

msgid "Output code suitable for use as a node script."
msgstr "nodeスクリプトとして使用するのに適した出力コード。"

msgid "<<target-npm-module, `:npm-module`>>"
msgstr ""

msgid "Output code suitable for use as an NPM module."
msgstr "NPM モジュールとして使用するのに適した出力コード。"

msgid "Each target is covered in more detail in its own chapter since the remaining build options vary on the target you select."
msgstr "各ターゲットは、選択したターゲットによって残りのビルドオプションが異なるため、それぞれの章で詳しく説明します。"

msgid "Development Options"
msgstr ""

msgid "Each build `:target` typically provides some development support. They are grouped under the `:devtools` key for each `:build`."
msgstr "各ビルド `:target` は通常、何らかの開発サポートを提供します。これらは各 `:build` の `:devtools` キーの下にグループ化されています。"

msgid "When running `watch` code for the REPL is injected automatically and usually does not require additional configuration. Additional options are available to control REPL behavior:"
msgstr "REPL のための `watch` コードは自動的に注入され、通常は追加の設定を必要としません。REPLの動作を制御するための追加オプションがあります:"

msgid "`:repl-init-ns` allows configuring which namespace the REPL will start in. It defaults to `cljs.user`."
msgstr "`:repl-init-ns` は REPL をどの名前空間で開始するかを設定することができます。デフォルトは `cljs.user` です。"

msgid "`:repl-pprint` makes the REPL use `cljs.pprint` instead of the regular `pr-str` when printing eval results. Defaults to false."
msgstr "`:repl-pprint` は、evalの結果を印刷する際に通常の `pr-str` の代わりに `cljs.pprint` を使用するようにします。デフォルトはfalseです。"

msgid ""
"{...\n"
" :builds\n"
" {:app {...\n"
"        :devtools {:repl-init-ns my.app\n"
"                   :repl-pprint true\n"
"                   ...}}}}"
msgstr ""

msgid "Preloads"
msgstr ""

msgid "As a developer most of your time is spent in development mode. You're probably familiar with tools like `figwheel`, `boot-reload`, and `devtools`. It's almost certain that you want one or more of these in your builds."
msgstr "開発者として、あなたの時間のほとんどは開発モードに費やされています。おそらく `figwheel`, `boot-reload`, `devtools` などのツールをよく知っているでしょう。これらのうちの 1 つ以上がビルドに必要であることはほぼ間違いありません。"

msgid "Preloads are used to force certain namespaces into the front of your generated Javascript. This is generally used to inject tools and instrumentation before the application actually loads and runs. The preloads option is simply a list of namespaces in the `:devtools`/`:preloads` section of `shadow-cljs-edn`:"
msgstr "プリロードは、生成された Javascript の前に特定の名前空間を強制的に挿入するために使用されます。これは一般的に、アプリケーションが実際にロードされて実行される前にツールやインストルメンテーションを注入するために使用されます。preloads オプションは `shadow-cljs-edn` の `:devtools`/`:preloads` セクションにある名前空間のリストです。"

msgid ""
"{...\n"
" :builds\n"
" {:app {...\n"
"        :devtools {:preloads [fulcro.inspect.preload]\n"
"                   ...}}}}"
msgstr ""

msgid "Since version 2.0.130 shadow-cljs automatically adds `cljs-devtools` to the preloads in `watch` and `compile` if they are on the classpath. All you need to do is make sure `binaryage/devtools` is in your `dependencies` list. (Note, *not* binaryage/**cljs-**devtools.) If you don't want to have `cljs-devtools` in specific targets, you can suppress this by adding `:console-support false` to the `:devtools` section of those targets."
msgstr "バージョン 2.0.130 以降、shadow-cljs は `watch` と `compile` のプリロードに `cljs-devtools` を自動的に追加します。必要なのは `binaryage/devtools` が `dependencies` リストにあることを確認するだけです。(注意: binaryage/**cljs-**devtools  *ではありません。*) 特定のターゲットに `cljs-devtools` を入れたくない場合は `:devtools` セクションに `:console-support false` を追加することで、これを抑制することができます。"

msgid "Hot Code Reload"
msgstr ""

msgid "The React and ClojureScript ecosystems combine to make this kind of thing super useful. The `shadow-cljs` system includes everything you need to do your hot code reload, without needing to resort to external tools."
msgstr "React と ClojureScript のエコシステムは、この種のことを非常に便利にしてくれます。 `shadow-cljs` システムには、外部ツールに頼らずにホットコードのリロードを行うために必要なものがすべて含まれています。"

msgid "In order to use it you simply run:"
msgstr "使用するには、単に実行するだけです。"

msgid "shadow-cljs watch build-id"
msgstr ""

msgid "Lifecycle Hooks"
msgstr ""

msgid "You can configure the compiler to run functions just before hot code reload brings in updated code, and just after. These are useful for stopping/starting things that would otherwise close over old code."
msgstr "ホットコードのリロードが更新されたコードを取り込む直前と直後に関数を実行するようにコンパイラを設定することができます。これらは、古いコードの上で閉じてしまうようなものを止めたり起動したりするのに便利です。"

msgid "These can be configured via the `:devtools` section in your build config or directly in your code via metadata tags."
msgstr "これらは、ビルド設定の `:devtools` セクションで設定することができますし、コードの中で直接メタデータタグを使って設定することもできます。"

msgid "Metadata"
msgstr ""

msgid "You can set certain metadata on normal CLJS `defn` vars to inform the compiler that these functions should be called at a certain time when live reloading."
msgstr "通常のCLJSの `defn` varsに特定のメタデータを設定することで、ライブリロード時にこれらの関数が特定のタイミングで呼び出されるようにコンパイラに通知することができます。"

msgid "hook config via metadata"
msgstr ""

msgid ""
"(ns my.app)\n"
"\n"
"(defn ^:dev/before-load stop []\n"
"  (js/console.log \"stop\"))\n"
"\n"
"(defn ^:dev/after-load start []\n"
"  (js/console.log \"start\"))"
msgstr ""

msgid "This would call `my.app/stop` before loading any new code and `my.app/start` when all new code was loaded. You can tag multiple functions like this and they will be called in dependency order of their namespaces."
msgstr "これは新しいコードを読み込む前に `my.app/stop` を呼び出し、すべての新しいコードが読み込まれたときに `my.app/start` を呼び出すことになります。このように複数の関数にタグを付けることができ、それらの関数は名前空間の依存関係の順に呼び出されます。"

msgid "There are also async variants of these in case you need to do some async work that should complete before proceeding with the reload process."
msgstr "リロード処理を進める前に完了すべきいくつかの非同期作業を行う必要がある場合に備えて、これらの非同期バリアントもあります。"

msgid "async hooks example"
msgstr ""

msgid ""
"(ns my.app)\n"
"\n"
"(defn ^:dev/before-load-async stop [done]\n"
"  (js/console.log \"stop\")\n"
"  (js/setTimeout\n"
"    (fn []\n"
"      (js/console.log \"stop complete\")\n"
"      (done)))\n"
"\n"
"(defn ^:dev/after-load-async start [done]\n"
"  (js/console.log \"start\")\n"
"  (js/setTimeout\n"
"    (fn []\n"
"      (js/console.log \"start complete\")\n"
"      (done)))"
msgstr ""

msgid "The functions will receive one callback function that must be called when their work is completed. If the callback function is not called the reload process will not proceed."
msgstr "関数は、その作業が完了したときに呼び出されなければならないコールバック関数を1つ受け取ります。コールバック関数が呼び出されなかった場合、リロード処理は進みません。"

msgid "It is possible to tag namespaces with metadata so they will never be reloaded even if they are recompiled."
msgstr "名前空間にメタデータでタグを付けることができるので、再コンパイルしてもリロードされることはありません。"

msgid "A non-reloadable ns"
msgstr ""

msgid ""
"(ns ^:dev/once my.thing)\n"
"\n"
"(js/console.warn \"will only execute once\")"
msgstr ""

msgid "Namespaces can also be tagged to always reload."
msgstr "名前空間は常にリロードするようにタグ付けすることもできます。"

msgid "An always-reloadable ns"
msgstr ""

msgid ""
"(ns ^:dev/always my.thing)\n"
"\n"
"(js/console.warn \"will execute on every code change\")"
msgstr ""

msgid "Config"
msgstr ""

msgid "In addition to the metadata you can configure the lifecycle hooks via `shadow-cljs.edn`."
msgstr "メタデータに加えて `shadow-cljs.edn` でライフサイクルフックを設定することができます。"

msgid "`:before-load`"
msgstr ""

msgid "A symbol (with namespace) of a function to run just before refreshing files that have been recompiled.  This function *must* by synchronous in nature."
msgstr "再コンパイルされたファイルをリフレッシュする直前に実行する関数のシンボル(名前空間付き)。 この関数は本質的に同期的でなければなりません。"

msgid "`:before-load-async`"
msgstr ""

msgid "A symbol (with namespace) of a function `(fn [done])` to run just before refreshing. This function can do async processing, but *must* call `(done)` to indicate it is complete."
msgstr "リフレッシュの直前に実行する関数 `(fn [done])` のシンボル (名前空間付き)。この関数は非同期処理を行うことができますが、完了したことを示すために `(done)` を呼び出す必要があります。"

msgid "`:after-load`"
msgstr ""

msgid "A symbol (with namespace) of a function to run after hot code reload is complete."
msgstr "ホットコードのリロードが完了した後に実行される関数のシンボル（名前空間付き）。"

msgid "`:after-load-async`"
msgstr ""

msgid "A symbol (with namespace) of a function `(fn [done])` to run after hot code reload is complete. This function can do async processing, but *must* call `(done)` to indicate it is complete."
msgstr "ホットコードのリロードが完了した後に実行される関数 `(fn [done])` のシンボル (名前空間付き)。この関数は非同期処理を行うことができますが、完了したことを示すために `(done)` を呼び出す必要があります。"

msgid "`:autoload`"
msgstr ""

msgid "A boolean controlling whether code should be hot loaded. Implicitly set to `true` if either of the callbacks is set. Always enabled for the `:browser` target by default, set to `false` to disable."
msgstr "コードをホットロードするかどうかを制御するブール値。コールバックのいずれかが設定されている場合、暗黙的に `true` に設定されます。デフォルトでは `:browser` ターゲットに対して常に有効で、無効にするには `false` をセットします。"

msgid "`:ignore-warnings`"
msgstr ""

msgid "A boolean controlling whether code with warnings should be reloaded. Defaults to `false`."
msgstr "警告を含むコードをリロードするかどうかを制御するブール値。デフォルトは `false` です。"

msgid "A sample of lifecycle hooks."
msgstr ""

msgid ""
"{...\n"
" :builds\n"
" {:app {...\n"
"        :devtools {:before-load  my.app/stop\n"
"                   :after-load   my.app/start\n"
"                   ...}}}}"
msgstr ""

msgid "Hooks cannot be declared in the `cljs.user` namespace. Hooks are only used if the namespace containing them is actually included in the build. If you use an extra namespace make sure to include it via `:preloads`."
msgstr "フックは `cljs.user` 名前空間では宣言できません。フックは、フックを含む名前空間が実際にビルドに含まれている場合にのみ使用されます。追加の名前空間を使う場合は、必ず `:preloads` でインクルードしてください。"

msgid "If neither `:after-load` nor `:before-load` are set the compiler will only attempt to hot reload the code in the `:browser` target. If you still want hot reloading but don't need any of the callbacks you can set `:autoload true` instead."
msgstr "`:after-load` や `:before-load` が設定されていない場合、コンパイラは `:browser` ターゲットのコードのみをホットリロードします。それでもホットリロードしたいがコールバックが必要ない場合は、代わりに `:autoload true` を設定することができます。"

msgid "Build Hooks"
msgstr ""

msgid "It is sometimes desirable to execute some custom code at a specific stage in the compilation pipeline. `:build-hooks` let you declare which functions should be called and they have full access to the build state at that time. This is quite powerful and opens up many possible tool options."
msgstr "コンパイルパイプラインの特定の段階でカスタムコードを実行することが望ましい場合があります。`:build-hooks` は、どの関数を呼び出すかを宣言し、その時点でのビルド状態に完全にアクセスできるようにします。これは非常に強力であり、多くの可能なツールオプションを開くことができます。"

msgid "They are configured per build under the `:build-hooks` key"
msgstr "これらはビルドごとに `:build-hooks` キーの下で設定されます。"

msgid "Exampe :build-hooks"
msgstr ""

msgid ""
"{...\n"
" :builds\n"
" {:app {:target ...\n"
"        :build-hooks\n"
"        [(my.util/hook 1 2 3)]\n"
"        ...}}}}"
msgstr ""

msgid "Example hook code"
msgstr ""

msgid ""
"(ns my.util)\n"
"\n"
"(defn hook\n"
"  {:shadow.build/stage :flush}\n"
"  [build-state & args]\n"
"  (prn [:hello-world args])\n"
"  build-state)"
msgstr ""

msgid "This example would call `(my.util/hook build-state 1 2 3)` after the build completed the `:flush` <<compilation-stages, stage>> (ie. written to disk). The example would print `[:hello-world (1 2 3)]` but please do something more useful in actual hooks."
msgstr "この例では、ビルドが完了した後に `:flush` <<compile-stages, stage>> (すなわち、ディスクに書き込まれる) を呼び出します。この例では `[:hello-world (1 2 3)]` と表示されますが、実際のフックではもっと便利なものをお願いします。"

msgid "The hook is a just a normal *Clojure* function with some additional metadata. The `{:shadow.build/stage :flush}` metadata informs the compiler to call this hook for `:flush` only. You may instead configure `{:shadow.build/stages #{:configure :flush}}` if the hook should be called after multiple stages. At least one configured stage is required since the hook otherwise would never do anything."
msgstr "フックは通常の *Clojure* 関数にメタデータを追加したものです。メタデータ `{:shadow.build/stage :flush}` は、このフックを `:flush` のためだけに呼び出すようにコンパイラに指示します。複数のステージの後にフックを呼び出す場合は、代わりに `{:shadow.build/stage #{:configure :flush}}` を設定することができます。そうしないとフックは何もしないので、少なくとも一つのステージを設定する必要があります。"

msgid "All build hooks will be called after the `:target` work is done. They will receive the `build-state` (a clojure map with all the current build data) as their first argument and *must* return this `build-state` modified or unmodified. When using multiple stages you can add additional data to the `build-state` that later stages can see. It is strongly advised to use namespaced keys only to ensure not accidentally breaking the entire build."
msgstr "すべてのビルドフックは `:target` の作業が完了した後に呼び出されます。これらのフックは `build-state` (現在のすべてのビルドデータを含む clojure マップ) を第一引数として受け取り、この `build-state` を変更したかどうかに関わらず返さなければ *なりません。* 複数のステージを使用する場合、後のステージが参照できるように `build-state` に追加のデータを追加することができます。誤ってビルド全体を壊してしまわないように、名前空間キーのみを使用することを強くお勧めします。"

msgid "The `build-state` has some important entries which might be useful for your hooks:"
msgstr "`build-state` には、フックに役立つかもしれない重要なエントリがいくつかあります。"

msgid "`:shadow.build/build-id` - the id of the current build (eg. `:app`)"
msgstr "`:shadow.build/build-id` - 現在のビルドのID (例えば `:app`)"

msgid "`:shadow.build/mode` - `:dev` or `:release`"
msgstr ""

msgid "`:shadow.build/stage` - the current stage"
msgstr ""

msgid "`:shadow.build/config` - the build config. You can either store config data for the hook in the build config directly or pass it as arguments in the hook itself"
msgstr "`:shadow.build/config` - ビルドコンフィグ。フックの設定データを直接ビルドコンフィグに保存するか、フック自体の引数として渡すことができます。"

msgid "With a running `watch` all hooks will be called repeatedly for each build. Avoid doing too much work as they can considerably impact your build performance."
msgstr "`watch` を実行していると、すべてのフックはビルドごとに繰り返し呼び出されます。ビルドのパフォーマンスにかなりの影響を与えるので、あまり多くの作業をしないようにしてください。"

msgid "Compilation Stages"
msgstr ""

msgid "The possible stages the `:build-hooks` can use are:"
msgstr "`:build-hooks` が使用できるステージは下記の通りです。"

msgid "`:configure` - initial `:target` specific configuration"
msgstr "`:configure` - 初期の `:target` 固有の設定"

msgid "`:compile-prepare` - called before any compilation is done"
msgstr "`:compile-prepare` - コンパイル開始前に呼び出されます。"

msgid "`:compile-finish` - called after all compilation finishes"
msgstr "`:compile-finish` - すべてのコンパイルが終了した後に呼び出されます。"

msgid "`:optimize-prepare` - called before running the Closure Compiler optimization phase (`:release` only)"
msgstr "`:optimize-prepare` - Closure Compilerの最適化フェーズを実行する前に呼び出されます (`:release` のみ)"

msgid "`:optimize-finish` - called after Closure is done (`:release` only)"
msgstr "`:optimize-finish` - Closureコンパイルの終了時に呼び出されます。 (`:release` のみ)"

msgid "`:flush` - called after everything was flushed to disk"
msgstr "`:flush` - ディスクにすべてを書き込んだ後に呼び出されます"

msgid "With a running `watch` the `:configure` is only called once. Any of the others may be called again (in order) for each re-compile. The `build-state` will be re-used until the build config changes at which point it will be thrown away and a fresh one will be created."
msgstr "実行中の `watch` では `:configure` が呼ばれるのは一度だけです。他のどれかは再コンパイルのたびに (順番に) 再度呼ばれるかもしれません。ビルド状態 `build-state` は、ビルド設定が変更されるまで再利用され、その時点で破棄されて新しいものが作成されます。"

msgid "Compiler Cache"
msgstr ""

msgid "`shadow-cljs` will cache all compilation results by default. The cache is invalidated whenever anything relevant to the individual source files changes (eg. changed compiler setting, changed dependencies, etc.). This greatly improves the developer experience since incremental compilation will be **much** faster than starting from scratch."
msgstr "`shadow-cljs` はデフォルトですべてのコンパイル結果をキャッシュします。個々のソースファイルに関連する何かが変更されると、キャッシュは無効になります (例: コンパイラの設定の変更、依存関係の変更など)。これは開発者の体験を *大幅* に向上させます。"

msgid "Invalidating the cache however can not always be done reliably if you are using a lot of macros with side-effects (reading files, storing things outside the compiler state, etc.). In those cases you might need to disable caching entirely."
msgstr "しかし、副作用のあるマクロを多く使用している場合 (ファイルを読んだり、コンパイラの状態の外に保存したり)、キャッシュを無効にすることは必ずしも確実にできるわけではありません。そのような場合は、キャッシュを完全に無効にする必要があるかもしれません。"

msgid "Namespaces that are known to include side-effecting macros can be blocked from caching. They won't be cached themselves and namespaces requiring them will not be cached as well. The https://github.com/cerner/clara-rules[clara-rules] library has side-effecting macros and is blocked by default. You can specify which namespaces to block globally via the `:cache-blockers` configuration. It expects a set of namespace symbols."
msgstr "副作用のあるマクロを含むことが知られている名前空間は、キャッシュをブロックすることができます。これらはそれ自体はキャッシュされず、それらを必要とする名前空間もキャッシュされません。 https://github.com/cerner/clara-rules[clara-rules] ライブラリには副作用のあるマクロがあり、デフォルトでブロックされています。どの名前空間をグローバルにブロックするかは `:cache-blockers` 設定で指定できます。これは名前空間シンボルのセットを期待しています。"

msgid "clara.rules cache blocking example (this is done by default)"
msgstr "clara.rules キャッシュブロックの例 (デフォルトで行われています)"

msgid ""
"{...\n"
" :cache-blockers #{clara.rules}\n"
" :builds {...}}"
msgstr ""

msgid "In addition you can control how much caching is done more broadly via the `:build-options` `:cache-level` entry. The supported options are:"
msgstr "さらに `:build-options` `:cache-level` エントリを使用することで、キャッシュの量をより広範囲に制御することができます。サポートされているオプションは以下の通りです:"

msgid "`:all`"
msgstr ""

msgid "The default, all CLJS files are cached"
msgstr "デフォルトでは、すべての CLJS ファイルがキャッシュされます。"

msgid "`:jars`"
msgstr ""

msgid "Only caches files from libraries, ie. source files in `.jar` files"
msgstr "ライブラリからのファイルのみをキャッシュします。 つまり `.jar` ファイル内のソースファイル。"

msgid "`:off`"
msgstr ""

msgid "Does not cache any CLJS compilation results (by far the slowest option)"
msgstr "CLJSのコンパイル結果をキャッシュしない(最も遅いオプション)"

msgid "Compiling without Cache"
msgstr ""

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {:target :browser\n"
"   ...\n"
"   :build-options\n"
"   {:cache-level :off}}}}"
msgstr ""

msgid "The cache files are stored in a dedicated directory for each build so the cache is never shared between builds. A build with the id `:app` will have the `:dev` cache in the directory:"
msgstr "キャッシュファイルはビルドごとに専用のディレクトリに保存されるので、ビルド間でキャッシュが共有されることはありません。id が `:app` のビルドは `:dev` キャッシュをディレクトリに格納します。"

msgid "Cache location for <code>cljs/core.cljs</code>"
msgstr "`cljs/core.cljs` のキャッシュ場所"

msgid "target/shadow-cljs/builds/app/dev/ana/cljs/core.cljs.cache.transit.json"
msgstr ""

msgid "The `:cache-root` setting defaults to `target/shadow-cljs` and controls where ALL cache files will be written. It can only be configured globally, not per build."
msgstr "デフォルトの `:cache-root` 設定は `target/shadow-cljs` で、すべてのキャッシュファイルをどこに書き込むかを制御します。これは全体に設定され、ビルドごとに設定できるわけではありません。"

msgid ""
"{:source-paths [...]\n"
" :dependencies [...]\n"
" :cache-root \".shadow-cljs\"\n"
" :builds ...}\n"
"\n"
";; cache then goes to\n"
";; .shadow-cljs/builds/app/dev/ana/cljs/core.cljs.cache.transit.json"
msgstr ""

msgid "The `:cache-root` is always resolved relative to the project directory. You can also specify absolute paths (eg. `/tmp/shadow-cljs`)."
msgstr "キャッシュルート `:cache-root` は常にプロジェクトディレクトリからの相対パスですが、絶対パスを指定することもできます (例: `/tmp/shadow-cljs`)。"

msgid "Closure Defines"
msgstr ""

msgid "The Closure Library & Compiler allow you to define variables that are essentially compile time constants. You can use these to configure certain features of your build. Since the Closure compiler treats these as constants when running `:advanced` optimizations they are fully supported in the Dead-Code-Elimination passes and can be used to remove certain parts of the code that should not be included in `release` builds."
msgstr "Closure ライブラリとコンパイラでは、基本的にコンパイル時の定数である変数を定義することができます。これらを使用してビルドの特定の機能を設定することができます。Closureコンパイラは `:advanced` 最適化を実行する際に定数として扱いますので、デッドコード除去パスでは完全にサポートされています。"

msgid "You can define them in your code"
msgstr "コード内で定義することができます。"

msgid ""
"(ns your.app)\n"
"\n"
"(goog-define VERBOSE false)\n"
"\n"
"(when VERBOSE\n"
"  (println \"Hello World\"))"
msgstr ""

msgid "This defines the `your.app/VERBOSE` variable as `false` by default. This will cause the `println` to be removed in `:advanced` compilation. You can toggle this to `true` via the `:closure-defines` options which will enable the `println`. This can either be done for development only or always."
msgstr "これはデフォルトで `your.app/VERBOSE` 変数を `false` に定義します。これにより `:advanced` のコンパイル時に `println` が削除されます。これを `:closure-defines` オプションで `true` に切り替えると `println` が有効になります。これは開発用にのみ行うことも、常に行うこともできます。"

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {:target :browser\n"
"   ...\n"
"   :modules {:app {:entries [your.app]}}\n"
"   ;; to enable in development only\n"
"   :dev {:closure-defines {your.app/VERBOSE true}}\n"
"   ;; to enable always\n"
"   :closure-defines {your.app/VERBOSE true}\n"
"   ;; you may also enable it for release as well\n"
"   :release {:closure-defines {your.app/VERBOSE true}}\n"
"   }}"
msgstr ""

msgid "It is generally safer to use the \"disabled\" variant as the default since it makes things less likely to be included in a `release` build when they shouldn't be. Forgetting to set a `:closure-defines` variable should almost always result in less code being used not more."
msgstr "\"disabled\" バリアントをデフォルトとして使用する方が一般的に安全です。変数 `:closure-defines` を設定するのを忘れた場合、ほとんどの場合、使用されるコードは少なくなりますが、多くはなりません。"

msgid "*Closure Defines from the Closure Library*"
msgstr ""

msgid "`goog.DEBUG`: The Closure Library uses this for many development features. `shadow-cljs` automatically sets this to `false` for `release` builds."
msgstr "`goog.DEBUG`: クロージャーライブラリはこれを多くの開発機能に利用します。 `shadow-cljs` は `release` ビルドでは自動的に `false` に設定します。"

msgid "`goog.LOCALE` can be used to configure certain localization features like `goog.i18n.DateTimeFormat`. It accepts a standard locale string and defaults to `en`. Pretty much all locales are supported, see https://github.com/google/closure-library/blob/master/closure/goog/i18n/datetimesymbols.js[here] and https://github.com/google/closure-library/blob/master/closure/goog/i18n/datetimesymbolsext.js[here]."
msgstr "`goog.LOCALE` は `goog.i18n.DateTimeFormat` のような特定のローカライゼーション機能を設定するために使用します。標準のロケール文字列を受け付け、デフォルトは `en` です。ほとんどすべてのロケールに対応しています。 https://github.com/google/closure-library/blob/master/closure/goog/i18n/datetimesymbols.js[こちら] および https://github.com/google/closure-library/blob/master/closure/goog/i18n/datetimesymbolsext.js[こちら] を参照ください。"

msgid "Compiler Options"
msgstr ""

msgid "The CLJS compiler supports several options to influence how some code is generated. For the most part `shadow-cljs` will pick some good defaults for each `:target` but you might occasionally want to change some of them."
msgstr "CLJSコンパイラはコードの生成方法に影響を与えるいくつかのオプションをサポートしています。ほとんどの場合 `shadow-cljs` は `:target` ごとにいくつかの良いデフォルト値を選択しますが、時々それらのいくつかを変更したくなるかもしれません。"

msgid "These are all grouped under the `:compiler-options` key in your build config."
msgstr "これらはすべてビルド設定の `:compiler-options` キーの下にグループ化されています。"

msgid ""
"{:dependencies [...]\n"
" :builds\n"
" {:app\n"
"  {:target :browser\n"
"   ...\n"
"   :compiler-options {:fn-invoke-direct true}}}}"
msgstr ""

msgid "Most of the standard ClojureScript https://clojurescript.org/reference/compiler-options[Compiler Options] are either enabled by default or do not apply. So very few of them actually have an effect. A lot of them are also specific to certain `:target` types and do not apply universally (e.g. `:compiler-options {:output-wrapper true}` is only relevant for `:target :browser`)."
msgstr "標準のClojureScript https://clojurescript.org/reference/compiler-options[コンパイラオプション] のほとんどは、デフォルトで有効になっているか、適用されていません。そのため、実際に効果があるものはほとんどありません。それらの多くは特定の `:target` タイプに固有のものであり、普遍的には適用されません (例えば `:compiler-options {:output-wrapper true}` は `:target :browser` にのみ関連しています)。"

msgid "Currently supported options include"
msgstr "現在サポートされているオプションには以下のものがあります。"

msgid "`:optimizations` supports `:advanced`, `:simple` or `:whitespace`, defaults to `:advanced`. `:none` is the default for development and cannot be set manually. `release` with `:none` won't work."
msgstr "`:optimizations` は `:advanced`, `:simple`, `:whitespace` をサポートしており、デフォルトは `:advanced` です。 `:none` は開発時のデフォルトであり、手動で設定することはできません。 `release` に `:none` を指定しても動作しません。"

msgid "`:infer-externs` `:all`, `:auto`, `true` or `false`, defaults to `true`"
msgstr "`:infer-externs` `:all`, `:auto`, `true` または `false`, デフォルトは `true` です。"

msgid "`:static-fns` (Boolean) defaults to `true`"
msgstr "`:static-fns` (ブール値) デフォルトは `true` です。"

msgid "`:fn-invoke-direct` (Boolean) defaults to `false`"
msgstr "`:fn-invoke-direct` (ブール値) デフォルトは `false` です。"

msgid "`:elide-asserts` (Boolean) default to `false` in development and `true` in `release` builds"
msgstr "`:elide-asserts` (ブール値) デフォルトは開発版では `false`, `release` ビルド版では `true` です。"

msgid "`:pretty-print` and `:pseudo-names` default to `false`. You can use `shadow-cljs release app --debug` to enable both temporarily without touching your config. This is very useful when running into problem with `release` builds"
msgstr "`:pretty-print` と `:pseudo-name` のデフォルトは `false` です。 `shadow-cljs release app --debug` を使うと、設定に触れずに一時的に両方を有効にすることができます。これは `release` ビルドで問題が発生したときに非常に便利です。"

msgid "`:source-map` (Boolean) defaults to `true` during development, `false` for `release`."
msgstr "`:source-map` (ブール値) デフォルトは開発中は `true` で `release` では `false` です。"

msgid "`:source-map-include-sources-content` (Boolean) defaults to `true` and decides whether source maps should contains their sources in the `.map` files directly."
msgstr "`:source-map-includes-sources-content` (ブール値) デフォルトは `true` で、ソースマップが `.map` ファイルに直接ソースを含めるかどうかを決定します。"

msgid "`:source-map-detail-level` `:all` or `:symbols` (`:symbols` reduces overall size a bit but also a bit less accurate)"
msgstr "`:source-map-detail-level` `:all` または `:synmbols` (`:synmbols` は全体のサイズを少し小さくしますが、精度は少し落ちます)"

msgid "`:externs` vector of paths, defaults to `[]`"
msgstr "`:externs` pathのベクタです、デフォルトは `[]`"

msgid "`:checked-arrays` (Boolean), defaults to `false`"
msgstr "`:checked-arrays` (ブール値), デフォルトは `false`"

msgid "`:anon-fn-naming-policy`"
msgstr ""

msgid "`:rename-prefix` and `:rename-prefix-namespace`"
msgstr ""

msgid "`:warnings` as a map of `{warning-type true|false}`, eg. `:warnings {:undeclared-var false}` to turn off specific warnings."
msgstr "`:warnings` は `{warning-type true|false}` のマップとして使用します。 例えば 特定の警告をオフにするには `:warnings {:undeclared-var false}` とします。"

msgid "*Unsupported or non-applicable Options*"
msgstr "*サポートされていない、または適用されないオプション*"

msgid "Options that don't have any effect at all include"
msgstr "全く効果がないオプションには以下のようなものがあります。"

msgid "`:verbose` is controlled by running `shadow-cljs compile app --verbose` not in the build config."
msgstr "`:verbose` はビルド設定ではなく `shadow-cljs compile app --verbose` を実行することで制御されます。"

msgid "`:foreign-libs` and `:libs`"
msgstr ""

msgid "`:stable-names` always enabled, cannot be disabled"
msgstr "`:stable-names` は常に有効で、無効にすることはできません。"

msgid "`:install-deps`"
msgstr ""

msgid "`:source-map-path`, `:source-asset-path` and `:source-map-timestamp`"
msgstr ""

msgid "`:cache-analysis` always enabled, cannot be disabled."
msgstr "`:cache-analysis` は常に有効で、無効にすることはできません。"

msgid "`:recompile-dependents`"
msgstr ""

msgid "`:preamble`"
msgstr ""

msgid "`:hashbang` (the `:node-script` target supports this, others don't)"
msgstr "`:hashbang` (`:node-script` ターゲットはこれをサポートしていますが、他のターゲットはこれをサポートしていません)"

msgid "`:compiler-stats` use `--verbose` to get detailed information instead"
msgstr "`:compiler-stats` は詳細な情報を得るために `--verbose` を使用します。"

msgid "`:optimize-constants` always done for `release` builds, cannot be disabled"
msgstr "`:optimize-constants` は `release` ビルドに対して常に行われ、無効にすることはできません。"

msgid "`:parallel-build` always enabled"
msgstr "`:parallel-build` は常に有効です"

msgid "`:aot-cache`"
msgstr ""

msgid "`:package-json-resolution` see <<js-resolve, :js-options :resolve>> instead"
msgstr "`:package-json-resolution` 代わりに <<js-resolve, :js-options :resolve>> を参照してください。"

msgid "`:watch-fn`"
msgstr ""

msgid "`:process-shim`"
msgstr ""

msgid "Warnings as Errors"
msgstr ""

msgid "It is sometimes desireable to fail a build with warnings rather than continuing with the build (eg. in CI envs). You can use the `:warnings-as-errors` compiler options to customize how that is handled."
msgstr "ビルドを継続するのではなく、警告を表示してビルドを失敗させたいと思うことがあります (CI環境など)。コンパイラのオプション `:warnings-as-errors` を使って、この処理方法をカスタマイズすることができます。"

msgid "Treat all warnings as errors"
msgstr "すべての警告をエラーとして扱う"

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {...\n"
"   :compiler-options {:warnings-as-errors true}}}}"
msgstr ""

msgid "Only throw certain warnings"
msgstr "特定の警告のみを投げる"

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {...\n"
"   :compiler-options {:warnings-as-errors #{:undeclared-var}}}}"
msgstr ""

msgid "A set of possible warning-type keywords can be found https://github.com/clojure/clojurescript/blob/5ad96a8b3ae2e3616a19715ba9ba2471a36933a2/src/main/clojure/cljs/analyzer.cljc#L124-L163[here]."
msgstr "可能性のある警告型キーワードのセットは、 https://github.com/clojure/clojurescript/blob/5ad96a8b3ae2e3616a19715ba9ba2471a36933a2/src/main/clojure/cljs/analyzer.cljc#L124-L163[こちら] を参照してください。"

msgid "Only throw for certain namespaces"
msgstr "特定の名前空間に対してのみ投げる"

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {...\n"
"   :compiler-options {:warnings-as-errors {:ignore #{some.ns some.library.*}\n"
"                                           :warnings-types #{:undeclared-var}}}"
msgstr ""

msgid "`:ignore` takes a set of symbols refering to namespaces. Either direct matches or `.*` wildcards are allowed. `:warning-types` has the same functionality as above, not specifying it means all warnings will throw except the ignored namespaces."
msgstr "`:ignore` は名前空間を参照するシンボルのセットを取ります。直接一致か `.*` ワイルドカードのいずれかを使用することができます。`:warning-types` は上記と同じ機能を持ちますが、指定しない場合は無視された名前空間を除いてすべての警告を投げることになります。"

msgid "Output Language Options"
msgstr ""

msgid "By default the generated JS output will be compatible with ES5 and all \"newer\" features will be transpiled to compatible code using polyfills. This is currently the safest default and supports most browsers in active use (including IE10+)."
msgstr "デフォルトでは、生成された JS 出力は ES5 と互換性があり、すべての\"新機能\"は polyfills を使用して互換性のあるコードにトランスパイルされます。これは現在のところ最も安全なデフォルトであり、アクティブに使用されているほとんどのブラウザ (IE10+ を含む) をサポートしています。"

msgid "You can select other output options if you only care about more modern environments and want to keep the original code without replacements (eg. `node`, Chrome Extensions, ...)"
msgstr "よりモダンな環境にのみ配慮し、置換せずにオリジナルのコードを保持したい場合は、他の出力オプションを選択することができます (例: `node`, Chrome Extensions, ....など)。"

msgid "Note that this mostly affects imported JS code from <<npm, npm>> or `.js` files from the <<classpath-js, classpath>>. CLJS will currently only generate ES5 output and is not affected by setting higher options."
msgstr "これは主に <<npm, npm>> や `.js` ファイルを <<classpath-js, classpath>> からインポートした JS コードに影響を与えることに注意してください。CLJSは現在のところES5の出力のみを生成し、より高いオプションを設定しても影響を受けません。"

msgid "You can configure this via the `:output-feature-set` in `:compiler-options`. The older `:language-out` option should not be used as `:output-feature-set` replaced it."
msgstr "これは `:compiler-options` の `:output-feature-set` で設定できます。古い `:language-out` オプションは `:output-feature-set` に取って代わられたものなので、使用すべきではありません。"

msgid "Supported options are:"
msgstr ""

msgid "`:es3`"
msgstr ""

msgid "`:es5`"
msgstr ""

msgid "`:es6` - `class`, `const`, `let`, ..."
msgstr ""

msgid "`:es7` - exponent `**` operator"
msgstr ""

msgid "`:es8` - `async/await`, `generators`, object literals with spread, ..."
msgstr ""

msgid "`:es-next` - all the features the Closure Compiler currently supports"
msgstr ""

msgid "Example"
msgstr ""

msgid ""
"{...\n"
" :builds\n"
" {:script\n"
"  {:target :node-script\n"
"   :main foo.bar/main\n"
"   ...\n"
"   :compiler-options {:output-feature-set :es7}}}}"
msgstr ""

msgid "Documentation on these options is a bit sparse and is mostly documented in the code https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/parsing/parser/FeatureSet.java[here]."
msgstr "これらのオプションに関するドキュメントは少しまばらで、ほとんどが https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/parsing/parser/FeatureSet.java[こちら] のコードに書かれています。"

msgid "Conditional Reading"
msgstr ""

msgid "This feature only works in `shadow-cljs`. It was officially https://dev.clojure.org/jira/browse/CLJS-2396[rejected] by the ClojureScript project. It will still compile fine in CLJS but only the official branches work (e.g. `:cljs`). It might still be https://groups.google.com/d/msg/clojure-dev/8YJJM8lJuQs/hR5_vUZPCQAJ[supported] one day but as of now it is not."
msgstr "この機能は `shadow-cljs` でのみ動作します。ClojureScriptプロジェクトによって公式に https://dev.clojure.org/jira/browse/CLJS-2396[rejected] されました。CLJSではまだ問題なくコンパイルできますが、公式ブランチ(`:cljs` など)でしか動作しません。いつかは https://groups.google.com/d/msg/clojure-dev/8YJJM8lJuQs/hR5_vUZPCQAJ[supported] になるかもしれませんが、今のところはそうではありません。"

msgid "`shadow-cljs` lets you configure additional reader features in `.cljc` files. By default you can only use reader conditionals to generate separate code for `:clj`, `:cljs` or `:cljr`. In many CLJS builds however it is also desirable to select which code is generated based on your `:target`."
msgstr "`shadow-cljs` は `.cljc` ファイルに追加のリーダ機能を設定することができます。デフォルトでは `:clj`, `:cljs`, `:cljr` のために別々のコードを生成するためにリーダ条件式を使うことしかできません。しかし、多くの CLJS ビルドでは `:target` に基づいてどのコードを生成するかを選択することが望ましいです。"

msgid "Example: Some `npm` packages only work when targeting the `:browser`, but you may have a `ns` that you also want to use in a `:node-script` build. This might happen frequently when trying to use Server-Side Rendering (SSR) with your React App. `codemirror` is one such package."
msgstr "例: `npm` パッケージの中には `:browser` をターゲットにしたときにのみ動作するものもありますが `:node-script` ビルドでも使用したい `ns` があるかもしれません。これはReactアプリでサーバーサイドレンダリング(SSR)を使おうとしているときに頻繁に起こるかもしれません。 `codemirror` はそのようなパッケージの一つです。"

msgid ""
"(ns my.awesome.component\n"
"  (:require\n"
"    [\"react\" :as react]\n"
"    [\"codemirror\" :as CodeMirror]))\n"
"\n"
";; suppose you create a CodeMirror instance on some React :ref\n"
"(defn init-cm [dom-node]\n"
"  (let [cm (CodeMirror/fromTextArea dom-node #js {...})]\n"
"    ...))\n"
"\n"
"..."
msgstr ""

msgid "This namespace will compile fine for both builds (`:node-script` and `:browser`) but when trying to run the `:node-script` it will fail since the `codemirror` package tries to access the DOM. Since `react-dom/server` does not use refs the `init-cm` function will never be called anyways."
msgstr "この名前空間は両方のビルド(`:node-script` と `:browser`)で正常にコンパイルされますが `:node-script` を実行しようとすると `codemirror` パッケージが DOM にアクセスしようとするので失敗します。 `react-dom/server` は refs を使わないので `init-cm` 関数は決して呼ばれません。"

msgid "While you can use <<closure-defines, :closure-defines>> to conditionally compile away the `init-cm` fn you can not use it to get rid of the extra `:require`. Reader conditionals let you do this easily."
msgstr "<<closure-defines, :closure-defines>> を使って `init-cm` 関数を条件付きでコンパイルすることができますが、余分な `:require` を取り除くためには使えません。リーダー条件式を使えば、これを簡単に行うことができます。"

msgid ""
"(ns my.awesome.component\n"
" (:require\n"
"   [\"react\" :as react]\n"
"   ;; NOTE: The order here matters. Only the first applicable\n"
"   ;; branch is used. If :cljs is used first it will still be\n"
"   ;; taken by the :server build\n"
"   #?@(:node [[]]\n"
"       :cljs [[\"codemirror\" :as CodeMirror]])))\n"
"\n"
"#?(:node ;; node platform override\n"
"   (defn init-cm [dom-node]\n"
"    :no-op)\n"
"   :cljs ;; default impl\n"
"   (defn init-cm [dom-node]\n"
"     ... actual impl ...))\n"
"\n"
"..."
msgstr ""
"(ns my.awesome.component\n"
" (:require\n"
"   [\"react\" :as react]\n"
"   ;; 注意：ここでは順番が重要です。\n"
"   ;; 最初の該当するブランチが使われます。\n"
"   ;; もし :cljs が先に使われた場合は、 :server ビルドで取得されます\n"
"   #?@(:node [[]]\n"
"       :cljs [[\"codemirror\" :as CodeMirror]])))\n"
"\n"
"#?(:node ;; node platform override\n"
"   (defn init-cm [dom-node]\n"
"    :no-op)\n"
"   :cljs ;; default impl\n"
"   (defn init-cm [dom-node]\n"
"     ... actual impl ...))\n"
"\n"
"..."

msgid "<code>:reader-features</code> config examples"
msgstr "`:reader-feature` config examples"

msgid ""
"{...\n"
" :builds\n"
" ;; app build configured normally, no adjustments required\n"
" {:app\n"
"  {:target :browser\n"
"   ...}\n"
"  ;; for the server we add the :node reader feature\n"
"  ;; it will then be used instead of the default :cljs\n"
"  :server\n"
"  {:target :node-script\n"
"   :compiler-options\n"
"   {:reader-features #{:node}}}}}"
msgstr ""
"{...\n"
" :builds\n"
" ;; アプリのビルドは正常に設定されており、調整は必要ありません\n"
" {:app\n"
"  {:target :browser\n"
"   ...}\n"
"  ;; サーバに :node reader機能を追加すると\n"
"  ;; デフォルトの :cljs の代わりに使用されます\n"
"  :server\n"
"  {:target :node-script\n"
"   :compiler-options\n"
"   {:reader-features #{:node}}}}}"

msgid "The `:server` build will then no longer have the `codemirror` require and the `init-cm` function is removed. Becoming only"
msgstr "これで `:server` ビルドでは `codemirror` が不要になり `init-cm` 関数が削除されます。ただの"

msgid ""
"(ns my.awesome.component\n"
"  (:require\n"
"    [\"react\" :as react]))\n"
"\n"
";; this will likely be removed as dead code if\n"
";; its never actually called anywhere\n"
"\n"
"(defn init-cm [dom-node] :no-op)\n"
"..."
msgstr ""
"(ns my.awesome.component\n"
"  (:require\n"
"    [\"react\" :as react]))\n"
"\n"
";; これは、実際にはどこにも呼ばれなかった場合\n"
";; デッドコードとして削除される可能性が高いでしょう\n"
"\n"
"(defn init-cm [dom-node] :no-op)\n"
"..."

msgid "This feature is only available in `.cljc` files and will fail in `.cljs` files."
msgstr "この機能は `.cljc` ファイルでのみ利用可能で `.cljs` ファイルでは失敗します。"

msgid "Overriding from the CLI"
msgstr ""

msgid "It is sometimes desirable to make small adjustments to the build configuration from the command line with values that can't be added statically to the `shadow-cljs.edn` config or may change depending on the environment you are in."
msgstr "`shadow-cljs.edn` の設定に静的に追加できない値や、環境によっては変更される可能性のある値をコマンドラインからビルド設定に小さな調整を加えることが望ましい場合があります。"

msgid "You can pass additional config data via the `--config-merge {:some \"data\"}` command line option which will be merged into the build config. Data added from the CLI will override data from the `shadow-cljs.edn` file."
msgstr "追加の設定データを `--config-merge {:some \"data\"}` コマンドラインオプションで渡すことができます。CLIから追加されたデータは `shadow-cljs.edn` ファイルからのデータを上書きします。"

msgid "Example <code>shadow-cljs.edn</code> config"
msgstr "`shadow-cljs.edn` コンフィグの例"

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {:target :browser\n"
"   :output-dir \"public/js\"\n"
"   ...}}}"
msgstr ""

msgid "Overriding the <code>:output-dir</code> from the CLI"
msgstr "CLIから `:output-dir` を上書きする"

msgid "$ shadow-cljs release app --config-merge '{:output-dir \"somewhere/else\"}'"
msgstr ""

msgid "Overriding the <code>:closure-defines</code> from the CLI"
msgstr "CLIから `:closure-defines` を上書きする"

msgid "$ shadow-cljs release app --config-merge '{:closure-defines {your.app/DEBUG true}}'"
msgstr ""

msgid "`--config-merge` expects one EDN map and can be used multiple times, they will be merged left to right. The data added is also visible to build-hooks."
msgstr "`config-merge` は1つのEDNマップを想定しており、複数回使用することができるので、左から右にマージされます。追加されたデータはbuild-hooksからも見えます。"

msgid "If you specify multiple build ids the data will be merged into all specified builds. `shadow-cljs release frontend backend --config-merge '{:hello \"world\"}'` will be applied to both."
msgstr "複数のビルドIDを指定すると、指定した全てのビルドにマージされます。 `shadow-cljs release frontend backend --config-merge '{:hello \"world\"}'` は両方に適用されます。"

msgid "Using Environment Variables"
msgstr ""

msgid "It is possible to use environment variables to set configuration values in `shadow-cljs.edn` but you should consider using `--config-merge` instead. If you really must use an environment variable you can do so via the `#shadow/env \"FOO\"` reader tag. You can also use the shorter `#env`."
msgstr "環境変数を使って `shadow-cljs.edn` の設定値を設定することは可能ですが、代わりに `--config-merge` を使うことを検討してください。どうしても環境変数を使わなければならない場合は `#shadow/env \"FOO\"` リーダータグで設定することができます。もっと短い `#env` を使うこともできます。"

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {:target :browser\n"
"   :output-dir \"public/js\"\n"
"   :closure-defines {your.app/URL #shadow/env \"APP_URL\"}\n"
"   ...}}}"
msgstr ""

msgid "The are also a few more supported forms that you can use `#shadow/env` with."
msgstr "また `#shadow/env` で使用できるフォームもいくつかサポートされています。"

msgid ""
"#shadow/env \"APP_URL\"\n"
"#shadow/env [\"APP_URL\"]\n"
";; with default value, used if env variable is not set\n"
"#shadow/env [\"APP_URL\" \"default-value\"]\n"
"#shadow/env [\"APP_URL\" :default \"default-value\"]\n"
";; turn PORT env into an integer, with default\n"
"#shadow/env [\"PORT\" :as :int :default 8080]"
msgstr ""
"#shadow/env \"APP_URL\"\n"
"#shadow/env [\"APP_URL\"]\n"
";; 環境変数が設定されていない場合にデフォルト値として使用されます\n"
"#shadow/env [\"APP_URL\" \"default-value\"]\n"
"#shadow/env [\"APP_URL\" :default \"default-value\"]\n"
";; PORT 環境変数を整数に変換します\n"
"#shadow/env [\"PORT\" :as :int :default 8080]"

msgid "Supported `:as` coercions are `:int`, `:bool`, `:keyword`, `:symbol`. Supplied `:default` values will not be converted and are expected to be in the correct type already."
msgstr "サポートされる `:as` の強制力は `:int`, `:bool`, `:keyword`, `:symbol` です。与えられた `:default` の値は変換されず、すでに正しい型になっているものとみなされます。"

msgid "The environment variables used when the `shadow-cljs` process was started are used. If a server process is used its environment variables will be used over those potentially set by other commands. This is mostly relevant during development but may be confusing. `--config-merge` does not have this limitation."
msgstr "`shadow-cljs` プロセスが起動したときに使用された環境変数が使用されます。サーバプロセスが使用されている場合、その環境変数は他のコマンドで設定される可能性のある環境変数よりも優先して使用されます。これはほとんどの場合、開発中に関連していますが、混乱を招くかもしれません。 `config-merge` にはこの制限はありません。"

msgid "Build and Target defaults"
msgstr ""

msgid "It is possible to use set defaults that will be used for all builds, or for all targets of a certain type."
msgstr "すべてのビルド、または特定のタイプのすべてのターゲットに使用されるデフォルト設定を使用することができます。"

msgid "Configuration merge order is as follows `:build-defaults` -> `:target-defaults` -> actual build config -> extra config overrides."
msgstr "コンフィギュレーションのマージ順序は `:build-defaults` -> `:target-defaults` -> 実際のビルドコンフィグ -> 追加コンフィグの順で上書きされます。"

msgid ""
"{...\n"
" :build-defaults\n"
" {:closure-defines\n"
"   {your.app/VERBOSE true}}\n"
"\n"
" :target-defaults\n"
" {:browser\n"
"   {:js-options\n"
"     {:resolve {\"react\" {:target :global\n"
"                         :global \"React\"}}}}}\n"
"\n"
" :builds\n"
" {:app\n"
"  {:target :browser\n"
"   ...}}}"
msgstr ""

msgid "In this example the `:app` target will inherit both `:build-defaults` and the `:target-defaults` for `:browser`."
msgstr "この例では `:app` ターゲットは `:build-defaults` と `:browser` の `:target-defaults` の両方を継承します。"

msgid "Configs later in the merge order can override, but not remove previous configuration items. Once a default is set, the only way to remove it is by overriding it."
msgstr "マージ順の後の設定は、以前の設定項目を上書きすることはできますが、削除することはできません。デフォルトが設定されている場合、それを削除するには、それを上書きするしかありません。"

msgid "Targeting the Browser"
msgstr ""

msgid "The `:browser` target produces output intended to run in a Browser environment. During development it supports live code reloading, REPL, CSS reloading. The `release` output will be minified by the Closure Compiler with `:advanced` optimizations."
msgstr "`browser` ターゲットはブラウザ環境で実行することを意図した出力を生成します。開発中はライブコードのリロード、REPL、CSSのリロードをサポートしています。 `release` の出力はClosureコンパイラによって `:advanced` の最適化が施されて最小化されます。"

msgid "A basic browser configuration looks like this:"
msgstr ""

msgid ""
"{:dependencies [...]\n"
" :source-paths [...]\n"
"\n"
" :builds\n"
" {:app {:target :browser\n"
"        :output-dir \"public/assets/app/js\"\n"
"        :asset-path \"/assets/app/js\"\n"
"        :modules {:main {:entries [my.app]}}}]}"
msgstr ""

msgid "Output Settings"
msgstr ""

msgid "The browser target outputs a lot of files, and a directory is needed for them all. You'll need to serve these assets with some kind of server, and the Javascript loading code needs to know the server-centric path to these assets. The options you need to specify are:"
msgstr "ブラウザ ターゲットは多くのファイルを出力し、それらすべてのためのディレクトリが必要です。これらのアセットを何らかのサーバーで提供する必要があり、Javascript の読み込みコードは、これらのアセットへのサーバー中心のパスを知る必要があります。指定する必要があるオプションは以下の通りです。"

msgid "`:output-dir`"
msgstr ""

msgid "The directory to use for all compiler output."
msgstr "すべてのコンパイラの出力に使用するディレクトリです。"

msgid "`:asset-path`"
msgstr ""

msgid "The relative path from *web server's root* to the resources in `:output-dir`."
msgstr "*webサーバのルート* から `:output-dir` にあるリソースまでの相対パス。"

msgid "Your entry point javascript file and all related JS files will appear in `:output-dir`."
msgstr "エントリーポイントのjavascriptファイルと関連するすべてのJSファイルは `:output-dir` に現れます。"

msgid "Each build requires its own :output-dir, you may not put multiple builds into the same directory. This directory should also be exclusively owned by the build. There should be no other files in there. While `shadow-cljs` won't delete anything it is safer to leave it alone. Compilation creates many more files than just the main entry point javascript file during development: source maps, original sources, and generated sources."
msgstr "各ビルドはそれ自身の :output-dir を必要とし、複数のビルドを同じディレクトリに置くことはできません。また、このディレクトリはそのビルドが独占的に所有していなければなりません。他のファイルを入れてはいけません。 `shadow-cljs` は何も削除しませんが、放っておいた方が安全です。コンパイルは開発中にメインのエントリーポイントjavascriptファイル以外にも多くのファイルを作成します: ソースマップ、オリジナルのソース、生成されたソースなどです。"

msgid "The `:asset-path` is a prefix that gets added to the paths of module loading code inside of the generated javascript. It allows you to output your javascript module to a particular subdirectory of your web server's root. The dynamic loading during development (hot code reload) and production (code splitting) need this to correctly locate files."
msgstr "`asset-path` は生成された javascript の中のモジュールの読み込みコードのパスに追加される接頭辞です。これにより、javascriptモジュールをWebサーバーのルートの特定のサブディレクトリに出力することができます。開発中の動的な読み込み (ホットコードの再読み込み) や本番環境 (コードの分割) では、ファイルを正しく見つけるためにこれが必要になります。"

msgid "Locating your generated files in a directory and asset path like this make it so that other assets (images, css, etc.) can easily co-exist on the same server without accidental collisions."
msgstr "生成されたファイルをこのようにディレクトリとアセットパスに配置することで、他のアセット（画像やCSSなど）が偶然に衝突することなく、同じサーバー上に簡単に共存できるようになります。"

msgid "For example: if your web server will serve the folder `public/x` when asked for the URI `/x`, and your `output-dir` for a module is `public/assets/app/js` then your asset-path should be `/assets/app/js`. You are not required to use an absolute asset path, but it is highly recommended."
msgstr "例えば、URI `/x` を要求されたときにウェブサーバが `public/x` というフォルダを提供し、モジュールの `output-dir` が `public/assets/app/js` である場合、アセットパスは `/assets/app/js` でなければなりません。絶対的なアセットパスを使う必要はありませんが、それを強く推奨します。"

msgid "Modules"
msgstr ""

msgid "Modules configure how the compiled sources are bundled together and how the final `.js` are generated. Each Module declares a list of Entry Namespace and from that dependency graph is built. When using multiple Modules the code is split so that the maximum amount of code is moved to the outer edges of the graph. The goal is to minimize the amount of code the browser has to load initially and loading the rest on-demand."
msgstr "モジュールはコンパイルされたソースがどのようにバンドルされ、最終的な `.js` がどのように生成されるかを設定します。各モジュールは Entry Namespace のリストを宣言し、その依存関係グラフを構築します。複数のモジュールを使用する場合は、最大量のコードがグラフの外側に移動するようにコードが分割されます。目標は、ブラウザが最初にロードしなければならないコードの量を最小限に抑え、残りのコードをオンデマンドでロードすることです。"

msgid "Don't worry too much about :modules in the beginning. Start with one and split them later."
msgstr "最初のうちは :modules をあまり気にしないでください。最初は1つのモジュールから始めて、後で分割してください。"

msgid "The `:modules` section of the config is always a map keyed by module ID. The module ID is also used to generate the Javascript filename. Module `:main` will generate `main.js` in `:output-dir`."
msgstr "設定の `:modules` セクションは常にモジュールIDがキーとなるマップです。モジュールIDはJavascriptのファイル名を生成するためにも使われます。モジュール `:main` は `:output-dir` に `main.js` を生成します。"

msgid "The available options in a module are:"
msgstr "モジュールで利用可能なオプションは以下の通りです:"

msgid "`:entries`"
msgstr ""

msgid "The namespaces that serve as the root nodes of the dependency graph for the output code of this module."
msgstr "このモジュールの出力コードの依存関係グラフのルートノードとして機能する名前空間。"

msgid "`:init-fn`"
msgstr ""

msgid "Fully qualified symbol pointing to a function that should be called when the module is loaded initially."
msgstr "モジュールが最初にロードされたときに呼び出されるべき関数を指す完全修飾シンボル。"

msgid "`:depends-on`"
msgstr ""

msgid "The names of other modules that must be loaded in order for this one to have everything it needs."
msgstr "このモジュールに必要なものをすべて搭載するためにロードしなければならない他のモジュールの名前です。"

msgid "`:prepend`"
msgstr ""

msgid "String content that will be prepended to the js output. Useful for comments, copyright notice, etc."
msgstr "jsの出力の前に付加される文字列の内容。コメントや著作権表示などに便利です。"

msgid "`:append`"
msgstr ""

msgid "String content that will be appended to the js output. Useful for comments, copyright notice, etc."
msgstr "jsの出力に追加される文字列コンテンツ。コメントや著作権表示などに便利です。"

msgid "`:prepend-js`"
msgstr ""

msgid "A string to prepend to the module output containing valid javascript that will be run through Closure optimizer."
msgstr "Closureオプティマイザーで実行される有効なjavascriptを含むモジュールの出力に付加する文字列。"

msgid "`:append-js`"
msgstr ""

msgid "A string to append to the module output containing valid javascript that will be run through Closure optimizer."
msgstr "モジュールの出力に追加する文字列で、Closureオプティマイザーで実行される有効なjavascriptを含みます。"

msgid "The following example shows a minimum module configuration:"
msgstr "The following example shows a minimum module configuration:"

msgid "Example :browser config"
msgstr ""

msgid ""
"{...\n"
" :builds\n"
" {:app {:target :browser\n"
"        :output-dir \"public/js\"\n"
"        ...\n"
"        :modules {:main {:entries [my.app]}}}}}"
msgstr ""

msgid "Example :browser config with :init-fn"
msgstr ""

msgid ""
"{...\n"
" :builds\n"
" {:app {:target :browser\n"
"        :output-dir \"public/js\"\n"
"        ...\n"
"        :modules {:main {:init-fn my.app/init}}}}}"
msgstr ""

msgid "`shadow-cljs` will follow the dependency graph from the root set of code entry points in the `:entries` to find everything needed to actually compile and include in the output. Namespaces that are not required will not be included."
msgstr "`shadow-cljs` は `:entry` のコードエントリーポイントのルートセットから依存関係グラフを辿り、実際にコンパイルして出力に含めるために必要なすべてのものを見つけます。必要のない名前空間は含まれません。"

msgid "The above config will create a `public/js/main.js` file. During development there will be an additional `public/js/cljs-runtime` directory with lots of files. This directory is not required for `release` builds."
msgstr "上記の設定は `public/js/main.js` ファイルを作成します。開発中には、たくさんのファイルを含む `public/js/cljs-runtime` ディレクトリが追加されます。このディレクトリは `release` ビルドには必要ありません。"

msgid "Code Splitting"
msgstr ""

msgid "Declaring more than one Module requires a tiny bit of additional static configuration so the Compiler can figure out how the Modules are related to each other and how you will be loading them later."
msgstr "複数のモジュールを宣言するには、少しだけ静的な設定を追加する必要があります。これにより、コンパイラはモジュールがどのように相互に関連しているか、また後でどのようにモジュールをロードするかを把握することができます。"

msgid "In addition to `:entries` you'll need to declare which module depends on which (via `:depends-on`). How you structure this is entirely up to your needs and there is no one-size-fits-all solution unfortunately."
msgstr "どのモジュールがどのモジュールに依存しているかを宣言する必要があります ( `:deined-on` を使って)。これをどのように構成するかは完全にあなたのニーズ次第であり、残念ながらすべてに当てはまる解決策はありません。"

msgid "Say you have a traditional website with actual different pages."
msgstr "あなたが実際に異なるページを持つ伝統的なウェブサイトを持っているとします。"

msgid "`www.acme.com` - serving the homepage"
msgstr "`www.acme.com` - ホームページ"

msgid "`www.acme.com/login` - serving the login form"
msgstr "`www.acme.com/login` - ログインフォーム"

msgid "`www.acme.com/protected` - protected section that is only available once the user is logged in"
msgstr "`www.acme.com/protected` - ログインしていないと利用できない保護されたセクション"

msgid "One good configuration for this would be to have one common module that is shared between all the pages. Then one for each page."
msgstr "このための良い構成の一つは、各ページに1つずつ全てのページで共有される共通モジュールを持つことでしょう"

msgid "Example config with multiple <code>:modules</code>"
msgstr "Example config with multiple ':modules'"

msgid ""
"{...\n"
" :output-dir \"public/js\"\n"
" :modules\n"
" {:shared\n"
"  {:entries [my.app.common]}\n"
"  :home\n"
"  {:entries [my.app.home]\n"
"   :depends-on #{:shared}}\n"
"  :login\n"
"  {:entries [my.app.login]\n"
"   :depends-on #{:shared}}\n"
"  :protected\n"
"  {:entries [my.app.protected]\n"
"   :depends-on #{:shared}}"
msgstr ""

msgid "You can leave the `:entries` of the `:shared` module empty to let the compiler figure out which namespaces are shared between the other modules."
msgstr "`shared` モジュールの `:entries` を空のままにしておくと、コンパイラが他のモジュール間でどの名前空間が共有されているかを把握できるようになります。"

msgid "Generated file structure"
msgstr ""

msgid ""
".\n"
"└── public\n"
"    └── js\n"
"        ├── shared.js\n"
"        ├── home.js\n"
"        ├── login.js\n"
"        └── protected.js"
msgstr ""

msgid "In your HTML for the Homepage you'd then always include the `shared.js` on each page and the others conditionally depending on which page the user is on."
msgstr "ホームページ用のHTMLには常に `shared.js` を各ページに、その他のページにはユーザーがどのページにいるかに応じて条件付きで含めることになります。"

msgid "HTML for the <code>/login</code> page"
msgstr "'/login' のHTML"

msgid ""
"<script src=\"/js/shared.js\"></script>\n"
"<script src=\"/js/login.js\"></script>"
msgstr ""

msgid "The `.js` files must be included in the correct order. The <<BrowserManifest, `manifest.edn`>> can help with this."
msgstr "`.js` ファイルは正しい順序でインクルードしなければなりません。<<BrowserManifest, `manifest.edn`>>がこれを助けてくれます。"

msgid "Loading code dynamically"
msgstr ""

msgid "These days Single-Page-Apps (SPA) are becoming more popular and they work similarly only that instead of letting the Server decide which JS to include to Client does it by itself."
msgstr "最近ではシングルページアプリ(SPA)が人気を集めていますが、似たような働きをしています。"

msgid "Using shadow-cljs&#8217;s built-in Loader Support"
msgstr ""

msgid "The compiler supports generating the required data for using the `shadow.loader` utility namespace. It exposes a simple interface to let you load modules on-demand at runtime."
msgstr "コンパイラは `shadow.loader` ユーティリティの名前空間を使用するために必要なデータの生成をサポートしています。これは、実行時にモジュールをオンデマンドでロードできるようにするためのシンプルなインターフェースを公開しています。"

msgid "You only need to add `:module-loader true` to your build config. The loader will always be injected into the default module (the one everything else depends on)."
msgstr "ビルド設定に `:module-loader true` を追加するだけです。ローダは常にデフォルトのモジュール (他のすべてのものが依存するモジュール) に注入されます。"

msgid "At runtime you may use the `shadow.loader` namespace to load modules. You may also load a module eagerly by just using a `<script>` tag in your page."
msgstr "実行時には `shadow.loader` 名前空間を使ってモジュールをロードすることができます。また、ページ内で `<script>` タグを使用するだけで、積極的にモジュールをロードすることもできます。"

msgid ""
"{...\n"
" :builds\n"
"   {:app\n"
"     {:target :browser\n"
"      ...\n"
"      :module-loader true\n"
"      :modules {:main  {:entries [my.app]}\n"
"                :extra {:entries [my.app.extra]\n"
"                        :depends-on #{:main}}}}}}"
msgstr ""

msgid "If you had the following for your main entry point:"
msgstr "メインのエントリーポイントに以下のようなものがあったとします。"

msgid ""
"(ns my.app\n"
"  (:require [shadow.loader :as loader]))\n"
"\n"
"(defn fn-to-call-on-load []\n"
"  (js/console.log \"extra loaded\"))\n"
"\n"
"(defn fn-to-call-on-error []\n"
"  (js/console.log \"extra load failed\"))"
msgstr ""

msgid "Then the following expressions can be used for loading code:"
msgstr "そうすると、以下のような式でコードをロードすることができます。"

msgid "Loading a module"
msgstr ""

msgid ""
";; load returns a goog.async.Deferred, and can be used like a promise\n"
"(-> (loader/load \"extra\")\n"
"    (.then fn-to-call-on-load fn-to-call-on-error))"
msgstr ""
";; loadはgoog.async.Deferredを返し、promiseのように使うことができます。\n"
"(-> (loader/load \"extra\")\n"
"    (.then fn-to-call-on-load fn-to-call-on-error))"

msgid "Loading many modules"
msgstr ""

msgid ""
";; must be a JS array, also returns goog.async.Deferred\n"
"(loader/load-many #js [\"foo\" \"bar\"])"
msgstr ""
";; 引数はJS配列でなければなりませんがgoog.async.Deferredが返ります。\n"
"(loader/load-many #js [\"foo\" \"bar\"])"

msgid "Including a callback"
msgstr ""

msgid "(loader/with-module \"extra\" fn-to-call-on-load)"
msgstr ""

msgid "You can check if a module is loaded using `(loaded? \"module-name\")`."
msgstr "モジュールがロードされているかどうかは `(loaded? \"module-name\")` で確認できます。"

msgid "Loader Costs"
msgstr ""

msgid "Using the loader is very lightweight. It has a few dependencies which you may not be otherwise using. In practice using `:module-loader true` adds about 8KB gzip'd to the default module. This will vary depending on how much of `goog.net` and `goog.events` you are already using, and what level of optimization you use for your release builds."
msgstr "ローダの使用は非常に軽量です。ローダにはいくつかの依存関係がありますが、他の方法では使用しないかもしれません。実際には `:module-loader true` を使うと、デフォルトのモジュールに約8KBのgzipが追加されます。これは `goog.net` や `goog.event` をどの程度使用しているか、また、リリースビルドにどの程度の最適化を使用しているかによって異なります。"

msgid "Using the Standard ClojureScript API"
msgstr ""

msgid "The generated code is capable of using the standard ClojureScript `cljs.loader` API. See the https://clojurescript.org/news/2017-07-10-code-splitting[documentation] on the ClojureScript website for instructions."
msgstr "生成されたコードは標準のClojureScript `cljs.loader` APIを使用することができます。説明はClojureScriptのウェブサイトの https://clojurescript.org/news/2017-07-10-code-splitting[ドキュメンテーション] を参照してください。"

msgid "The advantage of using the standard API is that your code will play well with others. This may be of particular importance to library authors. The disadvantage is that the dynamic module loading API in the standard distribution is currently somewhat less easy-to-use than the support in `shadow-cljs`."
msgstr "標準APIを使用する利点は、あなたのコードが他の人とうまく連携できることです。これはライブラリの作者にとって特に重要かもしれません。不利な点は、標準ディストリビューションの動的モジュールロードAPIが `shadow-cljs` のサポートに比べて、現在のところ使い勝手がやや悪いことです。"

msgid "Output Wrapper"
msgstr ""

msgid "*Release builds only*: The code generated by the Closure Compiler `:advanced` compilation will create a lot of global variables which has the potential to create conflicts with other JS running in your page. To isolate the created variables the code can be wrapped in an anonymous function to the variables only apply in that scope."
msgstr "*リリースビルドのみ*: Closureコンパイラの `:advanced` コンパイルによって生成されたコードは、多くのグローバル変数を生成し、ページ内で実行されている他のJSとの競合を引き起こす可能性があります。作成された変数を分離するには、コードを匿名関数でラップして、そのスコープ内でのみ適用される変数にすることです。"

msgid "`release` builds for `:browser` with only one `:modules` are wrapped in `(function(){<the-code>}).call(this);` by default. So no global variables are created."
msgstr "`release` はデフォルトでは `:browser` のビルドで `:modules` が1つしかない場合は `(function(){<コード>}).call(this);` でラップされているので、グローバル変数は生成されません。そのため、グローバル変数は生成されません。"

msgid "When using multiple `:modules` (a.k.a <<CodeSplitting, code splitting>>) this is not enabled by default since each module must be able to access the variables created by the modules it depends on. The Closure Compiler supports an additional option to enable the use of an output wrapper in combination with multiple `:modules` named `:rename-prefix-namespace`. This will cause the Compiler to scope all \"global\" variables used by the build into one actual global variable. By default this is set to `:rename-prefix-namespace \"$APP\"` when `:output-wrapper` is set to `true`."
msgstr "複数の `:modules` (別名 <<CodeSplitting, code splitting>>) を使用する場合、これはデフォルトでは有効になっていません。Closureコンパイラは `:rename-prefix-namespace` という名前の複数の `:modules` と組み合わせて出力ラッパーを使用できるようにする追加オプションをサポートしています。これによりコンパイラーはビルドで使用される全ての「グローバル」変数を1つの実際のグローバル変数にスコープするようになります。デフォルトでは `:output-wrapper` が `true` に設定されている場合、これは `:remame-prefix-namespace \"$APP\"` に設定されています。"

msgid ""
"{...\n"
" :builds\n"
" {:target :browser\n"
"  ...\n"
"  :compiler-options\n"
"  {:output-wrapper true\n"
"   :rename-prefix-namespace \"MY_APP\"}}}"
msgstr ""

msgid "This will only create the `MY_APP` global variable. Since every \"global\" variable will now be prefixed by `MY_APP.` (e.g. `MY_APP.a` instead of just `a`) the code size can go up substantially. It is important to keep this short. Browser compression (e.g. `gzip`) helps reduce the overhead of the extra code but depending on the amount of global variables in your build this can still produce a noticeable increase."
msgstr "これは `MY_APP` グローバル変数を作成するだけです。すべての「global」変数の前に `MY_APP.` が付くようになったので (例えば `a` だけではなく `MY_APP.a`)、コードサイズは大幅に大きくなる可能性があります。これを短くしておくことが重要です。ブラウザ圧縮(例: `gzip`)は、余分なコードのオーバーヘッドを減らすのに役立ちますが、ビルド中のグローバル変数の量によっては、コードサイズが顕著に増加する可能性があります。"

msgid "Note that the created variable isn't actually useful directly. It will contain a lot of munged/minified properties. All exported (eg. `^:export`) variables will still be exported into the global scope and are not affect by this setting. The setting only serves to limit the amount of global variables created, nothing else. Do not use it directly."
msgstr "作成された変数は、実際には直接役立つものではないことに注意してください。この変数には、多くのmunged/minifiedされたプロパティが含まれています。すべてのエクスポートされた変数(例: `^:export`)はグローバルスコープにエクスポートされ、この設定の影響を受けません。この設定は、作成されるグローバル変数の量を制限するのに役立つだけで、他には何もありません。直接使用しないでください。"

msgid "Web Workers"
msgstr ""

msgid "The `:modules` configuration may also be used to generate files intended to be used as a Web Workers. You may declare any module as a Web Worker by setting `:web-worker true`. The generated file will contain some additional bootstrap code which will load its dependencies automatically. The way `:modules` work also ensures that code used only by the worker will also only be in the final file for the worker. Each worker should have a dedicated CLJS namespace."
msgstr "また `:modules` 設定は、ウェブワーカーとして利用することを意図したファイルを生成するためにも利用できる。任意のモジュールをウェブワーカーとして宣言するには `:web-worker true` を設定します。生成されたファイルには、依存関係を自動的にロードする追加のブートストラップコードが含まれます。モジュールが動作する方法は、ワーカーによってのみ使用されるコードが、ワーカーの最終ファイルにのみ存在することを保証します。各ワーカーは専用のCLJS名前空間を持つべきです。"

msgid "An example of generating a web worker script"
msgstr "ウェブワーカースクリプトの生成例"

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {:target :browser\n"
"   :output-dir \"public/js\"\n"
"   :asset-path \"/js\"\n"
"   ...\n"
"   :modules\n"
"   {:shared\n"
"    {:entries []}\n"
"    :main\n"
"    {:init-fn my.app/init\n"
"     :depends-on #{:shared}}\n"
"    :worker\n"
"    {:init-fn my.app.worker/init\n"
"     :depends-on #{:shared}\n"
"     :web-worker true}}\n"
"   }}}"
msgstr ""

msgid "The above configuration will generate `worker.js` which you can use to start the Web Worker. It will have all code from the `:shared` module available (but not `:main`). The code in the `my.app.worker` namespace will only ever execute in the worker. Worker generation happens in both development and release modes."
msgstr "上記の設定により `worker.js` が生成され、これを使ってウェブワーカーを起動することができます。これには `:shared` モジュールのすべてのコードが含まれています (ただし `:main` は含まれていません)。名前空間 `my.app.worker` のコードはワーカー内でのみ実行されます。ワーカーの生成は開発モードとリリースモードの両方で行われます。"

msgid "Note that the empty `:entries []` in the `:shared` module will make it collect all the code shared between the `:main` and `:worker` modules."
msgstr "`shared` モジュールの空の `:entries []` は `:main` と `:worker` モジュール間で共有されているすべてのコードを収集するようにすることに注意してください。"

msgid "Sample echo worker"
msgstr ""

msgid ""
"(ns my.app.worker)\n"
"\n"
"(defn init []\n"
"  (js/self.addEventListener \"message\"\n"
"    (fn [^js e]\n"
"      (js/postMessage (.. e -data)))))"
msgstr ""

msgid "Sample using the worker"
msgstr ""

msgid ""
"(ns my.app)\n"
"\n"
"(defn init []\n"
"  (let [worker (js/Worker. \"/js/worker.js\")]\n"
"    (.. worker (addEventListener \"message\" (fn [e] (js/console.log e))))\n"
"    (.. worker (postMessage \"hello world\"))))"
msgstr ""

msgid "Since we now have a `:shared` module you must ensure to load it properly in your HTML. If you just load `main.js` you will get an error."
msgstr "これで `:shared` モジュールができたので、それを HTML で適切にロードする必要があります。`main.js` を読み込んだだけではエラーが発生します。"

msgid "HTML Loading shared.js and main.js"
msgstr ""

msgid ""
"<script src=\"/js/shared.js\"></script>\n"
"<script src=\"/js/main.js\"></script>"
msgstr ""

msgid "Cacheable Output"
msgstr ""

msgid "In a web setting it is desirable to cache `.js` files for a very long time to avoid extra request. It is common practice the generate a unique name for the `.js` file for every released version. This changes the URL used to access it and thereby is safe to cache forever."
msgstr "ウェブ設定では、余計なリクエストを避けるために `.js` ファイルを非常に長い間キャッシュしておくことが望ましいです。一般的には、リリースされたバージョンごとに `.js` ファイルに一意の名前を生成します。これにより、アクセスに使用するURLが変更されるため、永遠にキャッシュしても安全です。"

msgid "Release Versions"
msgstr ""

msgid "Creating unique filenames for each release can be done via the `:release-version` config setting. Generally you'll pass this in from the command line via <<config-merge, --config-merge>>."
msgstr "各リリースに固有のファイル名を作成するには `:release-version` の設定で行うことができます。通常はコマンドラインから <<config-merge, --config-merge>> で指定します。"

msgid "shadow-cljs release app --config-merge '{:release-version \"v1\"}'"
msgstr ""

msgid "Example :modules config"
msgstr ""

msgid ""
"{...\n"
" :builds\n"
"   {:app\n"
"     {:target :browser\n"
"      ...\n"
"      :output-dir \"public/js\"\n"
"      :asset-path \"/js\"\n"
"      :modules {:main  {:entries [my.app]}\n"
"                :extra {:entries [my.app.extra]\n"
"                        :depends-on #{:main}}}}}}"
msgstr ""

msgid "This would create the `main.v1.js` and `extra.v1.js` files in `public/js` instead of the usual `main.js` and `extra.js`."
msgstr "これにより、通常の `main.js` と `extra.js` の代わりに `public/js` に `main.v1.js` と `extra.v1.js` のファイルが作成されます。"

msgid "You can use manual versions or something automated like the `git` sha at the time of the build. Just make sure that you bump whatever it is once you shipped something out to the user since with caching they won't be requesting newer versions of old files."
msgstr "手動のバージョンを使うこともできますし、ビルド時に `git` sha のような自動化されたものを使うこともできます。ただ、キャッシュを使うとユーザは古いファイルの新しいバージョンを要求しないためユーザに何かを出荷したら、それが何であれ弾き上げるようにしてください。"

msgid "Filenames with Fingerprint-Hash"
msgstr ""

msgid "You can add `:module-hash-names true` to your build config to automatically create a MD5 signature for each generated output module file. That means that a `:main` module will generate a `main.<md5hash>.js` instead of just the default `main.js`."
msgstr "ビルド設定に `:module-hash-names true` を追加することで、生成された各出力モジュールファイルの MD5 シグネチャを自動的に作成することができます。これは `:main` モジュールがデフォルトの `main.js` の代わりに `main.<md5hash>.js` を生成することを意味します。"

msgid "`:module-hash-names true` will include the full 32-length md5 hash, if you prefer a shorter version you can specify a number between 1-32 instead (eg. `:module-hash-names 8`). Be aware that shortening the hash may increase the chances of generating conflicts. I recommend using the full hash."
msgstr "`:module-hash-names true` の場合モジュールハッシュの長さが32で完全なmd5ハッシュを含んでいることになります。もし短い方が良い場合は、代わりに1-32の間の数字を指定することができます (例: `module-hash-name 8`)。ハッシュを短くすると競合が発生する可能性が高くなることに注意してください。完全なハッシュを使うことをお勧めします。"

msgid "Example :module-hash-names config"
msgstr ""

msgid ""
"{...\n"
" :builds\n"
"   {:app\n"
"     {:target :browser\n"
"      ...\n"
"      :output-dir \"public/js\"\n"
"      :asset-path \"/js\"\n"
"      :module-hash-names true\n"
"      :modules {:main  {:entries [my.app]}\n"
"                :extra {:entries [my.app.extra]\n"
"                        :depends-on #{:main}}}}}}"
msgstr ""

msgid "Instead of generating `main.js` it will now generate `main.<hash>.js` in the `:output-dir`."
msgstr "これまでの `main.js` の代わりに `:output-dir` に `main.<hash>.js` を生成するようになりました。"

msgid "Since the filename can change with every release it gets a little bit more complicated to include them in your HTML. The <<BrowserManifest, Output Manifest>> can help with that."
msgstr "リリースごとにファイル名が変わることがあるので、HTMLに含めるのは少し複雑になります。 <<BrowserManifest, Output Manifest>>がそれを助けてくれます。"

msgid "Output Manifest"
msgstr ""

msgid "`shadow-cljs` generates a `manifest.edn` file in the configured `:output-dir`. This file contains a description of the module config together with an extra `:output-name` property which maps the original module name to actual filename (important when using the `:module-hash-names` feature)."
msgstr "`shadow-cljs` は `:output-dir` に `manifest.edn` ファイルを生成します。このファイルにはモジュールの設定の説明と、元のモジュール名を実際のファイル名にマップする追加の `:output-name` プロパティが含まれています (`:module-hash-names` 機能を使うときに重要です)。"

msgid "Sample output of manifest.edn when using hashed filenames."
msgstr "ハッシュ化されたファイル名を使用した場合の manifest.edn の出力サンプル。"

msgid ""
"[{:module-id :common,\n"
"  :name :common,\n"
"  :output-name \"common.15D142F7841E2838B46283EA558634EE.js\",\n"
"  :entries [...],\n"
"  :depends-on #{},\n"
"  :sources [...]}\n"
" {:module-id :page-a,\n"
"  :name :page-a,\n"
"  :output-name \"page-a.D8844E305644135CBD5CBCF7E359168A.js\",\n"
"  :entries [...],\n"
"  :depends-on #{:common},\n"
"  :sources [...]}\n"
" ...]"
msgstr ""

msgid "The manifest contains all `:modules` sorted in dependency order. You can use it to map the `:module-id` back to the actual generated filename."
msgstr "マニフェストには、依存関係の順に並べ替えられたすべての `:modules` が含まれています。これを使って `:module-id` を実際に生成されたファイル名にマップすることができます。"

msgid "Development builds also produce this file and you may check if for modifications to know when a new build completed. `:module-hash-names` does not apply during development so you'll get the usual filenames."
msgstr "開発ビルドでもこのファイルが生成されますので、新しいビルドが完了したときに変更があるかどうかを確認することができます。開発中は `:module-hash-names` は適用されないので、通常のファイル名を取得します。"

msgid "You can configure the name of the generated manifest file via the `:build-options :manifest-name` entry. It defaults to `manifest.edn`. If you configure a filename with `.json` ending the output will be JSON instead of EDN. The file will be relative to the configured `:output-dir`."
msgstr "生成されるマニフェストファイルの名前は `:build-options :manifest-name` エントリで設定できます。デフォルトは `manifest.edn` です。ファイル名の末尾に `.json` を指定した場合、出力は EDN ではなく JSON になります。ファイルは設定された `:output-dir` からの相対的なものになります。"

msgid "Example manifest.json config"
msgstr ""

msgid ""
"{...\n"
" :builds\n"
"   {:app\n"
"     {:target :browser\n"
"      ...\n"
"      :build-options {:manifest-name \"manifest.json\"}\n"
"      :modules {:main  {:entries [my.app]}\n"
"                :extra {:entries [my.app.extra]\n"
"                        :depends-on #{:main}}}}}}"
msgstr ""

msgid "Development Support"
msgstr ""

msgid "The `:devtools` section of the configuration for `:browser` supports a few additional options for configuring an optional dev-time HTTP server for a build and CSS reloading."
msgstr "`:browser` の設定の `:devtools` セクションは、ビルドや CSS のリロードのためにオプションの dev-time HTTP サーバを設定するためのいくつかの追加オプションをサポートしています。"

msgid "Heads-Up Display (HUD)"
msgstr ""

msgid "The `:browser` target now uses a HUD to display a loading indicator when a build is started. It will also display warnings and errors if there are any."
msgstr "`:browser` ターゲットはビルドが開始されたときにロードインディケータを表示するために HUD を使用するようになりました。また、警告やエラーがあれば表示されます。"

msgid "You can disable it completely by setting `:hud false` in the `:devtools` section."
msgstr "これを完全に無効にするには `:devtools` セクションで `:hud false` を設定します。"

msgid "You may also toggle certain features by specifying which features you care about via setting `:hud #{:errors :warnings}`. This will show errors/warnings but no progress indicator. Available options are `:errors`, `:warnings`, `:progress`. Only options included will be enabled, all other will be disabled."
msgstr "また `:hud #{:errors :warnings}` を設定することで、気になる機能を指定して、特定の機能を切り替えることもできます。これにより、エラーや警告は表示されますが、進捗状況は表示されません。利用可能なオプションは `:errors`, `:warnings`, `:progress` です。含まれるオプションのみが有効になり、それ以外はすべて無効になります。"

msgid "Opening Files"
msgstr ""

msgid "Warnings include a link to source location which can be clicked to open the file in your editor. For this a little bit of config is required."
msgstr "警告にはソースの場所へのリンクが含まれており、クリックするとエディタでファイルを開くことができます。このためには少しの設定が必要です。"

msgid "You can either configure this in your `shadow-cljs.edn` config for the project or globally in your home directory under `~/.shadow-cljs/config.edn`."
msgstr "この設定は、プロジェクトの `shadow-cljs.edn` の設定で行うか、ホームディレクトリの `~/.shadow-cljs/config.edn` の下にあるグローバルな設定で行うことができます。"

msgid "<code>:open-file-command</code> configuration"
msgstr "`:open-file-command` configuration"

msgid ""
"{:open-file-command\n"
" [\"idea\" :pwd \"--line\" :line :file]}"
msgstr ""

msgid "The `:open-file-command` expects a vector representing a very simple DSL. Strings are kept as they are and keyword are replaced by their respective values. A nested vector can be used in case you need to combine multiple params, using `clojure.core/format` style pattern."
msgstr "`open-file-command` は非常に単純なDSLを表すベクトルを期待します。文字列はそのまま保持され、キーワードはそれぞれの値に置き換えられます。複数のパラメータを組み合わせる必要がある場合は `clojure.core/format` スタイルのパターンを使って、入れ子になったベクトルを使うことができます。"

msgid "The above example would execute"
msgstr "上記の例では、次のように実行されます。"

msgid "$ idea /path/to/project-root --line 3 /path/to/project-root/srv/main/demo/foo.cljs"
msgstr ""

msgid "<code>emacsclient</code> example"
msgstr "`emacsclient` example"

msgid ""
"{:open-file-command\n"
" [\"emacsclient\" \"-n\" [\"+%s:%s\" :line :column] :file]}"
msgstr ""

msgid "$ emacsclient -n +3:1 /path/to/project-root/srv/main/demo/foo.cljs"
msgstr ""

msgid "The available replacement variables are:"
msgstr "利用可能な置換変数は以下の通りです:"

msgid "`:pwd`"
msgstr ""

msgid "Process Working Directory (aka project root)"
msgstr "プロセス作業ディレクトリ (別名プロジェクトルート)"

msgid "`:file`"
msgstr ""

msgid "Absolute File Path"
msgstr "ファイルの絶対パス"

msgid "`:line`"
msgstr ""

msgid "Line Number of Warning/Error"
msgstr "警告/エラーの行番号"

msgid "`:column`"
msgstr ""

msgid "Column Number"
msgstr "カラム番号"

msgid "`:wsl-file`"
msgstr ""

msgid "Translated WSL file path. Useful when running `shadow-cljs` via WSL Bash. Translates a `/mnt/c/Users/someone/code/project/src/main/demo/foo.cljs` path into `C:\\Users\\...`"
msgstr "WSLファイルのパスを変換したもの。WSL Bashで `shadow-cljs` を実行するときに便利。`/mnt/c/Users/someone/code/project/src/main/demo/foo.cljs` のパスを `C:\\Users\\...` に変換します。"

msgid "`:wsl-pwd`"
msgstr ""

msgid "Translated `:pwd`"
msgstr "`:pwd` を変換したもの"

msgid "CSS Reloading"
msgstr ""

msgid "The Browser devtools can also reload CSS for you. This is enabled by default and in most cases requires no additional configuration when you are using the built-in <<dev-http, development HTTP servers>>."
msgstr "また、ブラウザのdevtoolsは、あなたのためにCSSをリロードすることができます。これはデフォルトで有効になっており、組み込みの <<dev-http, development HTTP servers>> を使用している場合は、ほとんどの場合、追加の設定は必要ありません。"

msgid "Any stylesheet included in a page will be reloaded if modified on the filesystem. Prefer using absolute paths but relative paths should work as well."
msgstr "ページに含まれるスタイルシートは、ファイルシステム上で変更されるとリロードされます。絶対パスの使用を推奨しますが、相対パスも同様に動作します。"

msgid "Example HTML snippet"
msgstr ""

msgid "<link rel=\"stylesheet\" href=\"/css/main.css\"/>"
msgstr ""

msgid "Example Hiccup since we aren&#8217;t savages"
msgstr ""

msgid "[:link {:rel \"stylesheet\" :href \"/css/main.css\"}]"
msgstr ""

msgid "Using the built-in dev HTTP server"
msgstr ""

msgid "This will cause the browser to reload `/css/main.css` when `public/css/main.css` is changed."
msgstr "これにより `public/css/main.css` が変更されたときにブラウザが `/css/main.css` をリロードするようになります。"

msgid "`shadow-cljs` currently provides no support for directly compiling CSS but the usual tools will work and should be run separately. Just make sure the output is generated into the correct places."
msgstr "`shadow-cljs` は現在のところ CSS の直接コンパイルをサポートしていませんが、通常のツールは動作しますので、別途実行する必要があります。ただ、出力が正しい場所に生成されることを確認してください。"

msgid "When you are not using the built-in HTTP Server you can specify `:watch-dir` instead which should be a path to the document root used to serve your content."
msgstr "組み込みのHTTPサーバを使用していない場合は、代わりに `:watch-dir` を指定することができます。"

msgid "Example :watch-dir config"
msgstr ""

msgid ""
"{...\n"
"    {:builds\n"
"      {:app {...\n"
"             :devtools {:watch-dir \"public\"}}}}"
msgstr ""

msgid "When your HTTP Server is serving the files from a virtual directory and the filesystem paths don't exactly match the path used in the HTML you may adjust the path by setting `:watch-path` which will be used as a prefix."
msgstr "HTTP サーバが仮想ディレクトリからファイルを提供していて、ファイルシステムのパスが HTML で使われているパスと正確に一致しない場合は `:watch-path` を設定することでパスを調整することができます。"

msgid "Example <code>public/css/main.css</code> being served under <code>/foo/css/main.css</code>"
msgstr "例 `public/css/main.css` が `/foo/css/main.css` の下に提供されている場合"

msgid ""
"{...\n"
" {:builds\n"
"  {:app\n"
"   {...\n"
"    :devtools {:watch-dir \"public\"\n"
"               :watch-path \"/foo\"}}}}"
msgstr ""

msgid "Proxy Support"
msgstr ""

msgid "By default the devtools client will attempt to connect to the `shadow-cljs` process via the configured <<http, HTTP server>> (usually `localhost`). If you are using a reverse proxy to serve your HTML that might not be possible. You can set `:devtools-url` to configure which URL to use."
msgstr "デフォルトでは、devtools クライアントは設定された <<http, HTTP server>> (通常は `localhost`) を介して `shadow-cljs` プロセスに接続しようとします。リバースプロキシを使って HTML を提供している場合は、それができないかもしれません。どのURLを使うかは `:devtools-url` で設定することができます。"

msgid ""
"{...\n"
" :builds\n"
" {:app {...\n"
"        :devtools {:before-load  my.app/stop\n"
"                   :after-load   my.app/start\n"
"                   :devtools-url \"https://some.host/shadow-cljs\"\n"
"                   ...}}}}"
msgstr ""

msgid "`shadow-cljs` will then use the `:devtools-url` as the base when making requests. It is not the final URL so you must ensure that all requests starting with the path you configured (eg. `/shadow-cljs/*`) are forwarded to the host `shadow-cljs` is running on."
msgstr "`shadow-cljs` はリクエストを行う際に `:devtools-url` をベースにします。これは最終的な URL ではないので、設定したパス (例えば `/shadow-cljs/*`) で始まるすべてのリクエストが `shadow-cljs` が動作しているホストに転送されるようにしなければなりません。"

msgid "Incoming Request to Proxy"
msgstr ""

msgid "https://some.host/shadow-cljs/ws/foo/bar?asdf"
msgstr ""

msgid "must forward to"
msgstr ""

msgid "http://localhost:9630/foo/bar?asdf"
msgstr ""

msgid "The client will make WebSocket request as well as normal XHR requests to load files. Ensure that your proxy properly upgrades WebSockets."
msgstr "クライアントは、ファイルをロードするために通常の XHR 要求と同様に WebSocket 要求を行います。プロキシが適切に WebSocket をアップグレードしていることを確認してください。"

msgid "The requests must be forwarded to the main <<http, HTTP server>>, not the one configured in the build itself."
msgstr "リクエストは、ビルド自体で設定されたものではなく、メインの <<http, HTTP server>> に転送されなければなりません。"

msgid "Targeting React Native"
msgstr ""

msgid "The `:target :react-native` produces code that is meant to integrate into the default `react-native` tooling (eg. `metro`). Tools like `expo` which wrap those tools should automatically work and require no additional setup."
msgstr "`:target :react-native` は、デフォルトの `react-native` ツール (例: `metro`) に統合するコードを生成します。これらのツールをラップする `expo` のようなツールは自動的に動作し、追加の設定は必要ありません。"

msgid "You will need the same basic <<config,main configuration>> as in other targets (like `:source-paths`), the build specific config is very minimal and requires at least 2 options (besides `:target` itself)"
msgstr "他のターゲット (`:source-paths` のようなもの) と同じ基本的な <<config,main configuration>> が必要ですが、ビルド固有の設定は非常に最小限で、少なくとも 2 つのオプションが必要です (`:target` 自体の他に)。"

msgid "(required). The namespace-qualified symbol of your apps init function. This function will be called once on startup and should probably render something."
msgstr "(必須)。アプリのinit関数の名前空間修飾シンボル。この関数は起動時に一度だけ呼び出され、おそらく何かをレンダリングする必要があります。"

msgid "(required). The directory used to write output files."
msgstr "(必須)。出力ファイルの書き込みに使用するディレクトリ。"

msgid "Sample :react-native config"
msgstr ""

msgid ""
"{:source-paths [...]\n"
" :dependencies [...]\n"
" ...\n"
" :builds\n"
" {:app\n"
"  {:target :react-native\n"
"   :init-fn demo.app/init\n"
"   :output-dir \"app\"}}}"
msgstr ""

msgid "When compiled this results in a `app/index.js` file intended to be used as an entry point for the `react-native` tools. During development the `:output-dir` will contain many more files but you should only reference the generated `app/index.js` directly. A `release` build will only generated the optimized `app/index.js` and requires no additional files."
msgstr "コンパイルすると `app/index.js` ファイルが生成され、これは `react-native` ツールのエントリーポイントとして使用されることを意図しています。開発中の `:output-dir` にはさらに多くのファイルが含まれますが、生成された `app/index.js` だけを直接参照するようにしてください。 `release` ビルドでは最適化された `app/index.js` が生成されるだけで、追加のファイルは必要ありません。"

msgid "React Native"
msgstr ""

msgid "There are two ways to use `react-native`, \"plain\" `react-native`, which allows you to use native code and libraries and the one \"wrapped\" in https://expo.io/[expo] (described below). All the steps described above are sufficient to start using shadow-cljs with the plain `react-native`. See this example repo:"
msgstr "`react-native` を使うには2つの方法があり、ネイティブコードやライブラリを使えるプレーンな `react-native` と https://expo.io/[expo] でラップされたもの(後述)です。上記のすべてのステップを踏めば、プレーンな `react-native` で shadow-cljs を使い始めることができます。この例のリポジトリを参照してください:"

msgid "https://github.com/thheller/reagent-react-native"
msgstr ""

msgid "Expo"
msgstr ""

msgid "https://expo.io/[expo] makes working with `react-native` quite easy. There are two provided example setups."
msgstr "https://expo.io/[expo] を使うと `react-native` を使うのがとても簡単になります。提供されている設定例は2つあります。"

msgid "https://github.com/thheller/fulcro-expo"
msgstr ""

msgid "https://github.com/thheller/reagent-expo"
msgstr ""

msgid "Both examples where generated using `expo init ...` and the only adjusted change in the config was adding the proper `entryPoint` to the generated `app.json`."
msgstr "どちらの例も `expo init ...` を使って生成されたもので、設定の変更点は生成された `app.json` に適切な `entryPoint` を追加することだけでした。"

msgid ""
"{\n"
"  \"expo\": {\n"
"    \"name\": \"hello-world\",\n"
"    \"slug\": \"reagent-expo\",\n"
"    ...\n"
"    \"entryPoint\":\"./app/index.js\",\n"
"    ...\n"
"  }\n"
"}"
msgstr ""

msgid "`expo` requires that a React Component is registered on startup which can be done manually or by using the `shadow.expo/render-root` function which takes care of creating the Component and instead directly expects a React Element instance to start rendering."
msgstr "これは手動で行うこともできますが `shadow.expo/render-root` 関数を使用することで行うこともでき、代わりにReact Elementのインスタンスがレンダリングを開始することを直接期待できます。"

msgid "From the Reagent <a href=\"https://github.com/thheller/reagent-expo/blob/2c73ed0513a8f5050b250c0c7e53b9ae7543cee9/src/main/test/app.cljs#L34-L40\">example</a>"
msgstr "From the Reagent https://github.com/thheller/reagent-expo/blob/2c73ed0513a8f5050b250c0c7e53b9ae7543cee9/src/main/test/app.cljs#L34-L40[example]"

msgid ""
"(defn start\n"
"  {:dev/after-load true}\n"
"  []\n"
"  (expo/render-root (r/as-element [root])))\n"
"\n"
"(defn init []\n"
"  (start))"
msgstr ""

msgid "`init` is called once on startup. Since the example doesn't need to do any special setup it just calls `start` directly. `start` will be called repeatedly when `watch` is running each time after the code changes were reloaded. The `reagent.core/as-element` function can be used to generate the required React Element from the reagent hiccup markup."
msgstr "`init` は起動時に一度だけ呼び出されます。この例では特別な設定をする必要がないので `start` を直接呼び出すだけです。 `start` は `watch` が実行されているときには、コードの変更がリロードされた後、毎回繰り返し呼び出されます。 `reagent.core/as-element` 関数は、ReagentのHiccup markupから必要なReact要素を生成するために利用できます。"

msgid "Targeting node.js"
msgstr ""

msgid "There is built-in support for generating code that is intended to be used as a stand-alone script, and also for code that is intended to be used as a library. See the section on <<config,common configuration>> for the base settings needed in a configuration file."
msgstr "スタンドアロンスクリプトとして使用することを目的としたコードや、ライブラリとして使用することを目的としたコードの生成をビルトインでサポートしています。設定ファイルに必要な基本設定については、 <<config,common configuration>> の項を参照してください。"

msgid "node.js Scripts"
msgstr ""

msgid "The `:target :node-script` produces single-file stand-alone output that can be run using `node.js`. The code is just ClojureScript, and an entry point is easy to define:"
msgstr "`:target :node-script` はシングルファイルのスタンドアロン出力を生成し `node.js` を使って実行できます。コードはClojureScriptだけで、エントリポイントの定義も簡単です。"

msgid ""
"(ns demo.script)\n"
"\n"
"(defn main [& cli-args]\n"
"  (prn \"hello world\"))"
msgstr ""

msgid "Build Options"
msgstr ""

msgid "You will need the same basic <<config,main configuration>> as in other targets (like `:source-paths`), but you'll need some node-specific build target options:"
msgstr "他のターゲット (`:source-paths` など) と同じ基本的な <<config,main configuration>> が必要ですが、いくつかのノード固有のビルドターゲットオプションが必要になります:"

msgid "`:main`"
msgstr ""

msgid "(required). The namespace-qualified symbol of your script's entry point function."
msgstr "(必須)。スクリプトのエントリポイント関数の名前空間修飾シンボル。"

msgid "`:output-to`"
msgstr ""

msgid "(required). The path and filename for the generated script."
msgstr "(必須)。生成されたスクリプトのパスとファイル名。"

msgid "(optional). The path for supporting files in development mode. Defaults to a cache directory."
msgstr "(オプション)。開発モードでサポートするファイルのパス。デフォルトはキャッシュディレクトリです。"

msgid "Sample node script build"
msgstr ""

msgid ""
"{:source-paths [...]\n"
" ...\n"
" :builds\n"
" {:script\n"
"  {:target :node-script\n"
"   :main demo.script/main\n"
"   :output-to \"out/demo-script/script.js\"}}}"
msgstr ""

msgid "When compiled this results in a standalone `out/demo-script/script.js` file intended to be called via `node script.js <command line args>`. When run it will call `(demo.script/main <command line args>)` function on startup. This only ever produces the file specified in `:output-to`. Any other support files (e.g. for development mode) are written to a temporary support directory."
msgstr "コンパイルすると、これはスタンドアロンの `out/demo-script/script.js` ファイルになり `node script.js <command line args>` から呼び出されることを意図しています。実行すると、起動時に `(demo.script/main <command line args>)` 関数が呼び出されます。これは `:output-to` で指定されたファイルのみを生成します。その他のサポートファイル(開発モード用など)は、一時的なサポートディレクトリに書き込まれます。"

msgid "You will often write scripts that run as servers or some other long-running process. Hot code reload can be quite useful when working with these, and it is simple to set up:"
msgstr "サーバーやその他の長時間稼働するプロセスとして動作するスクリプトを書くことが多いでしょう。ホットコードリロードはこれらの作業を行う際に非常に便利で、設定も簡単です:"

msgid "Add start/stop callback functions."
msgstr "start/stop コールバック関数を追加します。"

msgid "Configure the build use those hooks."
msgstr "これらのフックを使用するビルドを設定します。"

msgid "Here is an example http server in node:"
msgstr "ここではnode内のhttpサーバの例を示します:"

msgid "Sample node script with start/stop hooks for hot code reload."
msgstr "ホットコードのリロードのための satrt/stop フックを持つサンプルノードスクリプト。"

msgid ""
"(ns demo.script\n"
"  (:require [\"http\" :as http]))\n"
"\n"
"(defn request-handler [req res]\n"
"  (.end res \"foo\"))\n"
"\n"
"; a place to hang onto the server so we can stop/start it\n"
"(defonce server-ref\n"
"  (volatile! nil))\n"
"\n"
"(defn main [& args]\n"
"  (js/console.log \"starting server\")\n"
"  (let [server (http/createServer #(request-handler %1 %2))]\n"
"\n"
"    (.listen server 3000\n"
"      (fn [err]\n"
"        (if err\n"
"          (js/console.error \"server start failed\")\n"
"          (js/console.info \"http server running\"))\n"
"        ))\n"
"\n"
"    (vreset! server-ref server)))\n"
"\n"
"(defn start\n"
"  \"Hook to start. Also used as a hook for hot code reload.\"\n"
"  []\n"
"  (js/console.warn \"start called\")\n"
"  (main))\n"
"\n"
"(defn stop\n"
"  \"Hot code reload hook to shut down resources so hot code reload can work\"\n"
"  [done]\n"
"  (js/console.warn \"stop called\")\n"
"  (when-some [srv @server-ref]\n"
"    (.close srv\n"
"      (fn [err]\n"
"        (js/console.log \"stop completed\" err)\n"
"        (done)))))\n"
"\n"
"(js/console.log \"__filename\" js/__filename)"
msgstr ""

msgid "The associated configuration is (`shadow-cljs.edn`):"
msgstr "関連する設定は (`shadow-cljs.edn`) です。"

msgid "Adding hooks for hot code reload."
msgstr "ホットコードのリロードのためのフックを追加。"

msgid ""
"{...\n"
" :builds\n"
"   { :script {... as before\n"
"\n"
"              ; add in reload hooks\n"
"              :devtools {:before-load-async demo.script/stop\n"
"                         :after-load demo.script/start}}}}"
msgstr ""

msgid "Many libraries hide state or do actions that prevent hot code reloading from working well. There is nothing the compiler can do to improve this since it has no idea what those libraries are doing. Hot code reload will only work well in situations where you can cleanly \"stop\" and \"restart\" the artifacts used."
msgstr "多くのライブラリは状態を隠したり、ホットコードのリロードがうまく動作しないような動作をしています。コンパイラは、それらのライブラリが何をしているかを知らないので、これを改善することはできません。ホット・コード・リロードがうまくいくのは、使用されたアーティファクトをきれいに 「stop」と「restart」することができる状況でのみです。"

msgid "node.js Libraries"
msgstr ""

msgid "The `:target :node-library` emits code that can be used (via `require`) as a standard node library, and is useful for publishing your code for re-use as a compiled Javascript artifact."
msgstr "`:target :node-library` は、標準のノードライブラリとして(`require` を介して)利用できるコードを出力し、コンパイルされた Javascript の成果物として再利用するためにコードを公開するのに便利です。"

msgid "As with other modes the <<config, main configuration options>> apply and must be set. The target-specific options are:"
msgstr "他のモードと同様に <<config, main configuration options>> が適用され、設定しなければなりません。ターゲット固有のオプションは以下の通りです:"

msgid "`:target`"
msgstr ""

msgid "Use :node-library"
msgstr ""

msgid "(required). The path and filename for the generated library."
msgstr "(必須)。生成されたライブラリのパスとファイル名。"

msgid "The hot code reload story is similar to <<NodeHotCodeReload, the script target>>, but may not work as well since it cannot as easily control all of the code that is loaded."
msgstr "ホットコードのリロードの話は <<NodeHotCodeReload, the script target>> と似ていますが、ロードされるコードの全てを簡単に制御できないので、うまくいかないかもしれません。"

msgid "Controlling what code is actually exported is done via one of the following options:"
msgstr "実際にエクスポートされるコードを制御するには、以下のオプションのいずれかを使用します:"

msgid "`:exports` -  a map of keyword to fully qualified symbols"
msgstr "`:exports` -  キーワードと完全修飾シンボルのマップ"

msgid "`:exports-var` - a fully qualified symbol"
msgstr "`:exports-var` - 完全修飾シンボル"

msgid "`:exports-fn` - a fully qualified symbol"
msgstr "`:exports-fn` - 完全修飾シンボル"

msgid "Single static \"default\" export"
msgstr ""

msgid "`:exports-var` will just return whatever is declared under that var. It can point to a `defn` or normal `def`."
msgstr "`:exports-var` は、その var の下で宣言されたものを返すだけです。 これは `defn` または通常の `def` を指すことができます。"

msgid "Build config using <code>:exports-var</code>"
msgstr "Build config using `:exports-var`"

msgid ""
"{...\n"
" :builds {:lib {:output-to \"lib.js\"\n"
"                :exports-var demo.ns/f\n"
"                ...}}}"
msgstr ""

msgid "Example CLJS"
msgstr ""

msgid ""
"(ns demo.ns)\n"
"\n"
"(defn f [...] ...)\n"
";; OR\n"
"(def f #js {:foo ...})"
msgstr ""

msgid "Consuming the generated code"
msgstr ""

msgid ""
"$ node\n"
"> var f = require('./lib.js');\n"
"f(); // the actual demo.ns/f function"
msgstr ""

msgid "It is effectively generating `module.exports = demo.ns.f;`"
msgstr "効果的に `module.exports = demo.ns.f;` を生成しています。"

msgid "Multiple static named exports"
msgstr "複数の静的名前付きエクスポート"

msgid "Build configuration with multiple exports"
msgstr "複数のエクスポートで構成を構築"

msgid ""
"{...\n"
" :builds {:lib {:exports {:g       demo.ns/f\n"
"                          :h       other.ns/thing\n"
"                          :ns/ok?  another.ns/ok?}\n"
"                ...}}}"
msgstr ""

msgid "The keyword is used as the name of the entry in the exported object. *No munging is done* to this keyword name (but namespaces are dropped). So, the above example maps cljs `f` to `g`, etc.:"
msgstr "このキーワードは、エクスポートされたオブジェクトのエントリの名前として使用されます。このキーワード名には *munging は行われません*  (ただし、名前空間は削除されます)。ですから、上の例では cljs `f` を `g` などにマップしています。"

msgid ""
"$ node\n"
"> var lib = require('./lib.js');\n"
"lib.g(); // call demo-ns/f\n"
"lib[\"ok?\"](); // call another-ns/ok?"
msgstr ""

msgid "You can achieve the exact same thing by using `:exports-var` pointing to a `def`"
msgstr "`:exports-var` が指す `def` を使うことで、全く同じことができます。"

msgid ""
"(def exports #js {:g f\n"
"                  ...})"
msgstr ""

msgid "\"Dynamic\" exports"
msgstr ""

msgid "In addition you may specify `:exports-fn` as a fully qualified symbol. This should point to a function with no arguments which should return a JS object (or function). This function will only ever be called ONCE as `node` caches the return value."
msgstr "さらに、完全修飾シンボルとして `:exports-fn` を指定することもできます。これはJSオブジェクト(または関数)を返す引数を持たない関数を指します。この関数は `node` が戻り値をキャッシュするため、一度だけ呼び出されます。"

msgid ""
"(ns demo.ns\n"
"  (:require [demo.other :as other]))\n"
"\n"
"(defn generate-exports []\n"
"  #js {:hello hello\n"
"       :foo other/foo})"
msgstr ""

msgid ""
"{...\n"
" :builds {:lib {:exports-fn demo.ns/generate-exports\n"
"                ...}}}"
msgstr ""

msgid "The exports config automatically tracks exported symbols and passes them on to the optimization stage. This means that anything listed in `:exports` will not be renamed by Google Closure optimizations."
msgstr "exports設定は、エクスポートされたシンボルを自動的に追跡し、最適化の段階に渡します。これは `:exports` にリストされているものは、Google Closure の最適化によってリネームされないことを意味します。"

msgid "Full Example"
msgstr ""

msgid "The example below creates a `lib.js` file intended to be consumed via the normal Node `require` mechanism."
msgstr "以下の例では、通常のNodeの `require` メカニズムで消費されることを意図した `lib.js` ファイルを作成しています。"

msgid ""
"(ns demo.lib)\n"
"\n"
"(defn hello []\n"
"  (prn \"hello\")\n"
"  \"hello\")"
msgstr ""

msgid "The build configuration would be:"
msgstr "ビルド構成は次のようになります:"

msgid ""
"{...\n"
" :builds {:library {:target    :node-library\n"
"                    :output-to \"out/demo-library/lib.js\"\n"
"                    :exports   {:hello demo.lib/hello}}}}"
msgstr ""

msgid "and the runtime use is as you would expect:"
msgstr "で、実行時の使用方法は期待通りです:"

msgid ""
"$ cd out/demo-library\n"
"$ node\n"
"> var x = require('./lib');\n"
"undefined\n"
"> x.hello()\n"
"hello\n"
"'hello'"
msgstr ""

msgid "As `:node-script` this will only create the file specified in `:output-to`. The `:exports` map maps CLJS vars to the name they should be exported to."
msgstr "これは `:node-script` のように `:output-to` で指定されたファイルのみを作成します。マップ `:exports` は CLJS の vars をエクスポート先の名前にマップします。"

msgid "Development mode has the <<NodeModes,same setup>> as for node scripts (extra dependencies)."
msgstr "開発モードでは、ノードスクリプトと同様に <<NodeModes, same setup>> を使用します（余分な依存関係があります）。"

msgid "Creating <code>npm</code> packages"
msgstr "Creating `npm` packages"

msgid "Embedding in the JS Ecosystem&#8201;&#8212;&#8201;The <code>:npm-module</code> Target"
msgstr "Embedding in the JS Ecosystem&#8201;&#8212;&#8201;The `:npm-module` Target"

msgid "There is an additional target that is intended to integrate CLJS into an existing JS project. The output can seamlessly integrate with existing JS tools (eg. webpack, browserify, babel, create-react-app, ...) with little configuration."
msgstr "既存のJSプロジェクトにCLJSを統合することを目的とした追加ターゲットがあります。出力は既存のJSツール（例：webpack、browserify、babel、create-react-app、...）とほとんど設定なしでシームレスに統合することができます。"

msgid "The path for the output files are written to, defaults to `node_modules/shadow-cljs`."
msgstr "出力ファイルのパスはデフォルトで `node_modules/shadow-cljs` に書き込まれます。"

msgid "(required) A vector of namespace symbols that should be compiled"
msgstr "(必須) コンパイルされるべき名前空間シンボルのベクトル"

msgid ""
"{...\n"
" :builds\n"
" {:code\n"
"  {:target :npm-module\n"
"   :entries [demo.foo]}}}"
msgstr ""

msgid "If you use the default `:output-dir` of `\"node_modules/shadow-cljs\"` you can access the declared namespaces by using `require(\"shadow-cljs/demo.foo\")` in JS. When using something not in `node_modules` you must include them using a relative path. With `:output-dir \"out\"` that would be `require(\"./out/demo.foo\")` from your project root."
msgstr "デフォルトの `:output-dir` の `\"node_modules/shadow-cljs\"` を使っている場合は、JSで `require(\"shadow-cljs/demo.foo\")` を使うことで、宣言された名前空間にアクセスすることができます。 `node_modules` にないものを使うときは、相対パスを使ってインクルードする必要があります。`:output-dir &#34;out&#34;` とすると、プロジェクトのルートから `require(&#34;./out/demo.foo&#34;)` となります。"

msgid "If you plan to distribute code on NPM, then you may want to use the <<NodeLibrary, `:node-library` target>> instead since it allows for a finer level of control over exports and optimization."
msgstr "NPM上でコードを配布する予定があるのであれば、代わりに <<NodeLibrary, `:node-library` target>> を使うのが良いでしょう。"

msgid "Working with Optimizations"
msgstr ""

msgid "Unlike the `:node-library` target, the module target does not know what you want to call the symbols you're exporting, so it just exports them as-is. If you use advanced compilation, then everything will get a minified munged name!"
msgstr "`:node-library` ターゲットとは異なり、モジュールターゲットはエクスポートしたシンボルを何と呼びたいかを知らないので、そのままエクスポートします。advanced コンパイルを使っている場合は、すべてのものが短縮化された名前になります!"

msgid "This is easy to remedy, simply add `:export` metadata on any symbols that you want to preserve:"
msgstr "保存したいシンボルに `:export` のメタデータを追加するだけです:"

msgid ""
"(ns demo.foo)\n"
"\n"
"(def ^:export foo 5.662)\n"
"\n"
"(defn ^:export bar [] ...)"
msgstr ""

msgid "This is a standard annotation that is understood by ClojureScript and prevents Google Closure from renaming an artifact. JS code will still be able to access them after optimizations. Without the `^:export` hint the closure-compiler will likely have removed or renamed them."
msgstr "これはClojureScriptで理解されている標準的なアノテーションで、Google Closureがアーティファクトの名前を変更するのを防ぎます。JSコードは最適化された後でもアクセスすることができます。ヒント `^:export` がなければ、クロージャコンパイラはそれらを削除したり、名前を変更したりしているでしょう。"

msgid ""
"var ns = require(\"shadow-cljs/demo.foo\");\n"
"\n"
"ns.foo;\n"
"ns.bar();"
msgstr ""

msgid "Testing"
msgstr ""

msgid "`shadow-cljs` provides a few utility targets to make building tests a little easier."
msgstr "`shadow-cljs` はテストのビルドを少し簡単にするためのユーティリティターゲットをいくつか提供します。"

msgid "All test targets generate a test runner and automatically add all namespaces matching the configurable `:ns-regexp`. The default test runners were built for `cljs.test` but you can create custom runners if you prefer to use other test frameworks."
msgstr "すべてのテストターゲットはテストランナーを生成し、設定可能な `:ns-regexp` にマッチするすべての名前空間を自動的に追加します。デフォルトのテストランナーは `cljs.test` 用にビルドされていますが、他のテストフレームワークを使いたい場合はカスタムランナーを作成することができます。"

msgid "The default `:ns-regexp` is `\"-test$\"`, so your first test could look like:"
msgstr "デフォルトの `:ns-regexp` は `\"-test$\"` なので、最初のテストは以下のようになります:"

msgid "File: <code>src/test/demo/app_test.cljs</code>"
msgstr "File: `src/test/demo/app_test.cljs`"

msgid ""
"(ns demo.app-test\n"
"  (:require [cljs.test :refer (deftest is)]))\n"
"\n"
"(deftest a-failing-test\n"
"  (is (= 1 2)))"
msgstr ""

msgid "In the Clojure world it is common to keep test files in their own source paths so the above example assumes you have configured `:source-paths [\"src/main\" \"src/test\"]` in your `shadow-cljs.edn` config. Your usual app code goes into `src/main` and the tests go into `src/test`. This however is optional and it is totally fine to keep everything in `src` and just use `:source-paths [\"src\"]`."
msgstr "Clojureの世界では、テストファイルをそれぞれのソースパスに保存するのが一般的ですので、上の例では `shadow-cljs.edn` の設定で `:source-paths [\"src/main\" \"src/test\"]` を設定したと仮定しています。通常のアプリのコードは `src/main` に、テストは `src/test` に入れます。これは任意で、全てを `src` に入れておいて `:source-paths [&#34;src&#34;]` を使っても全く問題ありません。"

msgid "Testing in node.js"
msgstr ""

msgid "This target will create a test runner including all test namespaces matching the given regular expression."
msgstr "このターゲットは、指定された正規表現にマッチするすべてのテスト名前空間を含むテストランナーを作成します。"

msgid "The relevant configuration options are:"
msgstr "関連する設定オプションは以下の通りです:"

msgid "`:node-test`"
msgstr ""

msgid "The final output file that will be used to run tests."
msgstr "テストの実行に使用される最終的な出力ファイル。"

msgid "`:ns-regexp`"
msgstr ""

msgid "(optional) A regular expression matching namespaces against project files. This only scans files, and will not scan jars. Defaults to `\"-test$\"`."
msgstr "(オプション) プロジェクトファイルに対して名前空間をマッチさせる正規表現。これはファイルのみをスキャンし、jarはスキャンしません。デフォルトは `\"-test$test\"` です。"

msgid "`:autorun`"
msgstr ""

msgid "(boolean, optional) Run the tests via `node` when a build completes. This is mostly meant to be used in combination with `watch`. The `node` process exit code will not be returned as that would have to forcefully kill the running JVM."
msgstr "(boolean, オプション) ビルドが完了したときに `node` 経由でテストを実行します。これは主に `watch` と組み合わせて使うことを意図しています。実行中のJVMを強制的に終了させる必要があるため `node` プロセスの終了コードは返されません。"

msgid "(qualified symbol, optional) Function called on startup to run the tests, defaults to `shadow.test.node/main` which runs tests using `cljs.test`."
msgstr "(修飾されたシンボルです,オプション) 起動時にテストを実行するために呼び出される関数です。デフォルトは `shadow.test.node/main` で、これは `cljs.test` を使ってテストを実行します。"

msgid "Test config matching all <code>*-spec</code> namespaces"
msgstr "すべての `*-spec` 名前空間にマッチする設定をテストする"

msgid ""
"{...\n"
" :builds\n"
" {:test\n"
"  {:target    :node-test\n"
"   :output-to \"out/node-tests.js\"\n"
"   :ns-regexp \"-spec$\"\n"
"   :autorun   true}}}"
msgstr ""

msgid "The `:node-test` target only generates the test file. You can run it via `node`."
msgstr "ターゲット `:node-test` はテストファイルを生成するだけです。 `node` を経由して実行することができます。"

msgid ""
"$ shadow-cljs compile test\n"
"# or\n"
"$ shadow-cljs release test\n"
"\n"
"# run tests manually, :autorun will do this automatically\n"
"$ node out/node-tests.js\n"
"\n"
"# compile & test combined\n"
"$ shadow-cljs compile test && node out/node-tests.js"
msgstr ""

msgid "The `node` process exit code will be set to `0` when successful and `1` on any failures. (The `node` process exit code will not be returned when using `:autorun`.)"
msgstr "成功した場合は `node` のプロセス終了コードは `0` に、失敗した場合は `1` に設定されます。(`:autorun` を利用している場合は `node` のプロセス終了コードは返されません)。"

msgid "Testing in the Browser"
msgstr ""

msgid "This target is meant for gathering up namespaces that contain tests (based on a filename pattern match), and triggering a test runner. It contains a built-in runner that will automatically scan for `cljs.test` tests and run them."
msgstr "このターゲットは、(ファイル名のパターンマッチに基づいて)テストを含む名前空間を収集し、テストランナーを起動するためのものです。自動的に `cljs.test` テストをスキャンして実行する組み込みのランナーが含まれています。"

msgid "`:browser-test`"
msgstr ""

msgid "`:test-dir`"
msgstr ""

msgid "A folder in which to output files. See below."
msgstr "ファイルを出力するフォルダ。下記参照。"

msgid "(optional) A regular expression matching namespaces against project files. This only scans files, and will not scan jars. Defaults to \"-test$\"."
msgstr "(オプション) プロジェクトファイルに対して名前空間をマッチさせる正規表現。これはファイルのみをスキャンし、jarはスキャンしません。デフォルトは \"-test$$\" です。"

msgid "`:runner-ns`"
msgstr ""

msgid "(optional) A namespace that can contain a start, stop, and init function. Defaults to `shadow.test.browser`."
msgstr "(オプション) start、stopおよび init 関数を含むことができる名前空間。デフォルトは `shadow.test.browser` です。"

msgid "The normal `:devtools` options are supported, so you will usually create an http server to serve the files. In general you will need a config that looks like this:"
msgstr "通常の `:devtools` オプションがサポートされているので、通常はファイルを提供するために http サーバを作成します。一般的には以下のような設定が必要になります:"

msgid ""
"{...\n"
" :builds {:test     {:target    :browser-test\n"
"                     :test-dir  \"resources/public/js/test\"\n"
"                     :ns-regexp \"-spec$\"\n"
"                     :runner-ns tests.client-test-main\n"
"                     :devtools  {:http-port          8021\n"
"                                 :http-root          \"resources/public/js/test\"}}"
msgstr ""

msgid "Remember that the test directory will have the index.html, and a js folder."
msgstr "テストディレクトリにはindex.htmlとjsフォルダがあることを覚えておいてください。"

msgid "If you choose to supply a custom `:runner-ns`, it might look like this:"
msgstr "カスタムの `:runner-ns` を指定すると、以下のようになります:"

msgid ""
"(ns tests.client-test-main)\n"
"\n"
"(defn start []\n"
"  ... run the tests...)\n"
"\n"
"(defn stop [done]\n"
"  ; tests can be async. You must call done so that the runner knows you actually finished\n"
"  (done))\n"
"\n"
"(defn ^:export init []\n"
"  (start))"
msgstr ""
"(ns tests.client-test-main)\n"
"\n"
"(defn start []\n"
"  ... run the tests...)\n"
"\n"
"(defn stop [done]\n"
"  ; テストは非同期にすることができます。ランナーが実際に終了したことを知ることができるように done を呼び出す必要があります  (done))\n"
"\n"
"(defn ^:export init []\n"
"  (start))"

msgid "It just has `init`, `start`, `stop` methods. `init` will be called once on startup, `stop` will be called before any code is reloaded and `start` will be called after all code was reloaded."
msgstr "これは単に `init`, `start`, `stop` メソッドを持っているだけです。 `init` は起動時に一度だけ呼び出され `stop` はコードがリロードされる前に呼び出され `start` はすべてのコードがリロードされた後に呼び出されます。"

msgid "`:runner-ns` is optional, just leave it out to use the default."
msgstr "`:runner-ns` はオプションで、デフォルトのままにしておきます。"

msgid "Generated output in <code>:test-dir</code>"
msgstr "Generated output in `:test-dir`"

msgid "The output includes two primary artifacts in your `test-dir` folder:"
msgstr "出力には `test-dir` フォルダ内の2つの主要な成果物が含まれています。"

msgid "`index.html` - If and only if there was not already an `index.html` file present. By default the generated file loads the tests and runs `init` in the `:runner-ns`. You may edit or add a custom version that will not be overwritten."
msgstr "`index.html` - `index.html` ファイルが存在しない場合に限ります。デフォルトでは、生成されたファイルはテストをロードして `:runner-ns` で `init` を実行します。上書きされないカスタムバージョンを編集したり、追加したりすることができます。"

msgid "`js/test.js` - The Javascript tests. The tests will always have this name. The entries for the module are auto-generated."
msgstr "`js/test.js` - Javascriptのテスト。テストは常にこの名前を持ちます。モジュールのエントリは自動生成されます。"

msgid "Targeting Tests to Karma for Continuous Integration"
msgstr "継続的インテグレーションのためにテストをKarmaターゲットに絞る"

msgid "When you want to run your CLJS tests against a browser on some kind of CI server you'll need to be able to run the tests from a command line and get back a status code. Karma is a well-known and supported test runner that can do this for you, and `shadow-cljs` includes a target that can add the appropriate wrappers around your tests so they will work in it."
msgstr "ある種のCIサーバ上のブラウザに対してCLJSテストを実行したい場合、コマンドラインからテストを実行してステータスコードを返すことができる必要があります。Karma はよく知られていてサポートされているテストランナーであり `shadow-cljs` にはテストに適切なラッパーを追加してテストを実行できるようにするターゲットが含まれています。"

msgid "Installing Karma"
msgstr ""

msgid "See their http://karma-runner.github.io[website] for full instructions. You'll typically need something like this is your `package.json`:"
msgstr "完全な説明は http://karma-runner.github.io[website] を参照してください。通常、以下のようなものが必要になります。"

msgid ""
"{\n"
"  \"name\": \"CITests\",\n"
"  \"version\": \"1.0.0\",\n"
"  \"description\": \"Testing\",\n"
"  ...\n"
"  \"devDependencies\": {\n"
"    \"karma\": \"^2.0.0\",\n"
"    \"karma-chrome-launcher\": \"^2.2.0\",\n"
"    \"karma-cljs-test\": \"^0.1.0\",\n"
"    ...\n"
"  },\n"
"  \"author\": \"\",\n"
"  \"license\": \"MIT\"\n"
"}"
msgstr ""

msgid "So, you need Karma, a browser launcher, and the cljs-test integration."
msgstr "そのためには、Karma、ブラウザランチャー、cljs-testの統合が必要です。"

msgid "The Build"
msgstr ""

msgid "The build options are:"
msgstr "ビルドオプション:"

msgid "`:karma`"
msgstr ""

msgid "A path/filename for the js file."
msgstr "jsファイルのパス/ファイル名。"

msgid "(optional) A regex to match the test namespaces, defaults to \"-test$"
msgstr "(オプション) テストの名前空間にマッチする正規表現、デフォルトは\"-test$\"です。"

msgid "So you might have something like this:"
msgstr "なので、こんな感じのものがあるかもしれません:"

msgid ""
"{...\n"
" :builds\n"
" {:ci\n"
"  {:target :karma\n"
"   :output-to  \"target/ci.js\"\n"
"   :ns-regexp  \"-spec$\"}}}"
msgstr ""

msgid "You also need a `karma.conf.js`:"
msgstr "また `karma.conf.js` も必要です。"

msgid ""
"module.exports = function (config) {\n"
"    config.set({\n"
"        browsers: ['ChromeHeadless'],\n"
"        // The directory where the output file lives\n"
"        basePath: 'target',\n"
"        // The file itself\n"
"        files: ['ci.js'],\n"
"        frameworks: ['cljs-test'],\n"
"        plugins: ['karma-cljs-test', 'karma-chrome-launcher'],\n"
"        colors: true,\n"
"        logLevel: config.LOG_INFO,\n"
"        client: {\n"
"            args: [\"shadow.test.karma.init\"],\n"
"            singleRun: true\n"
"        }\n"
"    })\n"
"};"
msgstr ""
"module.exports = function (config) {\n"
"    config.set({\n"
"        browsers: ['ChromeHeadless'],\n"
"        // 出力ファイルがあるディレクトリ\n"
"        basePath: 'target',\n"
"        // ファイルそのもの\n"
"        files: ['ci.js'],\n"
"        frameworks: ['cljs-test'],\n"
"        plugins: ['karma-cljs-test', 'karma-chrome-launcher'],\n"
"        colors: true,\n"
"        logLevel: config.LOG_INFO,\n"
"        client: {\n"
"            args: [\"shadow.test.karma.init\"],\n"
"            singleRun: true\n"
"        }\n"
"    })\n"
"};"

msgid "then you can run the tests as follows (assuming you've installed global executables of the tools):"
msgstr "で、以下のようにテストを実行することができます（ツールのグローバル実行ファイルをインストールしていると仮定します）"

msgid ""
"$ shadow-cljs compile ci\n"
"$ karma start --single-run\n"
"12 01 2018 01:19:24.222:INFO [karma]: Karma v2.0.0 server started at http://0.0.0.0:9876/\n"
"12 01 2018 01:19:24.224:INFO [launcher]: Launching browser ChromeHeadless with unlimited concurrency\n"
"12 01 2018 01:19:24.231:INFO [launcher]: Starting browser ChromeHeadless\n"
"12 01 2018 01:19:24.478:INFO [HeadlessChrome 0.0.0 (Mac OS X 10.12.6)]: Connected on socket TcfrjxVKmx7xN6enAAAA with id 85554456\n"
"LOG: 'Testing boo.sample-spec'\n"
"HeadlessChrome 0.0.0 (Mac OS X 10.12.6): Executed 1 of 1 SUCCESS (0.007 secs / 0.002 secs)"
msgstr ""

msgid "JavaScript Integration"
msgstr ""

msgid "https://www.npmjs.com/[npm] has come the de-facto standard package manager for JavaScript. Almost all JS libraries can be found there and shadow-cljs provides seamless integration for accessing those packages."
msgstr "https://www.npmjs.com/[npm] は JavaScript のデファクトスタンダードなパッケージマネージャです。ほとんどすべてのJSライブラリがここにあり、shadow-cljsはそれらのパッケージにアクセスするためのシームレスな統合を提供しています。"

msgid "Using npm packages"
msgstr ""

msgid "Most npm packages will also include some instructions on how to use the actual code. The “old” CommonJS style just has require calls which translate directly:"
msgstr "ほとんどの npm パッケージには、実際のコードの使用方法についての説明が含まれています。「古い」 CommonJS のスタイルは、直接変換する require 呼び出しを持っているだけです。"

msgid "var react = require(\"react\");"
msgstr ""

msgid ""
"(ns my.app\n"
"  (:require [\"react\" :as react]))"
msgstr ""

msgid "Whatever \"string\" parameter is used when calling require we transfer to the `:require` as-is. The `:as` alias is up to you. Once we have that we can use the code like any other CLJS namespace!"
msgstr "requireを呼び出す際に使用される文字列パラメータが何であれ、そのまま `:require` に転送します。\":as\" の別名はあなた次第です。これがわかれば、他のCLJSの名前空間と同じようにコードを使うことができます。"

msgid "(react/createElement \"div\" nil \"hello world\")"
msgstr ""

msgid "In `shadow-cljs`: *always use the `ns` form and whatever `:as` alias you provided.* You may also use `:refer` and `:rename`. This is different than what `:foreign-libs`/CLJSJS does where you include the thing in the namespace but then used a global `js/Thing` in your code."
msgstr "`shadow-cljs` では、 *常に `ns` 形式と指定した `:as` のエイリアスを使用します。* また `:reference` や `:rename` を使うこともできます。これは `:foreign-libs`/CLJSJS が行うものとは異なり、名前空間にそれをインクルードし、コードの中でグローバルな `js/Thhing` を使用します。"

msgid "Some packages just export a single function which you can call directly by using `(:require [\"thing\" :as thing])` and then `(thing)`."
msgstr "パッケージによっては `(:require [\"thing\" :as thing])` と `(thing)` を使って直接呼び出すことができる関数をエクスポートするだけのものもあります。"

msgid "More recently some packages started using ES6 `import` statements in their examples. Those also translate pretty much 1:1 with one slight difference related to default exports."
msgstr "最近では、いくつかのパッケージが ES6 の `import` 文を使用するようになりました。これらのパッケージも、デフォルトのエクスポートに関連したわずかな違いがありますが、ほぼ1:1で変換されています。"

msgid "The following table can be used for translation:"
msgstr "変換には以下の表を使用することができます:"

msgid "This table only applies if the code you are consuming is packaged as actual ES6+ code. If the code is packaged as CommonJS instead the `:default` may not apply. See the section below for more info."
msgstr "このテーブルは、消費するコードが実際のES6+コードとしてパッケージ化されている場合にのみ適用されます。コードがCommonJSとしてパッケージ化されている場合 `:default` は適用されない場合があります。詳細は以下のセクションを参照してください。"

msgid "ES6 Import to CLJS Require"
msgstr ""

msgid "ES6 Import"
msgstr ""

msgid "CLJS Require"
msgstr ""

msgid "`import defaultExport from \"module-name\";`"
msgstr ""

msgid "`(:require [\"module-name\" :default defaultExport])`"
msgstr ""

msgid "`import * as name from \"module-name\";`"
msgstr ""

msgid "`(:require [\"module-name\" :as name])`"
msgstr ""

msgid "`import { export } from \"module-name\";`"
msgstr ""

msgid "`(:require [\"module-name\" :refer (export)])`"
msgstr ""

msgid "`import { export as alias } from \"module-name\";`"
msgstr ""

msgid "`(:require [\"module-name\" :rename {export alias}])`"
msgstr ""

msgid "`import { export1 , export2 } from \"module-name\";`"
msgstr ""

msgid "`(:require [\"module-name\" :refer (export1 export2)])`"
msgstr ""

msgid "`import { export1 , export2 as alias2 , [...] } from \"module-name\";`"
msgstr ""

msgid "`(:require [\"module-name\" :refer (export1) :rename {export2 alias2}])`"
msgstr ""

msgid "`import defaultExport, { export [ , [...] ] } from \"module-name\";`"
msgstr ""

msgid "`(:require [\"module-name\" :refer (export) :default defaultExport])`"
msgstr ""

msgid "`import defaultExport, * as name from \"module-name\";`"
msgstr ""

msgid "`(:require [\"module-name\" :as name :default defaultExport])`"
msgstr ""

msgid "`import \"module-name\";`"
msgstr ""

msgid "`(:require [\"module-name\"])`"
msgstr ""

msgid "Notice that previously we were stuck using bundled code which included a lot of code we didn’t actually need. Now we're in a better situation: Some libraries are also packaged in ways that allow you to include only the parts you need, leading to much less code in your final build."
msgstr "以前は、実際には必要のないコードがたくさん含まれているバンドルコードを使用していたことに注意してください。今では、より良い状況になっています。ライブラリの中には、必要な部分だけを含めることができるようにパッケージ化されているものもあり、最終的なビルドのコード数を大幅に減らすことができます。"

msgid "`react-virtualized` is a great example:"
msgstr "`react-virtualized` は素晴らしい例です:"

msgid ""
"// You can import any component you want as a named export from 'react-virtualized', eg\n"
"import { Column, Table } from 'react-virtualized'\n"
"\n"
"// But if you only use a few react-virtualized components,\n"
"// And you're concerned about increasing your application's bundle size,\n"
"// You can directly import only the components you need, like so:\n"
"import AutoSizer from 'react-virtualized/dist/commonjs/AutoSizer'\n"
"import List from 'react-virtualized/dist/commonjs/List'"
msgstr ""
"// react-virtualized' から任意のコンポーネントを名前付きエクスポートとしてインポートすることができます。 例：\n"
"import { Column, Table } from 'react-virtualized'\n"
" \n"
"// しかし、いくつかの react-virtualized コンポーネントだけを使用していて、\n"
"// アプリケーションのバンドルサイズが大きくなるのが気になる場合は、\n"
"// 以下のように必要なコンポーネントだけを直接インポートすることができます。\n"
"import AutoSizer from 'react-virtualized/dist/commonjs/AutoSizer'\n"
"import List from 'react-virtualized/dist/commonjs/List'"

msgid "With our improved support we we can easily translate this to:"
msgstr "私たちのサポートが向上したことで、私たちはこれを簡単に変換することができます。"

msgid ""
"(ns my-ns\n"
"  ;; all\n"
"  (:require [\"react-virtualized\" :refer (Column Table)])\n"
"  ;; OR one by one\n"
"  (:require [\"react-virtualized/dist/commonjs/AutoSizer\" :default virtual-auto-sizer]\n"
"            [\"react-virtualized/dist/commonjs/List\" :default virtual-list]))"
msgstr ""
"(ns my-ns\n"
"  ;; 全て\n"
"  (:require [\"react-virtualized\" :refer (Column Table)])\n"
"  ;; または1つずつ\n"
"  (:require [\"react-virtualized/dist/commonjs/AutoSizer\" :default virtual-auto-sizer]\n"
"            [\"react-virtualized/dist/commonjs/List\" :default virtual-list]))"

msgid "About :default Exports"
msgstr ""

msgid "The `:default` option is currently only available in `shadow-cljs`, you can https://dev.clojure.org/jira/browse/CLJS-2376[vote here] to hopefully make it standard. You can always use `:as alias` and then call `alias/default` if you prefer to stay compatible with standard CLJS in the meantime."
msgstr "オプション `:default` は現在のところ `shadow-cljs` でしか利用できませんが、 https://dev.clojure.org/jira/browse/CLJS-2376[ここに投票する] で標準化できることを願っています(訳注：現在は投票を受け付けていません)。標準のCLJSとの互換性を保ちたいのであれば `:as alias` を使って `alias/default` を呼び出すこともできます。"

msgid "Default exports are a new addition in ECMAScript Modules and do not exist in CommonJS code. Sometimes you will see examples of `import Foo from \"something\"` when the code is actually CommonJS code. In theses cases `(:require [\"something\" :default Foo])` will not work and `(:require [\"something\" :as Foo])` must be used instead."
msgstr "デフォルトのエクスポートは ECMAScript モジュールに新たに追加されたもので、CommonJS コードには存在しません。CommonJSのコードの場合 `import Foo from \"something\"\"` の例を見かけることがあります。その場合は `(:require [\"something\" :default Foo])` は動作せず、代わりに `(:require [\"something\" :as Foo])` を使用しなければなりません。"

msgid "If a `:require` does not seem to work properly it is recommended to try looking at it in the REPL."
msgstr "もし `:require` が正しく動作しないようであれば、REPL で見てみることをお勧めします。"

msgid ""
"$ shadow-cljs browser-repl (or node-repl)\n"
"...\n"
"[1:1]~cljs.user=> (require '[\"react-tooltip\" :as x])\n"
"nil\n"
"[1:1]~cljs.user=> x\n"
"#object[e]\n"
"[1:1]~cljs.user=> (goog/typeOf x)\n"
"\"function\"\n"
"[1:1]~cljs.user=> (js/console.dir x)\n"
"nil"
msgstr ""

msgid "Since printing arbitrary JS objects is not always useful (as seen above) you can use `(js/console.dir x)` instead to get a more useful reprensentation in the browser console. `goog/typeOf` may also be useful at times. Since the above example shows `\"function\"` using `:default` would not work since `:default` basically is just syntax sugar for `x/default`."
msgstr "任意のJSオブジェクトを表示することが必ずしも有用とは限らないので(上で見たように)、代わりに `(js/console.dir x)` を使用すると、ブラウザコンソールでより有用な再表示を得ることができます。また `goog/typeOf` も有用な場合があります。上の例では `:default` は基本的には `x/default` の文法上の糖質に過ぎないので `:default` を使ってもうまくいかないでしょう。"

msgid "Package Provider"
msgstr ""

msgid "`shadow-cljs` supports several different ways to include `npm` packages into your build. They are configurable via the `:js-options :js-provider` setting. Each `:target` usually sets the one appropriate for your build most often you won't need to touch this setting."
msgstr "`shadow-cljs` は、ビルドに `npm` パッケージを含めるためのいくつかの異なる方法をサポートしています。これらは `:js-options :js-provider` 設定で設定できます。各 `:target` は通常、ビルドに適したものを設定しますが、ほとんどの場合、この設定に触れる必要はありません。"

msgid "Currently there are 3 supported JS Providers:"
msgstr "現在サポートされているJSプロバイダは3つあります:"

msgid "`:require`"
msgstr ""

msgid "Maps directly to the JS `require(\"thing\")` function call. It is the default for all `node.js` targets since it can resolve `require` natively at runtime. The included JS is not processed in any way."
msgstr "JSの `require(\"thing\")` 関数呼び出しに直接マップします。これはすべての `node.js` ターゲットのデフォルトで、実行時にネイティブに `require` を解決することができます。インクルードされたJSは何も処理されません。"

msgid "`:shadow`"
msgstr ""

msgid "Resolves the JS via `node_modules` and includes a minified version of each referenced file in the build. It is the default for the `:browser` target. `node_modules` sources do not go through `:advanced` compilation."
msgstr "`node_modules` 経由でJSを解決し、ビルド中に参照された各ファイルの修正版を含みます。これは `:browser` ターゲットのデフォルトです。 `node_modules` のソースは `:advanced` のコンパイルを通過しません。"

msgid "`:closure`"
msgstr ""

msgid "Resolves similarly to `:shadow` but attempts to process all included files via the Closure Compiler CommonJS/ES6 rewrite facilities. They will also be processed via `:advanced` compilation."
msgstr "`:shadow` と同様に解決しますが、すべてのインクルードされたファイルをClosure Compiler CommonJS/ES6の書き換え機能を使って処理しようとします。これらのファイルは `:advanced` コンパイルによっても処理されます。"

msgid "<code>:shadow</code> vs <code>:closure</code>"
msgstr "`:shadow` vs `:closure`"

msgid "Ideally we want to use `:closure` as our primary JS Provider since that will run the entire application through `:advanced` giving us the most optimized output. In practice however lots of code available via `npm` is not compatible with the aggressive optimizations that `:advanced` compilation does. They either fail to compile at all or expose subtle bugs at runtime that are very hard to identify."
msgstr "理想的には `:closure` をプライマリの JS プロバイダとして使いたいものです。しかし実際には `npm` で利用できるコードの多くは `:advanced` のコンパイルが行う積極的な最適化とは互換性がありません。これらのコードはコンパイルに全く失敗するか、実行時に識別するのが非常に困難な微妙なバグを露呈します。"

msgid "`:shadow` is sort of a stopgap solution that only processes code via `:simple` and achieves much more reliable support while still getting reasonably optimized code. The output is comparable (or often better) to what other tools like `webpack` generate."
msgstr "`:shadow` は `:simple` を経由してコードを処理するだけで、より信頼性の高いサポートを実現しつつ、合理的に最適化されたコードを得ることができるその場限りの解決方法のようなものです。出力は `webpack` のような他のツールが生成するものに匹敵します (あるいはそれよりも優れていることが多い)。"

msgid "Until support in Closure gets more reliable `:shadow` is the recommend JS Provider for `:browser` builds."
msgstr "Closureのサポートがより信頼性の高いものになるまでは `:shadow` が `:browser` ビルドの推奨JSプロバイダです。"

msgid "Example config for using <code>:closure</code> in a <code>:browser</code> build."
msgstr "`:browser` ビルドで `:closure` を使うための設定例。"

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {:target :browser\n"
"   ...\n"
"   :js-options {:js-provider :closure}\n"
"   }}}"
msgstr ""

msgid "Resolving Packages"
msgstr ""

msgid "By default `shadow-cljs` will resolve all `(:require [\"thing\" :as x])` requires following the `npm` convention. This means it will look at `<project>/node_modules/thing/package.json` and follow the code from there. To customize how this works `shadow-cljs` exposes a `:resolve` config option that lets you override how things are resolved."
msgstr "デフォルトでは `shadow-cljs` は `(:require [\" thing\" :as x])` 要求をすべて `npm` の規約に従って解決します。つまり `<project>/node_modules/thing/package.json` を見て、そこからコードを辿ります。この動作をカスタマイズするために `shadow-cljs` は `:resolve` という設定オプションを公開しています。"

msgid "Using a CDN"
msgstr ""

msgid "Say you already have React included in your page via a CDN. You could just start using `js/React` again but we stopped doing that for a good reason. Instead you can continue to use `(:require [\"react\" :as react])` but configure how \"react\" resolves!"
msgstr "CDN経由で既にReactがページに含まれているとします。あなたは再び `js/React` を使い始めることができますが、私たちは正当な理由のためにそれをするのをやめました。代わりに `(:require [\"react\" :as react])` を使い続けることができますが、&#34;react&#34; の解決方法を設定してください!"

msgid "Here is a sample `shadow-cljs.edn` config for such a build:"
msgstr "以下はそのようなビルドのための `shadow-cljs.edn` の設定例です:"

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {:target :browser\n"
"   ...\n"
"   :js-options\n"
"   {:resolve {\"react\" {:target :global\n"
"                       :global \"React\"}}}}\n"
"\n"
"  :server\n"
"  {:target :node-script\n"
"   ...}}}"
msgstr ""

msgid "The `:app` build will now use the global `React` instance while the `:server` build continues using the \"react\" npm package! No need to fiddle with the code to make this work."
msgstr "`:app` のビルドではグローバルな `React` インスタンスを使用しますが `:server` のビルドでは &#34;react&#34; npm パッケージを使用してビルドを継続します。これを動作させるためにコードをいじる必要はありません。"

msgid "Redirecting “require”"
msgstr ""

msgid "Sometimes you wan't more control over which `npm` package is actually used depending on your build. You can \"redirect\" certain requires from your build config without changing the code. This is often useful if you either don't have access to the sources using such packages or you just want to change it for one build."
msgstr "ビルドによっては、どの `npm` パッケージが実際に使用されるかをコントロールしたくないこともあるでしょう。コードを変更せずに、ビルド設定から特定の要求を &#34;redirect&#34; することができます。これは、そのようなパッケージを使っているソースにアクセスできない場合や、 あるビルドのためだけに変更したい場合に便利です。"

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {:target :browser\n"
"   ...\n"
"   :js-options\n"
"   {:resolve {\"react\" {:target :npm\n"
"                       :require \"preact-compat\"}}}"
msgstr ""

msgid "Limitations"
msgstr ""

msgid "The `:shadow-js` and `:closure` have full control over `:resolve` and everything mentioned above works without any downsides. The `:js-provider :require` however is more limited. Only the initial require can be influenced since the standard `require` is in control after that. This means it is not possible to influence what a package might `require` internally. It is therefore not recommended to be used with targets that use `require` directly (eg. `:node-script`)."
msgstr "`:shadow-js` と `:closure` は `:resolve` を完全に制御することができます。しかし `:js-provider :require` はより制限されています。標準の `require` がその後を制御しているため、最初の `require` だけが影響を受けることができます。つまり、パッケージが内部的に `require` するものに影響を与えることはできないということです。したがって `require` を直接使用するターゲット (例えば `:node-script`) と一緒に使用することは推奨されません。"

msgid "Redirecting \"react\" to \"preact\""
msgstr ""

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {:target :node-script\n"
"   ...\n"
"   :js-options\n"
"   {:resolve {\"react\" {:target :npm\n"
"                       :require \"preact-compat\"}}}"
msgstr ""

msgid "Example use of react-table"
msgstr ""

msgid ""
"(ns my.app\n"
"  (:require\n"
"    [\"react-table\" :as rt]))"
msgstr ""

msgid "The above works fine in the Browser since every `\"react\"` require will be replaced, including the `\"react\"` require `\"react-table\"` has internally. For `:js-provider :require` however a `require(\"react-table\")` will be emitted and `node` will be in control how that is resolved. Meaning that it will resolve it to the standard `\"react\"` and not the `\"preact\"` we had configured."
msgstr "ブラウザ上では、すべての `\"react\"` requireが置き換えられ `\"react-table\"` が内部的に持っている `\"react\"` requireも置き換えられるので、上記の方法で問題なく動作します。しかし `:js-provider :require` の場合は `require(\"react-table\")` が発行され `node` はそれをどのように解決するかを制御します。つまり、設定した `\"preact\"` ではなく、標準の `\"react\"` に解決されます。"

msgid "Alternate Modules Directories"
msgstr ""

msgid "By default `shadow-cljs` will only look at the `<project-dir>/node_modules` directory when resolving JS packages. This can be configured via the `:js-package-dirs` option in `:js-options`. This can be applied globally or per build."
msgstr "デフォルトでは `shadow-cljs` は JS パッケージを解決する際に `<project-dir>/node_modules` ディレクトリのみを参照します。これは `:js-options` の `:js-package-dirs` オプションで設定できます。これは全体またはビルドごとに適用することができます。"

msgid "Relative paths will be resolved relative to the project root directory. Paths will be tried from left to right and the first matching package will be used."
msgstr "相対パスは、プロジェクトのルートディレクトリからの相対パスとして解決されます。パスは左から右へと試行され、最初にマッチしたパッケージが使用されます。"

msgid "Global config in <code>shadow-cljs.edn</code>"
msgstr "Global config in `shadow-cljs.edn`"

msgid ""
"{...\n"
" :js-options {:js-package-dirs [\"node_modules\" \"../node_modules\"]}\n"
" ...}"
msgstr ""

msgid "Config applied to single build"
msgstr ""

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {...\n"
"   :js-options {:js-package-dirs [\"node_modules\" \"../node_modules\"]}}}}"
msgstr ""

msgid "Dealing with .js Files"
msgstr ""

msgid "*DANGER: This feature is an experiment!* It is currently only supported in `shadow-cljs` and other CLJS tools will yell at you if you attempt to use it. Use at your own risk. The feature was initially rejected from CLJS core but I think it is useful and should not have been https://dev.clojure.org/jira/browse/CLJS-2061?focusedCommentId=46191&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-46191[dismissed] without further discussion."
msgstr "*危険: この機能は実験的なものです！* 現在のところ `shadow-cljs` でのみサポートされており、他の CLJS ツールが使用しようとすると怒鳴りつけてきます。使用は自己責任で行ってください。この機能は当初CLJSコアから却下されましたが、私は便利だと思っていますし、さらなる議論なしに https://dev.clojure.org/jira/browse/CLJS-2061?focusedCommentId=46191&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-46191[dismissed] にすべきではありませんでした。"

msgid "CLJS has an alternate https://clojurescript.org/guides/javascript-modules[implementation] which in turn is not supported by `shadow-cljs`. I found this implementation to be lacking in certain aspects so I opted for the different solution. Happy to discuss the pros/cons of both approaches though."
msgstr "CLJSには代替の https://clojurescript.org/guides/javascript-modules[実装] がありますが、これは `shadow-cljs` がサポートしていません。私はこの実装がある面で欠けていることを発見したので、別の解決策を選択しました。両方のアプローチの長所と短所を議論したいと思います。"

msgid "We covered how <<npm, npm>> packages are used but you may be working on a codebase that already has lots of plain JavaScript and you don't want to rewrite everything in ClojureScript just yet. `shadow-cljs` provides 100% full interop between JavaScript and ClojureScript. Which means your JS can use your CLJS and CLJS can use your JS."
msgstr "<<npm, npm>> パッケージがどのように使われるかを説明しましたが、すでにたくさんのプレーンなJavaScriptを持っているコードベースで作業しているかもしれませんし、まだClojureScriptですべてを書き換えたくないかもしれません。 `shadow-cljs` は、JavaScriptとClojureScriptの間で100%完全な相互運用を提供します。つまり、あなたのJSはCLJSを使用でき、CLJSはあなたのJSを使用できるということです。"

msgid "There are only a few conventions you need to follow in order for this to work reliably but chances are that you are already doing that anyways."
msgstr "これを確実に動作させるためには、いくつかの規則に従う必要がありますが、いずれにせよ、あなたはすでにそれを行っている可能性があります。"

msgid "Requiring JS"
msgstr ""

msgid "We already covered how `npm` packages are accessed by their name but on the classpath we access `.js` files by either a full path or relative to the current namespace."
msgstr "`npm` パッケージが名前でアクセスする方法はすでに説明しましたが、クラスパスではフルパスか現在の名前空間からの相対パスのいずれかで `.js` ファイルにアクセスします。"

msgid "Loading JS from the classpath"
msgstr ""

msgid ""
"(ns demo.app\n"
"  (:require\n"
"    [\"/some-library/components/foo\" :as foo]\n"
"    [\"./bar\" :as bar :refer (myComponent)]))"
msgstr ""

msgid "For string requires the extension `.js` will be added automatically but you can specify the extension if you prefer. Note that currently only `.js` is supported though."
msgstr "文字列が必要な場合、拡張子 `.js` は自動的に追加されますが、お好みで拡張子を指定することもできます。しかし、現在は `.js` のみがサポートされていることに注意してください。"

msgid "Absolute requires like `/some-library/components/foo` mean that the compiler will look for a `some-library/components/foo.js` on the classpath; unlike `node` which would attempt to load the file from the local filesystem. The same classpath rules apply so the file may either be in your `:source-paths` or in some third-party `.jar` library you are using."
msgstr "`/some-library/components/foo` のような絶対的な要求は、コンパイラがクラスパス上の `some-library/components/foo.js` を探すことを意味します。同じクラスパスルールが適用されるので、ファイルは `:source-paths` または使用しているサードパーティの `.jar` ライブラリにあるかもしれません。"

msgid "Relative requires are resolved by first looking at the current namespace and then resolving a relative path from that name. In the above example we are in `demo/app.cljs` to the `./bar` require resolves to `demo/bar.js`, so it is identical to `(:require [\"/demo/bar\"])`."
msgstr "相対パスは、まず現在の名前空間を見て、その名前からの相対パスを解決することで解決されます。上の例では `demo/app.cljs` から `./bar` の require は `demo/bar.js` に解決されるので `(:require [\"/demo/bar\")` と同じです。"

msgid "The files must not be physically located in the same directory. The lookup for the file appears on the classpath instead. This is unlike node which expects relative requires to always resolve to physical files."
msgstr "ファイルが物理的に同じディレクトリにあってはいけません。ファイルの検索は、代わりにクラスパス上に表示されます。これは、相対的な要求が常に物理的なファイルに解決することを期待しているnodeとは異なります。"

msgid "Example File Structure with Separate Paths"
msgstr "パスが分離されたファイル構造の例"

msgid ""
".\n"
"├── package.json\n"
"├── shadow-cljs.edn\n"
"└── src\n"
"    └── main\n"
"        └── demo\n"
"            └── app.cljs\n"
"    └── js\n"
"        └── demo\n"
"            └── bar.js"
msgstr ""

msgid "Language Support"
msgstr ""

msgid "It is expected that the classpath only contains JavaScript that can be consumed without any pre-processing by the Compiler. `npm` has a very similar convention."
msgstr "クラスパスには、コンパイラによる前処理なしで消費できるJavaScriptのみが含まれていることが期待されています。 `npm` にも非常に似たような規約があります。"

msgid "The Closure Compiler is used for processing all JavaScript found on the classpath using its `ECMASCRIPT_NEXT` language setting. What exactly this setting means is not well documented but it mostly represents the next generation JavaScript code which might not even be supported by most browsers yet. ES6 is very well supported as well as most ES8 features. Similarly to standard CLJS this will be compiled down to ES5 with polyfills when required."
msgstr "Closureコンパイラは `ECMASCRIPT_NEXT` 言語設定を使用してクラスパス上のすべてのJavaScriptを処理するために使用されます。この設定が何を意味するのかはよくわかっていませんが、ほとんどのブラウザではまだサポートされていないかもしれない次世代のJavaScriptコードを表しています。ES6はES8の機能と同様に非常によくサポートされています。標準のCLJSと同様に、必要に応じてポリフィルを使用してES5までコンパイルされます。"

msgid "Since the Closure Compiler is getting constant updates newer features will be available over time. Just don't expect to use the latest cutting edge preview features to be available immediately. Somewhat recent additions like `async/await` already work quite well."
msgstr "Closureコンパイラは常に更新されていますので、新しい機能は時間の経過とともに利用可能になります。ただ、最新の最先端のプレビュー機能をすぐに使えるようになるとは思っていません。最近追加された `async/await` のような機能はすでに十分に機能しています。"

msgid "The JS should be written using ES Module Syntax using `import` and `export`. JS files can include other JS files and reference CLJS code directly. They may also access `npm` packages directly with one caveat."
msgstr "JSは `import` や `export` を使ってESモジュール構文を使って記述する必要があります。JSファイルは他のJSファイルをインクルードしたり、CLJSコードを直接参照したりすることができます。また `npm` パッケージに直接アクセスすることもできますが、1つの注意点があります。"

msgid ""
"// regular JS require\n"
"import Foo, { something } from \"./other.js\";\n"
"\n"
"// npm require\n"
"import React from \"react\";\n"
"\n"
"// require CLJS or Closure Library JS\n"
"import cljs from \"goog:cljs.core\";\n"
"\n"
"export function inc(num) {\n"
"  return cljs.inc(1);\n"
"}"
msgstr ""

msgid "Due to strict checking of the Closure Compiler it is not possible to use the `import * as X from \"npm\";` syntax when requiring CLJS or npm code. It is fine to use when requiring other JS files."
msgstr "Closure Compilerのチェックが厳しいため、CLJSやnpmのコードが必要な場合は `import * as X from &#34;npm&#34;;` 構文を使うことができません。他のJSファイルが必要な場合は問題ありません。"

msgid "JavaScript Dialects"
msgstr ""

msgid "Since there are many popular JavaScript dialects (JSX, CoffeeScript, etc) that are not directly parsable by the Closure Compiler we need to pre-process them before putting them onto the classpath. https://babeljs.io/[babel] is commonly used in the JavaScript world so we are going to use `babel` to process `.jsx` files as an example here."
msgstr "多くの一般的なJavaScriptの方言(JSX、CoffeeScriptなど)はClosureコンパイラで直接解析できないので、クラスパスに置く前に前処理をする必要があります。 https://babeljs.io/[babel] はJavaScriptの世界で一般的に使われているので `.jsx` ファイルを処理するために `babel` を例に挙げてみます。"

msgid "Example shadow-cljs.edn Config"
msgstr ""

msgid ""
"{:source-paths\n"
" [\"src/main\"\n"
"  \"src/gen\"]\n"
" ...}"
msgstr ""

msgid "Example File Structure"
msgstr ""

msgid ""
".\n"
"├── package.json\n"
"├── shadow-cljs.edn\n"
"└── src\n"
"    └── main\n"
"        └── demo\n"
"            └── app.cljs\n"
"    └── js\n"
"        ├── .babelrc\n"
"        └── demo\n"
"            └── bar.jsx"
msgstr ""

msgid "Notice how `src/js` is not added to `:source-paths` which means it will not be on the classpath."
msgstr "`src/js` が `:source-paths` に追加されていないことに注目してください。"

msgid "src/js/demo/bar.jsx"
msgstr ""

msgid ""
"import React from \"react\";\n"
"\n"
"function myComponent() {\n"
"  return <h1>JSX!</h1>;\n"
"}\n"
"\n"
"export { myComponent };"
msgstr ""

msgid "We run https://babeljs.io/docs/usage/cli/[babel] to convert the files and write them to the configured `src/gen` directory. Which directory you use it up to you. I prefer `src/gen` for generated files."
msgstr "https://babeljs.io/docs/usage/cli/[babel] を実行してファイルを変換し、設定された `src/gen` ディレクトリに書き出します。どのディレクトリを使うかはあなた次第です。私は生成されたファイルは `src/gen` の方が好きです。"

msgid ""
"$ babel src/js --out-dir src/gen\n"
"# or during development\n"
"$ babel src/js --out-dir src/gen --watch"
msgstr ""

msgid "`babel` itself is configured via the `src/js/.babelrc`. See the official https://babeljs.io/docs/plugins/transform-react-jsx/[example for JSX]."
msgstr "`babel` 自体は `src/js/.babelrc` で設定します。公式の https://babeljs.io/docs/plugins/transform-react-jsx/[JSXの例] を参照してください。"

msgid "JSX minimal .babelrc"
msgstr ""

msgid ""
"{\n"
"  \"plugins\": [\"transform-react-jsx\"]\n"
"}"
msgstr ""

msgid "Once `babel` writes the `src/gen/demo/bar.js` it will be available to use via ClojureScript and will even be hot loaded just like your ClojureScript sources."
msgstr "一度 `babel` が `src/gen/demo/bar.js` を書けば、ClojureScript から利用可能になり、ClojureScript のソースと同じようにホットロードされるようになります。"

msgid "`shadow-cljs` currently does not provide any support for running those transformation steps. Please use the standard tools (eg. `babel`, `coffeescript`, etc.) directly until it does."
msgstr "現在 `shadow-cljs` はこれらの変換ステップを実行するためのサポートを提供していません。サポートされるまでは、標準的なツール (例えば `babel`, `coffeescript` など) を直接使用してください。"

msgid "Access CLJS from JS"
msgstr ""

msgid "The JS sources can access all your ClojureScript (and the Closure Library) directly by importing their namespaces with a `goog:` prefix which the Compiler will rewrite to expose the namespace as the default ES6 export."
msgstr "JSソースは名前空間 `goog:` を接頭辞でインポートすることで、すべてのClojureScript (とClosure Library)に直接アクセスすることができます。"

msgid ""
"import cljs, { keyword } from \"goog:cljs.core\";\n"
"\n"
"// construct {:foo \"hello world\"} in JS\n"
"cljs.array_map(keyword(\"foo\"), \"hello world\");"
msgstr ""

msgid "The `goog:` prefix currently only works for ES6 file. `require(\"goog:cljs.core\")` does not work."
msgstr "接頭辞 `goog:` は現在のところ ES6 ファイルでしか動作しません。`require(\"goog:cljs.core\")` は動作しません。"

msgid "Migrating cljsjs.*"
msgstr ""

msgid "CLJSJS is an effort to package Javascript libraries to be able to use them from within ClojureScript."
msgstr "CLJSJSは、Javascriptのライブラリをパッケージ化して、ClojureScript内から利用できるようにする取り組みです。"

msgid "Since `shadow-cljs` can access <<npm, npm packages>> directly we do not need to rely on re-packaged https://github.com/cljsjs/packages[CLJSJS] packages."
msgstr "`shadow-cljs` は <<npm, npm packages>> に直接アクセスできるので、再パッケージ化された https://github.com/cljsjs/packages[CLJSJS] パッケージに頼る必要はありません。"

msgid "However many CLJS libraries are still using CLJSJS packages and they would break with `shadow-cljs` since it doesn't support those anymore. It is however very easy to mimick those `cljsjs` namespaces since they are mostly build from `npm` packages anyways. It just requires one shim file that maps the `cljsjs.thing` back to its original `npm` package and exposes the expected global variable."
msgstr "しかし、多くのCLJSライブラリはまだCLJSJSパッケージを使っており `shadow-cljs` はもうサポートしていないので `shadow-cljs` では壊れてしまいます。しかし `cljsjs` 名前空間はほとんどが `npm` パッケージからビルドされているので `cljs` 名前空間を真似るのは非常に簡単です。 `cljsjs.thing` を元の `npm` パッケージにマップして、期待されるグローバル変数を公開する shim ファイルが必要です。"

msgid "For React this requires a file like `src/cljsjs/react.cljs`:"
msgstr "Reactの場合は `src/cljsjs/react.cljs` のようなファイルが必要です:"

msgid ""
"(ns cljsjs.react\n"
"  (:require [\"react\" :as react]\n"
"            [\"create-react-class\" :as crc]))"
msgstr ""

msgid ""
"(js/goog.object.set react \"createClass\" crc)\n"
"(js/goog.exportSymbol \"React\" react)"
msgstr ""

msgid "Since this would be tedious for everyone to do manually I created the https://github.com/thheller/shadow-cljsjs[`shadow-cljsjs`] library which provides just that. It does not include every package but I’ll keep adding them and contributions are very welcome as well."
msgstr "誰もが手動で行うのは面倒なので https://github.com/thheller/shadow-cljsjs[`shadow-cljsjs`] ライブラリを作成しました。これはすべてのパッケージを含んでいるわけではありませんが、私はそれらを追加し続けます。"

msgid "The `shadow-cljsjs` library only provides the shim files. You’ll still need to `npm install` the actual packages yourself."
msgstr "`shadow-cljsjs` ライブラリは shim ファイルのみを提供します。実際のパッケージを自分で `npm` インストールする必要があります。"

msgid "Why not use CLJSJS?"
msgstr ""

msgid "CLJSJS packages basically just take the package from `npm` and put them into a `.jar` and re-publish them via https://clojars.org[clojars]. As a bonus they often bundle Externs. The compiler otherwise does nothing with these files and only prepends them to the generated output."
msgstr "CLJSJSのパッケージは基本的に `npm` からパッケージを取り出して `.jar` に入れ、https://clojars.org[clojars] 経由で再公開するだけです。ボーナスとしてExternsがバンドルされていることが多いです。それ以外の場合、コンパイラはこれらのファイルには何もせず、生成された出力に前置きするだけです。"

msgid "This was very useful when we had no access to `npm` directly but has certain issues since not all packages are easily combined with others. A package might rely on `react` but instead of expressing this via `npm` https://github.com/cljsjs/packages/tree/master/material-ui[they] bundle their own `react`. If you are not careful you could end up including 2 different `react` versions in your build which may lead to very confusing errors or at the very least increase the build size substantially."
msgstr "これは `npm` に直接アクセスできなかったときに非常に便利でしたが、すべてのパッケージが他のパッケージと簡単に結合できるわけではないので、ある種の問題があります。あるパッケージは `react` に依存しているかもしれませんが、これを `npm` で表現する代わりに https://github.com/cljsjs/packages/tree/master/material-ui[彼ら] は独自の `react` をバンドルしています。注意を怠ると、ビルド中に 2 つの異なる `react` バージョンを含むことになり、非常に混乱を招くエラーを引き起こしたり、 少なくともビルドサイズが大幅に大きくなったりする可能性があります。"

msgid "Apart from that not every `npm` package is available via CLJSJS and keeping the package versions in sync requires manual work, which means packages are often out of date."
msgstr "また、すべての `npm` パッケージが CLJSJS で利用できるわけではなく、パッケージのバージョンを同期させるには手作業が必要で、パッケージが古くなっていることがよくあります。"

msgid "`shadow-cljs` does not support CLJSJS at all to avoid conflicts in your code. One library might attempt to use the \"old\" `cljsjs.react` while another uses the newer `(:require [\"react\"])` directly. This would again lead to 2 versions of `react` on your page again."
msgstr "`shadow-cljs` は CLJSJS を全くサポートしていません。あるライブラリは \"old\"の `cljsjs.react` を使おうとするかもしれないし、別のライブラリは新しい `(:require [\"react\"])` を直接使おうとするかもしれない。これはまた、あなたのページに2つのバージョンの `react` が再び現れることになるでしょう。"

msgid "So the only thing we are missing are the bundled Externs. In many instances these are not required due to improved <<infer-externs, externs inference>>. Often those Externs are generated using third-party tools which means they are not totally accurate anyways."
msgstr "つまり、足りないのはバンドルされているExternsだけです。多くの場合、これらは改良された <<infer-externs, externs推論>> のために必要とされていません。多くの場合、これらのExternsはサードパーティのツールを使って生成されます。"

msgid "Conclusion: Use <<npm, npm>> directly. Use <<infer-externs, :infer-externs auto>>."
msgstr "結論：<<npm, npm>>を直接使う。<<infer-externs, :infer-externs auto>>を使う。"

msgid "Generating Production Code&#8201;&#8212;&#8201;All Targets"
msgstr ""

msgid "Development mode always outputs individual files for each namespace so that they can be hot loaded in isolation. When you're ready to deploy code to a real server you want to run the Closure Compiler on it to generate a single minified result for each <<Modules, module>>."
msgstr "開発モードでは、各名前空間ごとに個別のファイルを出力します。実際のサーバにコードをデプロイする準備ができたら、Closure Compilerを実行して、各 <<Modules, module>> に対して単一の最小化された結果を生成したいと思います。"

msgid "By default the release mode output file should just be a drop-in replacements for the development mode file: there is no difference in the way you include them in your HTML. You may use <<NameHashing, filename hashing>> to improve caching characteristics on browser targets."
msgstr "デフォルトでは、リリースモードの出力ファイルは、開発モードのファイルの代わりにドロップインされるだけです。ブラウザターゲットのキャッシュ特性を改善するために <<NameHashing, filename hashing>> を使うことができます。"

msgid "Generating Minified Output"
msgstr ""

msgid "$ shadow-cljs release build-id"
msgstr ""

msgid "Release Configuration"
msgstr ""

msgid "Usually you won't need to add any extra configuration to create a release version for your build. The default config already captures everything necessary and should only require extra configuration if you want to override the defaults."
msgstr "通常、ビルド用のリリースバージョンを作成するために余分な設定を追加する必要はありません。デフォルトの設定には必要なものがすべて含まれているので、デフォルトを上書きしたい場合に追加の設定が必要になるだけです。"

msgid "Each `:target` already provides good defaults optimized for each platform so you'll have less to worry about."
msgstr "それぞれの `:target` には、それぞれのプラットフォームに最適化されたデフォルトが用意されているので、心配することは少なくなります。"

msgid "Optimizations"
msgstr ""

msgid "You can choose the optimization level using the `:compiler-options` section of the configuration:"
msgstr "最適化レベルは設定の `:compiler-options` セクションで選択できます。"

msgid "You do not usually need to set `:optimizations` since the `:target` already sets it to an appropriate level."
msgstr "通常は `:target` が適切なレベルに設定しているので `:optimizations` を設定する必要はありません。"

msgid "`:optimizations` only apply when using the `release` command. Development builds are never optimized by the Closure Compiler. Development builds are always set to `:none`."
msgstr "`:optimizations` は `release` コマンドを使用した場合にのみ適用されます。開発ビルドはClosureコンパイラによって最適化されることはありません。開発ビルドは常に `:none` に設定されています。"

msgid ""
"{...\n"
" :build\n"
"   {:build-id\n"
"     {...\n"
"      :compiler-options {:optimizations :simple}}}}"
msgstr ""

msgid "See the https://developers.google.com/closure/compiler/docs/compilation_levels[the Closure compiler's documentation] for more information on available optimization levels."
msgstr "利用可能な最適化レベルの詳細については https://developers.google.com/closure/compiler/docs/compilation_levels[Closureコンパイラのドキュメント] を参照してください。"

msgid "Release-Specific vs. Development Configuration"
msgstr ""

msgid "If you wish to have separate configuration values in a build when running a release build then you can override settings by including a `:dev` and/or `:release` section in the build section:"
msgstr "リリースビルドを実行する時にビルド中に別の設定値を設定したい場合は、ビルドセクションに `:dev` や `:release` セクションを含めることで設定を上書きすることができます。"

msgid "Example <code>shadow-cljs.edn</code> build config"
msgstr "Example `shadow-cljs.edn` build config"

msgid ""
"{:source-paths [\"src\"]\n"
" :dependencies []\n"
" :builds\n"
" {:app\n"
"  {:target :browser\n"
"   :output-dir \"public/js\"\n"
"   :asset-path \"/js\"\n"
"   :modules {:base {:entries [my.app.core]}}\n"
"\n"
"   ;; Here is some dev-specific config\n"
"   :dev {:compiler-options {:devcards true}}\n"
"\n"
"   ;; Here is some production config\n"
"   :release {:compiler-options {:optimizations :simple}}}}}"
msgstr ""

msgid "Externs"
msgstr ""

msgid "Since we want builds to be fully optimized by the Closure Compiler `:advanced` compilation we need to deal with https://developers.google.com/closure/compiler/docs/api-tutorial3[Externs]. Externs represent pieces of code that are not included when doing `:advanced` compilation. `:advanced` works by doing whole program optimizations but some code we just won't be able to include so Externs inform the Compiler about this code. Without Externs the Compiler may rename or remove some code that it shouldn't."
msgstr "Closure Compilerの `:advanced` コンパイルでビルドを完全に最適化したいため https://developers.google.com/closure/compiler/docs/api-tutorial3[Externs] を扱う必要があります。 Externsは `:advanced` コンパイル時に含めないコードを表します。 `:advanced` はプログラム全体の最適化を行うことで動作しますが、その中には含めたくないコードもあるため、Externsはそのコードをコンパイラーに通知します。Externsを使用しないとコンパイラはコードの名前を変更したり削除したりすることがあります。"

msgid "Typically all JS Dependencies are foreign and won't be passed through `:advanced` and thus require Externs."
msgstr "典型的には、すべてのJS依存関係は外部のものであり `:advanced` には渡せないため、Externsが必要です。"

msgid "Externs are only required for `:advanced`, they are not required in `:simple` mode."
msgstr "エクスターンが必要なのは `:advanced` の場合のみであり `:simple` モードでは必要ありません。"

msgid "Externs Inference"
msgstr ""

msgid "To help deal with Externs the `shadow-cljs` compiler provides enhanced externs inference which can be enabled by setting `:infer-externs :auto` for your build."
msgstr "Externs扱うために `shadow-cljs` コンパイラは拡張externs推論を提供しています、これを有効にするにはビルドに `:infer-externs :auto` を設定する必要があります。"

msgid "Example Config"
msgstr ""

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {:target :browser\n"
"   ...\n"
"   :compiler-options {:infer-externs :auto}\n"
"   }}}}"
msgstr ""

msgid "With `:auto` the compiler will perform additional checks at compile time for your files only. It won't warn you about possible externs issues in library code. `:all` will enable it for everthing but be aware that you may get a lot of warnings."
msgstr "`:auto` を使うと、コンパイラはコンパイル時にファイルに対してのみ追加のチェックを行います。ライブラリコードのエクスターンの問題については警告しません。 `:all` を使うとすべての場合に有効になりますが、大量の警告を受ける可能性があることに注意してください。"

msgid "When enabled you'll get warnings whenever the Compiler cannot figure out whether you are working with JS or CLJS code."
msgstr "この機能を有効にするとコンパイラは、JS と CLJS のどちらのコードを使用しているかを判別できず、警告を表示します。"

msgid "Example Code"
msgstr ""

msgid ""
"(defn wrap-baz [x]\n"
"  (.baz x))"
msgstr ""

msgid "Example Warning"
msgstr ""

msgid ""
"------ WARNING #1 --------------------------------------------------------------\n"
" File: ~/project/src/demo/thing.cljs:23:3\n"
"--------------------------------------------------------------------------------\n"
"  21 |\n"
"  22 | (defn wrap-baz [x]\n"
"  23 |   (.baz x))\n"
"---------^----------------------------------------------------------------------\n"
" Cannot infer target type in expression (. x baz)\n"
"--------------------------------------------------------------------------------"
msgstr ""

msgid "In `:advanced` the compiler will be renaming `.baz` to something \"shorter\" and Externs inform the Compiler that this is an external property that should not be renamed."
msgstr "コンパイラは `:advanced` において `.baz` の名前をもっと短いものに変更します、 Externsはこれがリネームすべきではない外部プロパティであることをコンパイラに伝えます。"

msgid "`shadow-cljs` can generate the appropriate externs if you add a typehint to the object you are performing native interop on."
msgstr "`shadow-cljs` は、ネイティブInteropを実行するオブジェクトにタイプヒントを追加すれば、適切なエクスターンを生成することができます。"

msgid "Type-hint to help externs generation"
msgstr ""

msgid ""
"(defn wrap-baz [x]\n"
"  (.baz ^js x))"
msgstr ""

msgid "The `^js` typehint will cause the compiler to generate proper externs and the warning will go away. The property is now safe from renaming."
msgstr "この `^js` 型ヒントは、コンパイラが適切なエクスターンを生成するようになり、警告はなくなります。これでこのプロパティはリネームされても安全になりました。"

msgid "Multiple interop calls"
msgstr ""

msgid ""
"(defn wrap-baz [x]\n"
"  (.foo ^js x)\n"
"  (.baz ^js x))"
msgstr ""

msgid "It can get tedious to annotate every single interop call so you can annotate the variable binding itself. It will be used in the entire scope for this variable. Externs for both calls will still be generated."
msgstr "interop呼び出しのたびにアノテーションをつけるのは面倒になるので、変数のバインディング自体にアノテーションをつけることができます。この変数のスコープ全体で使用されます。両方の呼び出しのためのエクスターンはまだ生成されます。"

msgid "Annotate <code>x</code> directly"
msgstr "Annotate `x` directly"

msgid ""
"(defn wrap-baz [^js x]\n"
"  (.foo x)\n"
"  (.baz x))"
msgstr ""

msgid "Don't annotate everything with `^js`. Sometimes you may be doing interop on CLJS or ClosureJS objects. Those do not require externs. If you are certain you are working with a CLJS Object prefer using the `^clj` hint.  It is not the end of the world when using `^js` incorrectly but it may affect some optimizations when a variable is not renamed when it could be."
msgstr "すべてのものに `^js` をアノテーションしてはいけません。CLJSやClosureJSオブジェクトのinteropを行うことがあるかもしれません。これらはエクスターンを必要としません。CLJSオブジェクトで作業していることが確実ならば `^clj` ヒントを使うことをお勧めします。 間違って `^js` を使用しても世界の終わりではありませんが、変数がリネームされず最適化に影響を与える可能性があります。"

msgid "Calls on globals do not require a typehint when using direct `js/` calls."
msgstr "直接的な `js/` 呼び出しを使用する場合、グローバルの呼び出しはタイプヒントを必要としません。"

msgid "No hint required, externs inferred automatically"
msgstr "ヒントは不要で、自動的にexternが推測されます"

msgid "(js/Some.Thing.coolFunction)"
msgstr ""

msgid "Calls on `:require` bindings are also inferred automatically."
msgstr "`:require` バインディングの呼び出しも自動的に推測されます。"

msgid "No hint required for <code>:as</code> and <code>:refer</code> bindings"
msgstr "`:as` および `:refer` バインディングにはヒントは必要ありません。"

msgid ""
"(ns my.app\n"
"  (:require [\"react\" :as react :refer (createElement)]))\n"
"\n"
"(react/createElement \"div\" nil \"hello world\")\n"
"(createElement \"div\" nil \"hello world\")"
msgstr ""

msgid "Manual Externs"
msgstr ""

msgid "Some libraries provide Externs as separate `.js` files. You can include them into your build via the `:externs` compiler options."
msgstr "いくつかのライブラリでは、Externsを別の `.js` ファイルとして提供しています。コンパイラの `:externs` オプションを使ってビルドに含めることができます。"

msgid "Manual Externs Config"
msgstr ""

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {:target :browser\n"
"   ...\n"
"   :compiler-options {:externs [\"path/to/externs.js\" ...]}\n"
"   }}}"
msgstr ""

msgid "The compiler looks for files relative to the project root first. It will also attempt to load them from the classpath if no file is found."
msgstr "コンパイラは最初にプロジェクト・ルートからの相対的なファイルを探します。また、ファイルが見つからない場合は、クラスパスからの読み込みを試みます。"

msgid "Simplified Externs"
msgstr ""

msgid "Writing Externs by hand can be challenging and `shadow-cljs` provides a way to write a more convenient way to write them. In combination with `shadow-cljs check <your-build>` you can quickly add the missing Externs."
msgstr "Externsを手書きで書くのは難しいかもしれませんが `shadow-cljs` はより便利な書き方を提供してくれます。 `shadow-cljs check <your-build>` と組み合わせれば、不足しているエクスターンを素早く追加することができます。"

msgid "Start by creating a `externs/<your-build>.txt`, so build `:app` would be `externs/app.txt`. In that file each line should be one word specifying a JS property that should not be renamed. Global variables should be prefixed by `global:`"
msgstr "まず `externs/<your-build>.txt` を作成することから始めます。このファイルの各行には名前を変更してはいけないJSプロパティを1つずつ記述します。グローバル変数の前には `global:` を付けてください。"

msgid "Example externs/app.txt"
msgstr ""

msgid ""
"# this is a comment\n"
"foo\n"
"bar\n"
"global:SomeGlobalVariable"
msgstr ""

msgid "In this example the compiler will stop renaming `something.foo()`, `something.bar()`."
msgstr "この例ではコンパイラは `something.foo()`, `something.bar()` のリネームを停止します。"

msgid "Code Stripping"
msgstr ""

msgid "The Closure Compiler supports removing unwanted code by name. This allows removing code that normal dead-code removal can't or won't remove. This is quite dangerous as it can remove code you actually care about but it can remove a lot of dev only code easily. It is grouped into 4 separate options of which pretty much only `:strip-type-prefixes` is relevant to ClojureScript but other may be useful as well."
msgstr "Closureコンパイラは、不要なコードを名前で削除することをサポートしています。これにより、通常のデッドコード除去では除去できないコードを除去することができます。これは非常に危険なことですが、実際に気になるコードを削除することができますが、多くの開発者専用のコードを簡単に削除することができます。これは4つの別々のオプションにグループ化されていて、そのうちのほとんどは `:strip-type-prefixes` だけがClojureScriptに関連していますが、他のオプションも同様に有用かもしれません。"

msgid "Example removing all uses of <code>cljs.pprint</code>"
msgstr "`cljs.pprint` のすべての利用を削除する例"

msgid ""
"{...\n"
" :builds\n"
" {:app\n"
"  {:target :browser\n"
"   ...\n"
"   :compiler-options {:strip-type-prefixes #{\"cljs.pprint\"}\n"
"   }}}"
msgstr ""

msgid "Each of these options is specified as a Set of Strings. Please note that all the names specified here are JS names so certain CLJS names must be munged. `my-lib.core` becomes `my_lib.core`."
msgstr "これらのオプションはそれぞれ文字列のセットとして指定されます。ここで指定された名前はすべてJS名なので、CLJS名を指定する必要があることに注意してください。 `my-lib.core` は `my_lib.core` になります。"

msgid "`:strip-types`"
msgstr ""

msgid "Allows removing deftype/defrecord declarations or uses. `#{\"my.ns.FooBar}` removes `(defrecord FooBar [])`."
msgstr "deftype/defrecordの宣言や使用法を削除することができます `#{&#34;my.ns.FooBar&#34;}` は `(defrecord FooBar [])` を削除します。"

msgid "`:strip-type-prefixes`"
msgstr ""

msgid "Removes everything starting with any of the given Prefixes. Allows removing entire CLJS namespaces."
msgstr "与えられた接頭辞のいずれかで始まるすべてのものを削除します。CLJSの名前空間全体を削除することができます。"

msgid "`:strip-name-prefixes`"
msgstr ""

msgid "Allows removing properties by prefix. `#{\"log\"}` removes `this.logX` or `(defn log-me [...])`"
msgstr "接頭辞によるプロパティの削除を許可します。このように `#{\"log\"}` は `this.logX` または `(defn log-me [...])` を削除します。"

msgid "`:strip-name-suffixes`"
msgstr ""

msgid "Allows removing properties by suffix. `#{\"log\"}` removes `this.myLog` or `(defn my-log [...])`"
msgstr "サフィックスによるプロパティの削除が可能です `#{&#34;log\"}` は `this.myLog` または `(defn my-log [...])` を削除します。"

msgid "*DANGER: Be careful with these options. They apply to your entire build and may remove code you actually need. You may accidentally remove code in libraries not written by you. Always consider other options before using this.*"
msgstr "*危険: これらのオプションには注意してください。これらのオプションはビルド全体に適用され、実際に必要なコードを削除する可能性があります。あなたが書いたものではないライブラリのコードを誤って削除してしまうかもしれません。これを使用する前には、常に他のオプションを検討してください。*"

msgid "Build Report"
msgstr ""

msgid "`shadow-cljs` can generate a detailed report for your `release` builds which includes a detailed breakdown of the included sources and how much they each contributed to the overall size."
msgstr "`shadow-cljs` は `release` ビルドの詳細なレポートを生成することができ、含まれるソースの詳細な内訳と、それらが全体のサイズにどれだけ貢献したかを含みます。"

msgid "A sample report can be found https://code.thheller.com/demos/build-report/huge.html[here]."
msgstr "レポートのサンプルは https://code.thheller.com/demos/build-report/huge.html[こちら] をご覧ください。"

msgid ""
"$ npx shadow-cljs run shadow.cljs.build-report <build-id> <path/to/output.html>\n"
"# example\n"
"$ npx shadow-cljs run shadow.cljs.build-report app report.html"
msgstr ""

msgid "The above example will generate a `report.html` in the project directory for the `:app` build."
msgstr "上記の例では `:app` ビルド用の `report.html` がプロジェクトディレクトリに生成されます。"

msgid "The generated `report.html` is entirely self-contained and includes all the required data/js/css. No other external sources are required."
msgstr "生成される `report.html` は完全に自己完結型で、必要なデータ/js/cssをすべて含んでいます。他の外部ソースは必要ありません。"

msgid "Editor Integration"
msgstr ""

msgid "Cursive"
msgstr ""

msgid "Cursive does not currently support resolving dependencies via `shadow-cljs.edn`. You can run `shadow-cljs pom` to generate a `pom.xml` and import that using the IntelliJ."
msgstr "Cursiveは現在のところ `shadow-cljs.edn` による依存関係の解決をサポートしていません。 `shadow-cljs pom` を実行して `pom.xml` を生成し、IntelliJを使ってそれをインポートすることができます。"

msgid "$ shadow-cljs pom"
msgstr ""

msgid "Then in Cursive *File -> New -> Project from Existing Sources* then select the generated `pom.xml` in the project directory."
msgstr "次にCursiveから *File -> New -> Project from Existing Sources* で、プロジェクトディレクトリ内の生成された `pom.xml` を選択します。"

msgid "You need to have the \"Build Tools\" -> \"Maven\" Plugin enabled for this. It might not be enabled by default."
msgstr "このためには、&#34;Build Tools&#34; -> \"Maven\" Pluginが有効になっている必要があります。デフォルトでは有効になっていないかもしれません。"

msgid "Alternatively you can create a dummy `project.clj` or use the full <<Leiningen, Leiningen integration>>."
msgstr "あるいはダミーの `project.clj` を作成するか、完全な <<Leiningen, Leiningen integration>> を使うことができます。"

msgid ""
"(defproject your/project \"0.0.0\"\n"
"  :dependencies\n"
"  [[thheller/shadow-cljs \"X.Y.Z\"]]\n"
"\n"
"  :source-paths\n"
"  [\"src\"])"
msgstr ""

msgid "You can run `npx shadow-cljs server` inside the Terminal provided by IntelliJ and use `Clojure REPL -> Remote` Run Configuration to connect to the provided <<nREPL, nREPL server>>. Just select the \"Use port from nREPL file\" option in Cursive Clojure REPL -> Remote or configure a fixed nREPL port if you prefer."
msgstr "IntelliJが提供するターミナルの中で `npx shadow-cljs server` を実行し、 `Clojure REPL -> Remote` Run Configuration を使って、提供された <<nREPL, nREPL server>> に接続することができます。Cursive Clojure REPL -> Remoteで &#34;Use port from nREPL file &#34;オプションを選択するか、固定のnREPLポートを設定してください。"

msgid "Note that the Cursive REPL when first connected always starts out as a CLJ REPL. You can switch it to CLJS by calling `(shadow/repl :your-build-id)`. This will automatically switch the Cursive option as well. You can type `:cljs/quit` to drop back down to the CLJ REPL."
msgstr "最初に接続されたときのCursive REPLは常にCLJ REPLとして始まることに注意してください。 `(shadow/repl :your-build-id)` を呼び出すことでCLJSに切り替えることができます。これによりCursiveオプションも自動的に切り替わります。CLJ REPLに戻るには `:cljs/quit` と入力してください。"

msgid "You cannot switch from CLJ->CLJS via the Cursive select box. Make sure you use the call above to switch."
msgstr "CLJ->CLJSからCursiveセレクトボックスを使って切り替えることはできません。必ず上記の呼び出しを使って切り替えてください。"

msgid "Emacs / CIDER"
msgstr ""

msgid "This section is written for CIDER version 0.20.0 and above. Ensure your Emacs environment has this version of the `cider` package or later. Refer to the link:https://docs.cider.mx[CIDER documentation] for full installation details."
msgstr "このセクションは CIDER バージョン 0.20.0 以降向けに書かれています。お使いのEmacs環境にこのバージョンの `cider` パッケージ以降があることを確認してください。インストールの詳細については https://docs.cider.mx[CIDER documentation] を参照してください。"

msgid "Launch the ClojureScript REPL"
msgstr "ClojureScript REPLを起動します。"

msgid "Launch the nREPL and a ClojureScript REPL."
msgstr "nREPLとClojureScript REPLを起動します。"

msgid "M-x cider-jack-in-cljs"
msgstr ""

msgid "CIDER will prompt you for the type of ClojureScript REPL:"
msgstr "CIDERはClojureScript REPLの種類を尋ねてきます:"

msgid "Select ClojureScript REPL type:"
msgstr "ClojureScriptのREPLタイプを選択します:"

msgid "Enter `shadow`."
msgstr "`shadow` と入力します。"

msgid "Select shadow-cljs build:"
msgstr "shadow-cljs のビルドを選択します:"

msgid "Enter the name of your build target, for example, `app`."
msgstr "ビルド対象の名前を入力してください(例: `app`):"

msgid "Emacs should now open a new nREPL connection to the `shadow-cljs` server of its sibling, bootstrapping into a ClojureScript REPL environment:"
msgstr "Emacs はこれで、兄弟関係の `shadow-cljs` サーバへの新しい nREPL 接続を開き、ClojureScript の REPL 環境にブートストラップすることができるようになりました。"

msgid ""
"shadow.user> To quit, type: :cljs/quit\n"
"[:selected :app]\n"
"cljs.repl>"
msgstr ""

msgid "You should now be able to eval ClojureScript, jump to the definitions of vars (with `cider-find-var`) and much more."
msgstr "これで、ClojureScriptのevalやvarsの定義へのジャンプ（`cider-find-var` で）などができるようになりました。"

msgid "For example, to display an alert in the browser:"
msgstr "例えば、ブラウザにアラートを表示させたり。"

msgid "cljs.repl> (js/alert \"Jurassic Park!\")"
msgstr ""

msgid "Simplify startup with dir-local"
msgstr "dir-localで起動を簡素化"

msgid "You can simplify startup flow by a creating a `.dir-locals.el` file at project root."
msgstr "プロジェクトのルートに `.dir-locals.el` ファイルを作成することで、起動の流れを簡単にすることができます。"

msgid ""
"((nil . ((cider-default-cljs-repl . shadow)\n"
"\t (cider-shadow-default-options . \"<your-build-name-here>\"))))"
msgstr ""

msgid "Proto REPL (Atom)"
msgstr ""

msgid "Proto REPL is mostly intended for Clojure development so most features do not work for ClojureScript. It is however possible to use it for simple evals."
msgstr "Proto REPLはほとんどがClojure開発のためのものなので、ほとんどの機能はClojureScriptでは動作しません。しかし、単純な検証に使用することは可能です。"

msgid "You need to setup a couple of things to get it working."
msgstr "設定が必要なので"

msgid "1)  Create a `user.clj` in on of your `:source-paths`."
msgstr "1) `:source-paths` の中に `user.clj` を作成する。"

msgid ""
" (ns user)\n"
"\n"
" (defn reset [])"
msgstr ""

msgid "The file must define the `user/reset` fn since Proto REPL will call that when connecting. If `user/reset` is not found it will call `tools.namespace` which destroys the running `shadow-cljs` server. We don't want that. You could do something here but we don't need to do anything for CLJS."
msgstr "Proto REPLは接続時にこれを呼び出すので、このファイルは `user/reset` 関数を定義しなければなりません。もし `user/reset` が見つからなければ、`tools.namespace` を呼び出し、実行中の `shadow-cljs` サーバを破壊します。これは望ましくありません。ここで何かできるかもしれませんが、CLJSのために何もする必要はありません。"

msgid "2) add `[proto-repl \"0.3.1\"]` to your `:dependencies` in <<user-config, ~/.shadow-cljs/config.edn>> or `shadow-cljs.edn`."
msgstr "2) <<user-config, ~/.shadow-cljs/config.edn>> または `shadow-cljs.edn` の `:dependencies` に `[proto-repl \"0.3.1.1\"]` を追加する。"

msgid "3) Configure a fixed <<nREPL, nREPL port>>"
msgstr "3) 固定の <<nREPL, nREPLポート>> を設定します。"

msgid "4) Start `shadow-cljs server` or `shadow-cljs watch your-build`."
msgstr "4) `shadow-cljs server` または `shadow-cljs watch your-build` を起動する。"

msgid "5) Run the Atom Command `Proto Repl: Remote Nrepl Connection` connect to `localhost` and the port you configured"
msgstr "5) Atomコマンド `Proto Repl: Remote Nrepl Connection` で `localhost` と設定したポートに接続します。"

msgid "6) Eval `(shadow.cljs.devtools.api/watch :your-build)` (if you used `server` in 4)"
msgstr "6) 4で `server` を使った場合 `(shadow.cljs.devtools.api/watch :your-build)` を評価します。"

msgid "7) Eval `(shadow.cljs.devtools.api/nrepl-select :your-build)`. The REPL connection is now in CLJS mode, meaning that everything you eval will be eval'd in JS. You can eval `:repl/quit` to get back to Clojure Mode. If you get `[:no-worker :browser]` you need to start the `watch` first."
msgstr "7) `(shadow.cljs.devtools.api/nrepl-select :your-build)` の評価を行います。REPL接続はCLJSモードになっているので、evalしたものはすべてJSでevalされることになります。Clojureモードに戻るには `:repl/quit` と入力してください。もし `[:no-worker :browser]` が出たら、まず `watch` を起動する必要があります。"

msgid "8) Before you can eval CLJS you need to connect your client (eg. your Browser when building a `:browser` App)."
msgstr "8) CLJSを評価する前にクライアント（例えば `:browser` アプリを構築する際のブラウザ）を接続する必要があります。"

msgid "9) Eval some JS, eg. `(js/alert \"foo\")`. If you get `There is no connected JS runtime` the client is not connected properly. Otherwise the Browser should show an alert."
msgstr "9) JSを評価する、例えば `(js/alert \"foo\")`。 `There is no connected JS runtime` と表示されたらクライアントは正しく接続されていません。そうでなければブラウザにアラートが表示されるはずです。"

msgid "Chlorine (Atom)"
msgstr ""

msgid "Chlorine connects Atom to a Socket REPL, but also tries to refresh namespace. So first, open up Chlorine package config and check if configuration `Should we use clojure.tools.namespace to refresh` is set to `simple`, otherwise it'll destroy the running `shadow-cljs` server."
msgstr "ChlorineはAtomをSocket REPLに接続しますが名前空間をリフレッシュしようともします。そこでまずChlorineパッケージのconfigを開き、設定 `Should we use clojure.tools.namespace to refresh` が `simple` に設定されているかどうかを確認してください。"

msgid "Once you checked that the configuration is right, you can start your shadow app (replace `app` with whatever build):"
msgstr "設定が正しいことを確認したら shadow app を起動します。(`app` をビルドしたものに置き換えてください)"

msgid "$ shadow-cljs watch app"
msgstr ""

msgid "Now, all you have to do is to run the atom command `Chlorine: Connect Clojure Socket Repl`. This will connect a REPL to evaluate Clojure code. Next you need to run `Chlorine: Connect Embeded`, and it'll connect the ClojureScript REPL too."
msgstr "あとは、アトムコマンド `Chlorine: Connect Clojure Socket Repl` を実行するだけです、これでClojureコードを評価するためのREPLが接続されます。次に `Chlorine: Connect Embeded` を実行すると、ClojureScriptのREPLも接続されます。"

msgid "Now, you can use the `Chlorine: Evaluate...` commands to evaluate any Clojure or ClojureScript REPL. It'll evaluate `.clj` files as Clojure, and `cljc` files as ClojureScript."
msgstr "これで、`Chlorine: Evaluate…` コマンドを使って、任意のClojureやClojureScriptのREPLを評価できるようになりました。これは `.clj` ファイルを Clojure として、`cljc` ファイルを ClojureScript として評価します。"

msgid "Calva (VS Code)"
msgstr ""

msgid "(Only tested with `browser` targets so far. Probably works with other targets too.)"
msgstr "(今のところ `browser` ターゲットでしかテストしていません。おそらく他のターゲットでも動作します)"

msgid "You need VS Code and install the https://marketplace.visualstudio.com/items?itemName=betterthantomorrow.calva#overview[Calva] extension."
msgstr "VS Codeと https://marketplace.visualstudio.com/items?itemName=betterthantomorrow.calva#overview[Calva] の拡張機能をインストールします。"

msgid "Since Calva uses nREPL and the `cider-nrepl` middlewares you need to include this dependency in <<user-config, ~/.shadow-cljs/config.edn>> or `shadow-cljs.edn`:"
msgstr "Calva は nREPL と `cider-nrepl` ミドルウェアを使用しているので、この依存関係を <<user-config, ~/.shadow-cljs/config.edn>> または `shadow-cljs.edn` に含める必要があります。"

msgid "[cider/cider-nrepl \"0.21.0\"]"
msgstr ""

msgid "`shadow-cljs` will inject the required `cider-nrepl` middleware once it sees this dependency."
msgstr "`shadow-cljs` はこの依存関係を見つけると必要な `cider-nrepl` ミドルウェアを注入します。"

msgid "Connecting Calva to the REPLs"
msgstr ""

msgid "Once that is done start your shadow app. (Using whatever build instead of `app`.):"
msgstr "これが完了したら、シャドウアプリを起動します。(`app` の代わりに何でもいいからビルドしてください):"

msgid "Once the app is loaded in the browser, and you see `JS runime connected` in the terminal where you started the app, Calva can connect to its repl. Open the project in VS Code and Calva will by default try to auto connect and prompt you with a list of builds read from `shadow-cljs.edn`. Select the right one (`:app` in this example) and Calva's Clojure and Clojurescript support is activated."
msgstr "アプリがブラウザに読み込まれ、アプリを起動したターミナルに `JS runime connected` と表示されると、Calva はその repl に接続することができます。VS Codeでプロジェクトを開くとCalvaはデフォルトで自動接続を試み `shadow-cljs.edn` から読み込んだビルドのリストを表示します。正しいもの(この例では `:app`)を選択すると、CalvaのClojureとClojurescriptのサポートが有効になります。"

msgid "(If you already have the project open in VS Code when you start the app, issue the `Calva: Connect to a Running REPL Server in the Project` command.)"
msgstr "(アプリを起動したときにすでに VS Code でプロジェクトを開いている場合は `Calva: Connect to a Running REPL Server in the Project` コマンドを実行してください)"

msgid "Features"
msgstr ""

msgid "Some of the things you can now do:"
msgstr "今できることのいくつか:"

msgid "Intellisense and stuff"
msgstr "インテリセンスなど"

msgid "Peek at definitions on hover."
msgstr "hoverで定義を覗く"

msgid "Get auto completion help."
msgstr "自動補完の手助け"

msgid "Navigate to definitions (`cmd-click` on Mac, might be `ctrl-click` on Windows and Linux)."
msgstr "定義へ移動 (Macでは `cmd-click` 、WindowsやLinuxでは `ctrl-click`)"

msgid "Evaluation of the file, forms and selection"
msgstr "ファイルやフォーム、選択範囲の評価"

msgid "Evaluate the file: `ctrl+alt+c enter` (This is done automatically one opening files.)"
msgstr "ファイルを評価する: `ctrl+alt+c enter` (これはファイルを開くときに自動で行います)"

msgid "Evaluate inline: `ctrl+alt+c e`"
msgstr "インラインで評価: `ctrl+alt+c e`"

msgid "Evaluate and replace them in the editor: `ctrl+alt+c r`"
msgstr "エディタで評価して置き換える: `ctrl+alt+c r`"

msgid "Pretty print evaluation resuls: `ctrl+alt+c p`"
msgstr "評価結果をプリティプリント: `ctrl+alt+c p`"

msgid "Send forms to the integrated terminal repls for evaluation: `ctrl+alt+c alt+e`"
msgstr "評価のために統合されたreplにフォームを送る: `ctrl+alt+c alt+e`"

msgid "Run tests"
msgstr ""

msgid "Run namespace tests: `ctrl+alt+c t`"
msgstr "名前空間テストの実行: `ctrl+alt+c t`"

msgid "Run all tests: `ctrl+alt+c shift+t` (Really clunky in large projects so far.)"
msgstr "全体テスト: `ctrl+alt+c shift+t` (大規模プロジェクトではとても不便です)"

msgid "Rerun previously failing tests: `ctrl+alt+c ctrl+t`"
msgstr "以前に失敗したテストの再実行: `ctrl+alt+c ctrl+t`"

msgid "Test failures are marked in the explorer and editors and listed in the Problem tab for easy access."
msgstr "テストの失敗は、エクスプローラとエディタでマークされ、問題タブに一覧表示されるので、簡単にアクセスできます"

msgid "Terminal repls"
msgstr ""

msgid "Switch namespace in terminal repl to that of the currently open file: `ctrl+alt+c n`"
msgstr "ターミナルの名前空間を現在開いているファイルの名前空間に切り替える: `ctrl+alt+c n`"

msgid "Load current file and switch namespace in: `ctrl+alt+c alt+n`"
msgstr "現在のファイルをロードして名前空間を切り替える: `ctrl+alt+c alt+n`"

msgid "Cljc files"
msgstr ""

msgid "Switch between Clojure and Clojurescript repl `ctrl+alt+c ctrl+alt+t` (or click the green `cljc/clj` button in the status bar). This determines both which repl is backing the editor and what terminal repl is being accessed, see above."
msgstr "Clojure と Clojurescript replの切り替え `ctrl+alt+c ctrl+alt+t` (またはステータスバーの緑の `cljc/clj` ボタンをクリック)。これは、どの repl がエディタを支持しているかと、どのターミナルの repl がアクセスされているかを決定します"

msgid "Fireplace.vim (Vim/Neovim)"
msgstr ""

msgid "https://www.vim.org/scripts/script.php?script_id=4978[Fireplace.vim] is a Vim/Neovim plug-in which provides Clojure REPL integration by acting as an https://nrepl.org/[nREPL] client. When combined with Shadow-CLJS, it also provides ClojureScript REPL integration."
msgstr "https://www.vim.org/scripts/script.php?script_id=4978[Fireplace.vim] は https://nrepl.org/[nREPL] クライアントとして動作することでClojure REPLの統合を提供するVim/Neovimプラグインです。Shadow-CLJSと組み合わせるとClojureScriptのREPL統合も提供します。"

msgid "This guide uses as an example the app created in the official https://github.com/thheller/shadow-cljs#quick-start[Shadow-CLJS Quick Start] guide therefore refers to a few configuration items in the app's `shadow-cljs.edn`. That being said, these configuration items are fairly generic so should be applicable to other apps with minor modifications."
msgstr "このガイドでは公式 https://github.com/thheller/shadow-cljs#quick-start[Shadow-CLJS Quick Start] ガイドで作成されたアプリを例にしているため、アプリの `shadow-cljs.edn` の中のいくつかの設定項目を参照しています。つまり、これらの設定項目はかなり汎用的なものなので、ちょっとした修正で他のアプリにも適用できるはずです。"

msgid "Install https://www.vim.org/scripts/script.php?script_id=4978[Fireplace.vim] using your favorite method of installing plug-ins in Vim/Neovim."
msgstr "https://www.vim.org/scripts/script.php?script_id=4978[Fireplace.vim] をVim/Neovimで好きな方法でプラグインをインストールします。"

msgid "As an https://nrepl.org/[nREPL] client, https://www.vim.org/scripts/script.php?script_id=4978[Fireplace.vim] depends on https://docs.cider.mx/cider-nrepl/[CIDER-nREPL] (which is nREPL middleware that provides common, editor-agnostic REPL operations) therefore you need to include this dependency in <<user-config, ~/.shadow-cljs/config.edn>> or `shadow-cljs.edn` (as shown in the next sub-section.) Shadow-CLJS will inject the required CIDER-nREPL middleware once it sees this dependency."
msgstr "https://nrepl.org/[nREPL] クライアントとして https://www.vim.org/scripts/script.php?script_id=4978[Fireplace.vim] は https://docs.cider.mx/cider-nrepl/[CIDER-nREPL] に依存しています（これは一般的なエディタに依存しないREPL操作を提供するnREPLミドルウェアです）ので、この依存関係を <<user-config, ~/. shadow-cljs/config.edn>> または `shadow-cljs.edn` (次のサブセクションで示されているように) に含める必要があります。"

msgid "Preparing the app"
msgstr ""

msgid "Create the example app by following the official https://github.com/thheller/shadow-cljs#quick-start[Shadow-CLJS Quick Start] guide and modify its `shadow-cljs.edn` as follows:"
msgstr "公式 https://github.com/thheller/shadow-cljs#quick-start[Shadow-CLJS Quick Start] ガイドに従ってサンプルアプリを作成し、その `shadow-cljs.edn` を以下のように修正します。"

msgid ""
";; shadow-cljs configuration\n"
"{:source-paths\n"
" [\"src/dev\"\n"
"  \"src/main\"\n"
"  \"src/test\"]\n"
"\n"
" ;; ADD - CIDER-nREPL middleware required by Fireplace.vim\n"
" :dependencies\n"
" [[cider/cider-nrepl \"0.22.4\"]]\n"
"\n"
" ;; ADD - a port (e.g., 3333) for the REPL server to which Fireplace.vim connects\n"
" :nrepl\n"
" {:port 3333}\n"
"\n"
" ;; ADD - a port (e.g., 8080) for the development-time HTTP server that serves the app\n"
" :dev-http\n"
" {8080 \"public\"}\n"
"\n"
" :builds\n"
" {:frontend  ; NOTE - This is the build ID referenced at various places below.\n"
"  {:target :browser\n"
"   :modules {:main {:init-fn acme.frontend.app/init}}}}}"
msgstr ""
";; shadow-cljs configuration\n"
"{:source-paths\n"
" [\"src/dev\"\n"
"  \"src/main\"\n"
"  \"src/test\"]\n"
"\n"
" ;; 追加 - Fireplace.vimが必要とするCIDER-nREPLミドルウェア\n"
" :dependencies\n"
" [[cider/cider-nrepl \"0.22.4\"]]\n"
"\n"
" ;; 追加 - Fireplace.vimが接続するREPLサーバのポート（例：3333）\n"
" :nrepl\n"
" {:port 3333}\n"
"\n"
" ;; 追加 - アプリを提供する開発時HTTPサーバーのポート（例：8080）\n"
" :dev-http\n"
" {8080 \"public\"}\n"
"\n"
" :builds\n"
" {:frontend  ; 注意 - これは以下の様々な場所で参照されているビルドIDです\n"
"  {:target :browser\n"
"   :modules {:main {:init-fn acme.frontend.app/init}}}}}"

msgid "Once that is done, start the app (note the Shadow-CLJS build ID, `frontend`, specified in `shadow-cljs.edn`):"
msgstr "これが完了したらアプリを起動します（ `shadow-CLJS.edn` で指定されたShadow-CLJSのビルドIDである `frontend` に注意してください）"

msgid "npx shadow-cljs watch frontend"
msgstr "$ npx shadow-cljs watch frontend"

msgid "Open the app in a browser at http://localhost:8080/. Without this step, you would get the following error message from https://www.vim.org/scripts/script.php?script_id=4978[Fireplace.vim] if you attempt to connect to the REPL server from within Vim/Neovim:"
msgstr "http://localhost:8080/ でブラウザでアプリを開きます。このステップがないと、Vim/Neovim 内から REPL サーバーに接続しようとすると https://www.vim.org/scripts/script.php?script_id=4978[Fireplace.vim] から以下のようなエラーメッセージが表示されます。"

msgid ""
"No application has connected to the REPL server.\n"
"Make sure your JS environment has loaded your compiled ClojureScript code."
msgstr ""

msgid "Connecting Fireplace.vim to REPL Server"
msgstr ""

msgid "Open a ClojureScript source file in Vim/Neovim and execute the following command to connect https://www.vim.org/scripts/script.php?script_id=4978[Fireplace.vim] to the REPL server (note the port for the REPL server, `3333`, specified in `shadow-cljs.edn`):"
msgstr "Vim/NeovimでClojureScriptのソースファイルを開き、以下のコマンドを実行して https://www.vim.org/scripts/script.php?script_id=4978[Fireplace.vim] をREPLサーバに接続します（ `shadow-cljs.edn` で指定したREPLサーバのポート `3333` に注意してください）"

msgid ""
":Connect 3333\n"
"=>\n"
"Connected to nrepl://localhost:3333/\n"
"Scope connection to: ~/code/clojurescript/acme-app (ENTER)"
msgstr ""

msgid "This creates a Clojure (instead of ClojureScript) REPL session. Execute the following command to add ClojureScript support to the session (note the Shadow-CLJS build ID, `frontend`, specified in `shadow-cljs.edn`):"
msgstr "これによりClojure (ClojureScript の代わりに) REPL セッションが作成されます。セッションにClojureScriptのサポートを追加するには、以下のコマンドを実行してください（ `shadow-CLJS.edn` で指定されたShadow-CLJSのビルドID `frontend` に注意してください）"

msgid ""
":CljEval (shadow/repl :frontend)\n"
"=>\n"
"To quit, type: :cljs/quit\n"
"[:selected :frontend]\n"
"Press ENTER or type command to continue"
msgstr ""

msgid "You should now be able to execute https://www.vim.org/scripts/script.php?script_id=4978[Fireplace.vim] commands against the REPL server. Please refer to the https://www.vim.org/scripts/script.php?script_id=4978[Fireplace.vim] documentation for the full list of commands you can execute."
msgstr "これでREPLサーバに対して https://www.vim.org/scripts/script.php?script_id=4978[Fireplace.vim] コマンドを実行できるようになるはずです。実行可能なコマンドの完全なリストについては https://www.vim.org/scripts/script.php?script_id=4978[Fireplace.vim] のドキュメントを参照してください。"

msgid "Troubleshooting"
msgstr ""

msgid "Startup Errors"
msgstr ""

msgid "Sometimes `shadow-cljs` can fail to start properly. The errors are often very confusing and hard to identify. Most commonly this is caused by a few dependency conflicts on some of the important dependencies. When using just `shadow-cljs.edn` to manage your `:dependencies` it will provide a few extra checks to protect against these kinds of errors but when using `deps.edn` or `project.clj` these protections cannot be done so these errors happen more often when using those tools."
msgstr "時々 `shadow-cljs` が正しく起動できないことがあります。このエラーは非常に混乱していて識別するのが難しいことがよくあります。最も一般的には重要な依存関係のいくつかに依存関係の競合があることが原因です。 `shadow-cljs.edn` を使って `:dependencies` を管理しているときは、これらの種類のエラーから保護するためにいくつかの余分なチェックを提供しますが、`deps.edn` や `project.clj` を使っているときはこれらの保護ができないので、これらのツールを使っているときにこの類のエラーが起こることが多くなります。"

msgid "Generally the important dependencies to watch out for are"
msgstr "一般的に気を付けるべき重要な依存関係は"

msgid "org.clojure/clojure"
msgstr ""

msgid "org.clojure/clojurescript"
msgstr ""

msgid "org.clojure/core.async"
msgstr ""

msgid "com.google.javascript/closure-compiler-unshaded"
msgstr ""

msgid "Each `shadow-cljs` version is only tested with one particular combination of versions and it is recommended to stick with that version set for best compatibility. It might work when using different versions but if you encounter any kind of weird issues consider fixing your dependency versions first."
msgstr "それぞれの `shadow-cljs` バージョンは特定の組み合わせでしかテストされていないので、最高の互換性を得るためにはそのバージョンに固執することをお勧めします。異なるバージョンを使っていても動作するかもしれませんが、何か奇妙な問題が発生した場合は、まず依存関係のあるバージョンを修正することを検討してください。"

msgid "You can find the required dependencies for each version on clojars:"
msgstr "各バージョンに必要な依存関係は clojars で確認できます。"

msgid "https://clojars.org/thheller/shadow-cljs"
msgstr ""

msgid "The way to diagnose these issues vary by tool, so please refer to the appropriate section for further info."
msgstr "これらの問題の診断方法はツールによって異なりますので、詳細については適切なセクションを参照してください。"

msgid "Generally if you want to be sure you can just declare the matching dependency versions directly together with your chosen `shadow-cljs` version but that means you must also update those versions whenever you upgrade `shadow-cljs`. Correctly identifying where unwanted dependencies may be more work but will make future upgrades easier."
msgstr "一般的に確実にしたい場合は、マッチする依存関係のバージョンを選択した `shadow-cljs` のバージョンと一緒に直接宣言すればよいのですが、これは `shadow-cljs` をアップグレードするときには常にそれらのバージョンも更新しなければならないことを意味しています。不要な依存関係がどこにあるのかを正しく特定することはより多くの作業になりますが、将来のアップグレードをより簡単にすることができます。"

msgid "`shadow-cljs` will likely always be on the very latest version for all the listed dependencies above so if you need to stick with an older dependency you might need to stick with an older shadow-cljs version as well."
msgstr "`shadow-cljs` は上記に挙げた依存関係のすべてにおいて常に最新のバージョンである可能性が高いので、古い依存関係を維持する必要がある場合は古い shadow-cljs のバージョンを維持する必要があるかもしれません。"

msgid "`shadow-cljs` is very often several versions ahead on the `com.google.javascript/closure-compiler-unshaded` version it uses, so if you are depending on the version `org.clojure/clojurescript` normally supplies that might cause issues. Make sure the `thheller/shadow-cljs` version is picked over the version preferred by `org.clojure/clojurescript`."
msgstr "`shadow-cljs` は `com.google.javascript/closure-compiler-unshaded` のバージョンよりも数バージョン先にあることが多いので `org.clojure/clojurescript` が通常提供しているバージョンに依存している場合、問題が発生する可能性があります。 `thheller/shadow-cljs` のバージョンが `org.clojure/clojurescript` が好むバージョンよりも選択されていることを確認してください。"

msgid "If you want to make your live easier just use `shadow-cljs.edn` to manage your dependencies if you can. It is much less likely to have these problems or will at least warn you directly."
msgstr "もしあなたの暮らしを楽にしたいのであれば、できれば `shadow-cljs.edn` を使って依存関係を管理してください。その方が問題が発生しにくいですし、少なくとも直接警告を出してくれます。"

msgid "If you have ensured that you are getting all the correct versions but things still go wrong please open a https://github.com/thheller/shadow-cljs/issues[Github Issue] with a full problem description including your full dependency list."
msgstr "すべてのバージョンが正しいことを確認しているにもかかわらずうまくいかない場合は、 https://github.com/thheller/shadow-cljs/issues[Github Issue] を開いて依存関係のリストを含めた問題の詳細を説明してください。"

msgid "deps.edn / tools.deps"
msgstr ""

msgid "When using `deps.edn` to manage your dependencies via the <<tools-deps, :deps>> key in `shadow-cljs.edn` it is recommended to use the `clj` tool directly for further diagnosis. First you need to check which aliases you are applying via `shadow-cljs.edn`. So if you are setting `:deps {:aliases [:dev :cljs]}` you'll need to specify these aliases when running further commands."
msgstr "`deps.edn` を使って `shadow-cljs.edn` の <<tools-deps, :deps>> キーで依存関係を管理する場合、さらなる診断のためには `clj` ツールを直接使うことをお勧めします。まず `shadow-cljs.edn` でどの別名を適用しているかを確認する必要があります。そのため `:deps {:aliases [:dev :cljs]}` を設定している場合は、コマンドを実行する際にこれらの別名を指定する必要があります。"

msgid "First of all you should ensure that all dependencies directly declared in `deps.edn` have the expected version. Sometimes transitive dependencies can cause the inclusion of problematic versions. You can list all dependencies via:"
msgstr "まず第一に `deps.edn` で直接宣言された依存関係がすべて期待されたバージョンを持っていることを確認する必要があります。時々、移行的な依存関係が問題のあるバージョンを含む原因になることがあります。すべての依存関係をリストアップするには:"

msgid "Listing all active dependencies"
msgstr ""

msgid "$ clj -A:dev:cljs -Stree"
msgstr ""

msgid "This will list all the dependencies. Tracking this down is a bit manual but you'll need to verify that you get the correct versions for the dependencies mentioned above."
msgstr "これはすべての依存関係をリストアップします。これを追跡するのは少し手動ですが、上記の依存関係が正しいバージョンであることを確認する必要があります。"

msgid "Please refer to the official https://clojure.org/reference/deps_and_cli[tools.deps] documentation for further information."
msgstr "詳しくは公式の https://clojure.org/reference/deps_and_cli[tools.deps] のドキュメントを参照してください。"

msgid "project.clj / Leiningen"
msgstr ""

msgid "When using `project.clj` to manage you dependencies you'll need to specify your configured `:lein` profiles from `shadow-cljs.edn` when using `lein` directly to diagnose the problem. For example `:lein {:profiles \"+cljs\"}` would require `lein with-profiles +cljs` for every command."
msgstr "`project.clj` を使って依存関係を管理する場合、問題を診断するために `lein` を直接使う場合は `shadow-cljs.edn` から `:lein` の設定されたプロファイルを指定する必要があります。例えば `:lein {:profiles \"+cljs\"}` の場合 `lein with-profiles +cljs` をコマンドごとに指定する必要があります。"

msgid "Example listing of deps"
msgstr ""

msgid ""
"# no profile\n"
"$ lein deps :tree\n"
"\n"
"# with profile\n"
"$ lein with-profiles +cljs deps :tree"
msgstr ""

msgid "This will usually list all the current conflicts at the top and provide suggestions with the dependency tree at the bottom. The suggestions aren't always fully accurate so don't get mislead and don't add exclusions to the `thheller/shadow-cljs` artifact."
msgstr "これは通常、一番上に現在のすべての競合がリストアップされ、一番下に依存関係ツリーの提案が表示されます。提案は常に完全に正確とは限らないので、誤解を招かないようにし `thheller/shadow-cljs` アーティファクトに除外を追加しないようにしてください。"

msgid "Please refer to the https://leiningen.org/[Leiningen] documentation for more information."
msgstr "詳細は https://leiningen.org/[Leiningen] のドキュメントを参照してください。"

msgid "Getting a CLJS REPL working can sometimes be tricky and a lot can go wrong since all the moving parts can be quite complicated. This guide hopes to address the most common issues that people run into and how to fix them."
msgstr "CLJS REPLを動作させるには、時にトリッキーなことがあり、すべての可動部品が非常に複雑であるため、多くのことがうまくいかないことがあります。このガイドでは、人々が遭遇する最も一般的な問題とその解決方法について説明します。"

msgid "Anatomy of the CLJS REPL"
msgstr ""

msgid "A REPL in Clojure does exactly what the name implies: Read one form, Eval it, Print the result, Loop to do it again."
msgstr "ClojureのREPLはその名の通りのことをします。一つのフォームを読んで、それを評価して、結果を印刷して、ループして再び実行します。"

msgid "In ClojureScript however things are a bit more complicated since compilation happens on the JVM but the results are eval'd in a JavaScript runtime. There are a couple more steps that need to be done due in order to \"emulate\" the plain REPL experience. Although things are implemented a bit differently in `shadow-cljs` over regular CLJS the basic principles remain the same."
msgstr "しかし、ClojureScriptでは、コンパイルはJVM上で行われますが、結果はJavaScriptランタイムで評価されるので、物事はもう少し複雑です。プレインのREPLの経験を &#34;Emmulate &#34;するためには、さらにいくつかのステップが必要です。 `shadow-cljs` では通常のCLJSとは少し実装が異なりますが基本的な原則は変わりません。"

msgid "First you'll need a REPL client. This could just be the CLI (eg. `shadow-cljs cljs-repl app`) or your Editor connected via `nREPL`. The Client will always talk directly to the `shadow-cljs` server and it'll handle the rest. From the Client side it still looks like a regular REPL but there are a few more steps happening in the background."
msgstr "最初にREPLクライアントが必要です。これはCLI(例: `shadow-cljs cljs-repl app`)か `nREPL` を介して接続されたエディタです。クライアントは常に `shadow-cljs` サーバに直接話しかけるので、あとはそれが処理します。クライアント側からは通常のREPLのように見えますが、バックグラウンドでいくつかのステップがあります。"

msgid "1) Read: It all starts with reading a singular CLJS form from a given InputStream. That is either a blocking read directly from `stdin` or read from a string in case of `nREPL`. A Stream of characters are turned into actual datastructures, `\"(+ 1 2)\"` (a string) becomes `(+ 1 2)` (a list)."
msgstr "1) Read: すべては与えられたInputStreamからCLJSフォームを読み込むことから始まります。これは `stdin` から直接ブロッキングで読み込むか、 `nREPL` の場合は文字列から読み込むかのどちらかです。文字列のストリームは実際のデータ構造に変換され、`\"(+ 1 2)\"` (文字列)は `(+ 1 2)` (リスト)になります。"

msgid "2) Compile: That form is then compiled on the `shadow-cljs` JVM side and transformed to a set of instructions."
msgstr "2) Compile: そのフォームは `shadow-cljs` JVM側でコンパイルされ命令セットに変換されます。"

msgid "3) Transfer Out: Those instructions are transferred to a connected JavaScript runtime. This could be a Browser or a `node` process."
msgstr "3) Transfer Out: これらの命令は接続されたJavaScriptランタイムに転送されます。これはブラウザや `node` プロセスかもしれません。"

msgid "4) Eval: The connected runtime will take the received instructions and `eval` them."
msgstr "4) Eval: 接続されたランタイムは受信した命令を受け取り `eval` します。"

msgid "5) Print: The `eval` result is printed as a String in the JS runtime."
msgstr "5) Print: JSランタイムでは `eval` の結果が文字列として出力されます。"

msgid "6) Transfer Back: The printed result is transferred back to the `shadow-cljs` JVM side."
msgstr "6) Transfer Back: 印刷された結果は `shadow-cljs` JVM側に転送されます。"

msgid "7) Reply: The JVM side will forward the received results back to initial caller and the result is printed to the proper OutputStream (or sent as a nREPL message)."
msgstr "7) Reply: JVM側は、受信した結果を最初の呼び出し元に転送し、その結果を適切なOutputStreamに出力します（またはnREPLメッセージとして送信します）"

msgid "8) Loop: Repeat from 1)."
msgstr "8) Loop: 1)から繰り返します。"

msgid "JavaScript Runtimes"
msgstr ""

msgid "The `shadow-cljs` JVM side of things will require one running `watch` for a given build which will handle all the related REPL commands as well. It uses a dedicated thread and manages all the given events that can happen during development (eg. REPL input, changing files, etc)."
msgstr "`shadow-cljs` JVM側では関連するすべてのREPLコマンドを扱うビルド用に `watch` を実行している必要があります。これは専用のスレッドを使用し、開発中に発生する可能性のあるすべてのイベント(例: REPL入力、ファイルの変更など)を管理します。"

msgid "The compiled JS code however must also be loaded by a JS runtime (eg. Browser or `node` process) and that JS runtime must connect back to the running `shadow-cljs` process. Most `:target` configurations will have the necessary code added by default and should just connect automatically. How that connect is happening is dependent on the runtime but usually it is using a WebSocket to connect to the running `shadow-cljs` <<http, HTTP server>>."
msgstr "しかし、コンパイルされたJSコードはJSランタイム(ブラウザや `node` プロセスなど)によってロードされなければならず、そのJSランタイムは実行中の `shadow-cljs` プロセスに接続しなければなりません。ほとんどの `:target` の設定では必要なコードがデフォルトで追加されており、自動的に接続されます。どのように接続するかはランタイムに依存しますが、通常はWebSocketを使って実行中の `shadow-cljs` <<http, HTTP server>> に接続します。"

msgid "Once connected the REPL is ready to use. Note that reloading the JS runtime (eg. manual browser page reload) will wipe out all REPL state of the runtime but some of the compiler side state will remain until the `watch` is also restarted."
msgstr "接続されると、REPLは使用する準備ができています。JSランタイムをリロードすると(ブラウザのページを手動でリロードするなど)、ランタイムのREPLの状態はすべて消去されますがコンパイラ側の状態の一部は `watch` が再起動されるまで残りますので注意してください。"

msgid "It is possible for more than one JS runtime to connect to the `watch` process. `shadow-cljs` by default picks the first JS runtime that connected as the `eval` target. If you open a given `:browser` build in multiple Browsers only the first one will be used to `eval` code. Or you could be opening a `:react-native` app in iOS and Android next to each other during development. Only one runtime can eval and if that disconnects the next one takes over based on the time it connected."
msgstr "複数のJSランタイムが `watch` プロセスに接続することも可能です。デフォルトでは `shadow-cljs` は最初に接続した JS ランタイムを `eval` ターゲットとして選択します。与えられた `:browser` ビルドを複数のブラウザで開いた場合、最初のブラウザのみが `eval` コードに使われます。あるいは、開発中に iOS と Android で `:react-native` アプリを隣り合わせで開いているかもしれません。1つのランタイムだけがevalできるので、もしそれが切断された場合は、接続した時間に基づいて次のランタイムが引き継ぐことができます。"

msgid "Missing JS runtime"
msgstr ""

msgid "No application has connected to the REPL server. Make sure your JS environment has loaded your compiled ClojureScript code."
msgstr ""

msgid "This error message just means that no JS runtime (eg. Browser) has connected to the `shadow-cljs` server. Your REPL client has successfully connected to the `shadow-cljs` server but as explained above we still need a JS runtime to actually `eval` anything."
msgstr "このエラーメッセージは、JS ランタイム (例えばブラウザ) が `shadow-cljs` サーバに接続していないことを意味しています。REPLクライアントは `shadow-cljs` サーバに正常に接続しましたが、上で説明したように、実際に何かを `eval` するにはまだJSランタイムが必要です。"

msgid "Regular `shadow-cljs` builds do not manage any JS runtime of their own so you are responsible for running them."
msgstr "通常の `shadow-cljs` ビルドは独自の JS ランタイムを管理していないので、あなたが責任を持って実行してください。"

msgid ":target :browser"
msgstr ""

msgid "For <<target-browser, `:target :browser`>> builds the `watch` process will have compiled the given code to a configured `:output-dir` (defaults to `public/js`). The generated `.js` must be loaded in a browser. Once loaded the Browser Console should show a `WebSocket connected` message. If you are using any kind of custom HTTP servers or have over-eager firewalls blocking the connections you might need to set some additional configuration (eg. via <<proxy-support, :devtools-url>>). The goal is to be able to connect to the <<http, primary HTTP server>>."
msgstr "<<target-browser, `:target :browser`>> のビルドでは `watch` プロセスは指定されたコードを設定された `:output-dir` (デフォルトは `public/js`) にコンパイルします。生成された `.js` はブラウザで読み込まなければなりません。ロードされると、ブラウザコンソールに `WebSocket connected` のメッセージが表示されるはずです。カスタムの HTTP サーバを使用していたり、過度に熱心なファイアウォールが接続をブロックしている場合は、追加の設定が必要になるかもしれません (例: <<proxy-support, :devtools-url>>)。目標は <<http, primary HTTP server>> に接続できるようにすることです。"

msgid ":target :node-script, :node-library"
msgstr ""

msgid "These targets will have produced a `.js` file that are intended to run in a `node` process. Given the variety of options however you'll need to run them yourself. For example a `:node-script` you'd run via `node the-script.js` and on startup it'll try to connect to the `shadow-cljs` server. You should see a `WebSocket connected` message on startup. The output is designed to only run on the machine they were compiled on, don't copy `watch` output to other machines."
msgstr "これらのターゲットは `node` プロセスで実行することを意図した `.js` ファイルを生成します。しかしさまざまなオプションがあるため自分で実行する必要があります。例えば `:node-script` は `node-script.js` で実行し、起動時に `shadow-cljs` サーバに接続しようとします。起動時に `WebSocket connected` というメッセージが表示されるはずです。出力はコンパイルされたマシン上でのみ動作するように設計されているので `watch` の出力を他のマシンにコピーしないようにしてください。"

msgid ":target :react-native"
msgstr ""

msgid "The generated `<:output-dir>/index.js` file needs to be added to your `react-native` app and then loaded on an actual device or emulator. On startup it will also attempt to connect to the `shadow-cljs` server. You can check the log output via `react-native log-android|log-ios` and should show a `WebSocket connected` message once the app is running. If you see a websocket related error on startup instead it may have failed to connect to the shadow-cljs process. This can happen when the IP detection picked an incorrect IP. You can check which IP was used via `shadow-cljs watch app --verbose` and override it via `shadow-cljs watch app --config-merge '{:local-ip \"1.2.3.4\"}'`."
msgstr "生成された `<:output-dir>/index.js` ファイルを `react-native` アプリに追加し、実際のデバイスやエミュレータにロードする必要があります。起動時には `shadow-cljs` サーバへの接続も試みます。 `react-native log-android|log-ios` でログ出力を確認することができ、アプリが実行されると `WebSocket connected` というメッセージが表示されるはずです。起動時にWebsocket関連のエラーが表示される場合は、shadow-cljsプロセスへの接続に失敗した可能性があります。これは、IP検出が間違ったIPを選択した場合に発生する可能性があります。どのIPが使われたかは `shadow-cljs watch app --verbose` で確認し、 `shadow-cljs watch app --config-merge '{:local-ip \"1.2.3.4\"}'` で上書きすることができます。"

msgid "Publishing Libraries"
msgstr ""

msgid "ClojureScript libraries are published to `maven` repositories just like Clojure. Most commonly they are published to https://clojars.org/[Clojars] but all other standard maven repositories work too."
msgstr "ClojureScript ライブラリは Clojure と同様に `maven` リポジトリに公開されています。最も一般的には https://clojars.org/[Clojars] に公開されていますが、他の標準的な maven リポジトリでも動作します。"

msgid "`shadow-cljs` itself does not have direct support for publishing but since ClojureScript libraries are just uncompiled source files published in a JAR (basically just a ZIP compressed file) any common tool that is able to publish to maven will work. (eg. `mvn`, `gradle`, `lein`, etc). No extra compilation or other steps are required to publish. The ClojureScript compiler and therefore shadow-cljs is not involved at all."
msgstr "`shadow-cljs` 自体はパブリッシュを直接サポートしていませんが、ClojureScriptライブラリはコンパイルされていないソースファイルをJAR(基本的にはZIP圧縮ファイル)で公開しているだけなので、mavenにパブリッシュできる一般的なツールであればどんなものでも動作します。(例: `mvn`, `gradle`, `lein` など)。パブリッシュするために余分なコンパイルや他のステップは必要ありません。ClojureScriptコンパイラとそのためのshadow-cljsは全く関与していません。"

msgid "There are a variety of options to publish libraries and I currently recommend https://leiningen.org/[Leiningen]. The setup is very straightforward and doesn't require much configuration at all."
msgstr "ライブラリを公開するには様々なオプションがありますが、私が現在推奨しているのは https://leiningen.org/[Leiningen] です。セットアップは非常に簡単で、設定は全く必要ありません。"

msgid "This does not mean that you have to use Leiningen during development of the library itself. It is recommended to just use Leiningen for publishing but use `shadow-cljs` normally otherwise. You'll only need to copy the actual `:dependencies` definition once you publish. Remember to keep development related dependencies out though."
msgstr "これはライブラリ自体の開発中にLeiningenを使わなければならないということではありません。パブリッシュにはLeiningenを使うだけで、それ以外の場合は通常通り `shadow-cljs` を使うことをお勧めします。パブリッシュ時に実際の `:dependencies` 定義をコピーするだけで済みます。ただし、開発に関連した依存関係は除外しておくことを忘れないでください。"

msgid "Assuming you are already using the recommended project structure where all your primary sources are located in `src/main` you can publish with a very simple `project.clj`."
msgstr "すでに推奨されているプロジェクト構造を使用していると仮定すると、すべてのプライマリソースが `src/main` に配置されており、非常にシンプルな `project.clj` でパブリッシュすることができます。"

msgid ""
"(defproject your.cool/library \"1.0.0\"\n"
"  :description \"Does cool stuff\"\n"
"  :url \"https://the.inter.net/wherever\"\n"
"\n"
"  ;; this is optional, add what you want or remove it\n"
"  :license {:name \"Eclipse Public License\"\n"
"            :url \"http://www.eclipse.org/legal/epl-v10.html\"}\n"
"\n"
"  :dependencies\n"
"  ;; always use \"provided\" for Clojure(Script)\n"
"  [[org.clojure/clojurescript \"1.10.520\" :scope \"provided\"]\n"
"   [some.other/library \"1.0.0\"]\n"
"\n"
"  :source-paths\n"
"  [\"src/main\"])"
msgstr ""
"(defproject your.cool/library \"1.0.0\"\n"
"  :description \"Does cool stuff\"\n"
"  :url \"https://the.inter.net/wherever\"\n"
"\n"
"  ;; これはオプションで、必要なものを追加するか削除します\n"
"  :license {:name \"Eclipse Public License\"\n"
"            :url \"http://www.eclipse.org/legal/epl-v10.html\"}\n"
"\n"
"  :dependencies\n"
"  ;; Clojure(Script)では、必ず\"provided\"を使います\n"
"  [[org.clojure/clojurescript \"1.10.520\" :scope \"provided\"]\n"
"   [some.other/library \"1.0.0\"]\n"
"\n"
"  :source-paths\n"
"  [\"src/main\"])"

msgid "This will generate the required `pom.xml` and put all sources from `src/main` into the published `.jar` file. All you need to run is `lein deploy clojars` to publish it. When doing this for the first time you'll first need to setup proper authentication. Please refer to the official  https://github.com/technomancy/leiningen/blob/stable/doc/DEPLOY.md[Leiningen] and https://github.com/clojars/clojars-web/wiki/Tutorial[Clojars] documentation on how to set that up."
msgstr "これは必要な `pom.xml` を生成し `src/main` からのすべてのソースを公開された `.jar` ファイルに入れます。これを公開するために必要なのは `lein deploy clojars` を実行することだけです。初めてこの作業を行う際には、まず適切な認証を設定する必要があります。設定方法は公式の https://github.com/technomancy/leiningen/blob/stable/doc/DEPLOY.md[Leiningen] や https://github.com/clojars/clojars-web/wiki/Tutorial[Clojars] のドキュメントを参照してください。"

msgid "Disable JAR Signing"
msgstr ""

msgid "Leiningen defaults to signing libraries via GPG before publishing which is a good default but given that this can be a hassle to setup and not many people are actually verifying the signatures you can disable that step via adding a simple `:repositories` config to the `project.clj`."
msgstr "Leiningenのデフォルトでは、公開する前にGPG経由でライブラリに署名するのが良いデフォルトですが、これはセットアップが面倒で、実際に署名を検証する人が多くないことを考えると、`project.clj` にシンプルな `:repositories` の設定を追加することで、そのステップを無効にすることができます。"

msgid ""
"(defproject your.cool/library \"1.0.0\"\n"
"  ...\n"
"  :repositories\n"
"  {\"clojars\" {:url \"https://clojars.org/repo\"\n"
"              :sign-releases false}}\n"
"  ...)"
msgstr ""

msgid "Keep your JAR clean"
msgstr ""

msgid "If you write tests or user other development related code for your library make sure to keep them in `src/dev` or `src/test` to avoid publishing them together with the library."
msgstr "ライブラリのためにテストやユーザなどの開発関連のコードを書く場合は、ライブラリと一緒に公開しないように `src/dev` または `src/test` に入れておいてください。"

msgid "Also avoid generating output to `resources/*` since Leiningen and other tools may include those files into the `.jar` which may cause problems for downstream users. Your `.jar` should ONLY contains the actual source files, no compiled code at all."
msgstr "また `resources/*` への出力は避けてください。Leiningenや他のツールがそれらのファイルを `.jar` に含めている可能性があり、下流のユーザに問題を引き起こす可能性があります。あなたの `.jar` には実際のソースファイルのみが含まれ、コンパイルされたコードは一切含まれていません。"

msgid "You can and should verify that everything is clean by running `lein jar` and inspecting the files that end up in it via `jar -tvf target/library-1.0.0.jar`."
msgstr "すべてがクリーンであることを確認するには `lein jar` を実行し、 `jar -tvf target/library-1.0.0.jar` でその中にあるファイルを検査します。"

msgid "Declaring JS dependencies"
msgstr ""

msgid "Please note that currently only `shadow-cljs` has a clean automatic interop story with `npm`. That may represent a problem for users of your libraries using other tools. You may want to consider providing a CLJSJS fallback and/or publishing extra documentation for `webpack` related workflows."
msgstr "現在 `shadow-cljs` だけが `npm` とのクリーンな自動相互接続ストーリーを持っていることに注意してください。これは他のツールを使っているライブラリのユーザにとっては問題かもしれません。CLJSJSフォールバックの提供や `webpack` 関連のワークフローのための追加ドキュメントの公開を検討してみてはいかがでしょうか。"

msgid "You can declare `npm` dependencies directly by including a `deps.cljs` with `:npm-deps` in your project (eg. `src/main/deps.cljs`)."
msgstr "依存関係を直接宣言するには `deps.cljs` に `:npm-deps` を付けてプロジェクトに追加します (例: `src/main/deps.cljs`)"

msgid "Example src/main/deps.cljs"
msgstr ""

msgid "{:npm-deps {\"the-thing\" \"1.0.0\"}}"
msgstr ""

msgid "You can also provide extra `:foreign-libs` definitions here. They won't affect `shadow-cljs` but might help other tools."
msgstr "ここに `:foreign-libs` の定義を追加することもできます。これらは `shadow-cljs` には影響しませんが、他のツールの助けになるかもしれません。"

msgid "What to do when things don’t work?"
msgstr "うまくいかない時の対処法は？"

msgid "Since the JS world is still evolving rapidly and not everyone is using the same way to write and distribute code there are some things `shadow-cljs` cannot work around automatically. These can usually be solved with custom `:resolve` configs, but there may also be bugs or oversights."
msgstr "JS の世界はまだ急速に進化しており、誰もが同じ方法でコードを書いて配布しているわけではないので `shadow-cljs` が自動的に回避できないことがいくつかあります。これらは通常カスタムの `:resolve` 設定で解決できますが、バグや見落としがあるかもしれません。"

msgid "If you cannot resolve such an issue with the instructions in this chapter, then try asking on the https://clojurians.slack.com/messages/C6N245JGG[`#shadow-cljs` Slack channel]."
msgstr "この章の指示でこのような問題を解決できない場合は https://clojurians.slack.com/messages/C6N245JGG[`#shadow-cljs` Slackチャンネル] で質問してみてください。"

msgid "Hacking"
msgstr ""

msgid "Patching Libraries"
msgstr ""

msgid "The `shadow-cljs` compiler ensures that things on your source paths are compiled first, overriding files from JARs. This means that you can copy a source file from a library, patch it, and include it in your own source directory."
msgstr "`shadow-cljs` コンパイラは、ソースパス上のものが最初にコンパイルされ、JARからのファイルを上書きすることを保証します。これは、ライブラリからソースファイルをコピーしてパッチを当て、自分のソースディレクトリにインクルードすることができることを意味します。"

msgid "Shadow CLJS User&#8217;s Guide"
msgstr ""
